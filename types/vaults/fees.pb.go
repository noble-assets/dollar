// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v1/fees.proto

package vaults

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// FeeType defines the different types of fees that can be collected
type FeeType int32

const (
	// Management fee charged periodically
	FEE_TYPE_MANAGEMENT FeeType = 0
	// Performance fee on positive returns
	FEE_TYPE_PERFORMANCE FeeType = 1
	// Deposit fee charged on entry
	FEE_TYPE_DEPOSIT FeeType = 2
	// Withdrawal fee charged on exit
	FEE_TYPE_WITHDRAWAL FeeType = 3
	// Cross-chain operation fee
	FEE_TYPE_CROSS_CHAIN FeeType = 4
	// Emergency operation fee
	FEE_TYPE_EMERGENCY FeeType = 5
)

var FeeType_name = map[int32]string{
	0: "FEE_TYPE_MANAGEMENT",
	1: "FEE_TYPE_PERFORMANCE",
	2: "FEE_TYPE_DEPOSIT",
	3: "FEE_TYPE_WITHDRAWAL",
	4: "FEE_TYPE_CROSS_CHAIN",
	5: "FEE_TYPE_EMERGENCY",
}

var FeeType_value = map[string]int32{
	"FEE_TYPE_MANAGEMENT":  0,
	"FEE_TYPE_PERFORMANCE": 1,
	"FEE_TYPE_DEPOSIT":     2,
	"FEE_TYPE_WITHDRAWAL":  3,
	"FEE_TYPE_CROSS_CHAIN": 4,
	"FEE_TYPE_EMERGENCY":   5,
}

func (x FeeType) String() string {
	return proto.EnumName(FeeType_name, int32(x))
}

func (FeeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4005b30a35fc5b42, []int{0}
}

// FeeCollectionMethod defines how fees are collected
type FeeCollectionMethod int32

const (
	// Fees collected through share dilution
	COLLECTION_SHARE_DILUTION FeeCollectionMethod = 0
	// Fees collected in tokens directly
	COLLECTION_TOKEN_DIRECT FeeCollectionMethod = 1
	// Fees collected through NAV adjustment
	COLLECTION_NAV_ADJUSTMENT FeeCollectionMethod = 2
)

var FeeCollectionMethod_name = map[int32]string{
	0: "COLLECTION_SHARE_DILUTION",
	1: "COLLECTION_TOKEN_DIRECT",
	2: "COLLECTION_NAV_ADJUSTMENT",
}

var FeeCollectionMethod_value = map[string]int32{
	"COLLECTION_SHARE_DILUTION": 0,
	"COLLECTION_TOKEN_DIRECT":   1,
	"COLLECTION_NAV_ADJUSTMENT": 2,
}

func (x FeeCollectionMethod) String() string {
	return proto.EnumName(FeeCollectionMethod_name, int32(x))
}

func (FeeCollectionMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4005b30a35fc5b42, []int{1}
}

// FeeConfig defines the configuration for various fees
type FeeConfig struct {
	// Management fee rate (annual basis points)
	ManagementFeeRate int32 `protobuf:"varint,1,opt,name=management_fee_rate,json=managementFeeRate,proto3" json:"management_fee_rate,omitempty"`
	// Performance fee rate (basis points)
	PerformanceFeeRate int32 `protobuf:"varint,2,opt,name=performance_fee_rate,json=performanceFeeRate,proto3" json:"performance_fee_rate,omitempty"`
	// Deposit fee rate (basis points)
	DepositFeeRate int32 `protobuf:"varint,3,opt,name=deposit_fee_rate,json=depositFeeRate,proto3" json:"deposit_fee_rate,omitempty"`
	// Withdrawal fee rate (basis points)
	WithdrawalFeeRate int32 `protobuf:"varint,4,opt,name=withdrawal_fee_rate,json=withdrawalFeeRate,proto3" json:"withdrawal_fee_rate,omitempty"`
	// Cross-chain operation fee rate (basis points)
	CrossChainFeeRate int32 `protobuf:"varint,5,opt,name=cross_chain_fee_rate,json=crossChainFeeRate,proto3" json:"cross_chain_fee_rate,omitempty"`
	// Emergency operation fee rate (basis points)
	EmergencyFeeRate int32 `protobuf:"varint,6,opt,name=emergency_fee_rate,json=emergencyFeeRate,proto3" json:"emergency_fee_rate,omitempty"`
	// Fee collection method
	CollectionMethod FeeCollectionMethod `protobuf:"varint,7,opt,name=collection_method,json=collectionMethod,proto3,enum=noble.dollar.vaults.v1.FeeCollectionMethod" json:"collection_method,omitempty"`
	// Fee recipient address
	FeeRecipient string `protobuf:"bytes,8,opt,name=fee_recipient,json=feeRecipient,proto3" json:"fee_recipient,omitempty"`
	// Whether fees are enabled
	FeesEnabled bool `protobuf:"varint,9,opt,name=fees_enabled,json=feesEnabled,proto3" json:"fees_enabled,omitempty"`
	// High water mark for performance fees
	HighWaterMark cosmossdk_io_math.LegacyDec `protobuf:"bytes,10,opt,name=high_water_mark,json=highWaterMark,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"high_water_mark"`
}

func (m *FeeConfig) Reset()         { *m = FeeConfig{} }
func (m *FeeConfig) String() string { return proto.CompactTextString(m) }
func (*FeeConfig) ProtoMessage()    {}
func (*FeeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4005b30a35fc5b42, []int{0}
}
func (m *FeeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeConfig.Merge(m, src)
}
func (m *FeeConfig) XXX_Size() int {
	return m.Size()
}
func (m *FeeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_FeeConfig proto.InternalMessageInfo

func (m *FeeConfig) GetManagementFeeRate() int32 {
	if m != nil {
		return m.ManagementFeeRate
	}
	return 0
}

func (m *FeeConfig) GetPerformanceFeeRate() int32 {
	if m != nil {
		return m.PerformanceFeeRate
	}
	return 0
}

func (m *FeeConfig) GetDepositFeeRate() int32 {
	if m != nil {
		return m.DepositFeeRate
	}
	return 0
}

func (m *FeeConfig) GetWithdrawalFeeRate() int32 {
	if m != nil {
		return m.WithdrawalFeeRate
	}
	return 0
}

func (m *FeeConfig) GetCrossChainFeeRate() int32 {
	if m != nil {
		return m.CrossChainFeeRate
	}
	return 0
}

func (m *FeeConfig) GetEmergencyFeeRate() int32 {
	if m != nil {
		return m.EmergencyFeeRate
	}
	return 0
}

func (m *FeeConfig) GetCollectionMethod() FeeCollectionMethod {
	if m != nil {
		return m.CollectionMethod
	}
	return COLLECTION_SHARE_DILUTION
}

func (m *FeeConfig) GetFeeRecipient() string {
	if m != nil {
		return m.FeeRecipient
	}
	return ""
}

func (m *FeeConfig) GetFeesEnabled() bool {
	if m != nil {
		return m.FeesEnabled
	}
	return false
}

// ShareDilutionParams defines parameters for fee collection through share dilution
type ShareDilutionParams struct {
	// Target dilution rate (basis points per year)
	TargetDilutionRate int32 `protobuf:"varint,1,opt,name=target_dilution_rate,json=targetDilutionRate,proto3" json:"target_dilution_rate,omitempty"`
	// Minimum dilution amount per period
	MinDilutionAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=min_dilution_amount,json=minDilutionAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_dilution_amount"`
	// Maximum dilution amount per period
	MaxDilutionAmount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=max_dilution_amount,json=maxDilutionAmount,proto3,customtype=cosmossdk.io/math.Int" json:"max_dilution_amount"`
	// Dilution frequency (seconds)
	DilutionFrequency int64 `protobuf:"varint,4,opt,name=dilution_frequency,json=dilutionFrequency,proto3" json:"dilution_frequency,omitempty"`
	// Last dilution timestamp
	LastDilution time.Time `protobuf:"bytes,5,opt,name=last_dilution,json=lastDilution,proto3,stdtime" json:"last_dilution"`
}

func (m *ShareDilutionParams) Reset()         { *m = ShareDilutionParams{} }
func (m *ShareDilutionParams) String() string { return proto.CompactTextString(m) }
func (*ShareDilutionParams) ProtoMessage()    {}
func (*ShareDilutionParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_4005b30a35fc5b42, []int{1}
}
func (m *ShareDilutionParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShareDilutionParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShareDilutionParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShareDilutionParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShareDilutionParams.Merge(m, src)
}
func (m *ShareDilutionParams) XXX_Size() int {
	return m.Size()
}
func (m *ShareDilutionParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ShareDilutionParams.DiscardUnknown(m)
}

var xxx_messageInfo_ShareDilutionParams proto.InternalMessageInfo

func (m *ShareDilutionParams) GetTargetDilutionRate() int32 {
	if m != nil {
		return m.TargetDilutionRate
	}
	return 0
}

func (m *ShareDilutionParams) GetDilutionFrequency() int64 {
	if m != nil {
		return m.DilutionFrequency
	}
	return 0
}

func (m *ShareDilutionParams) GetLastDilution() time.Time {
	if m != nil {
		return m.LastDilution
	}
	return time.Time{}
}

// FeeAccrual represents accrued fees for a specific period
type FeeAccrual struct {
	// Fee type
	FeeType FeeType `protobuf:"varint,1,opt,name=fee_type,json=feeType,proto3,enum=noble.dollar.vaults.v1.FeeType" json:"fee_type,omitempty"`
	// Accrued amount
	AccruedAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=accrued_amount,json=accruedAmount,proto3,customtype=cosmossdk.io/math.Int" json:"accrued_amount"`
	// Shares to be diluted for this fee
	SharesToDilute cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=shares_to_dilute,json=sharesToDilute,proto3,customtype=cosmossdk.io/math.Int" json:"shares_to_dilute"`
	// Accrual period start
	PeriodStart time.Time `protobuf:"bytes,4,opt,name=period_start,json=periodStart,proto3,stdtime" json:"period_start"`
	// Accrual period end
	PeriodEnd time.Time `protobuf:"bytes,5,opt,name=period_end,json=periodEnd,proto3,stdtime" json:"period_end"`
	// Whether this accrual has been collected
	Collected bool `protobuf:"varint,6,opt,name=collected,proto3" json:"collected,omitempty"`
}

func (m *FeeAccrual) Reset()         { *m = FeeAccrual{} }
func (m *FeeAccrual) String() string { return proto.CompactTextString(m) }
func (*FeeAccrual) ProtoMessage()    {}
func (*FeeAccrual) Descriptor() ([]byte, []int) {
	return fileDescriptor_4005b30a35fc5b42, []int{2}
}
func (m *FeeAccrual) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeAccrual) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeAccrual.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeAccrual) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeAccrual.Merge(m, src)
}
func (m *FeeAccrual) XXX_Size() int {
	return m.Size()
}
func (m *FeeAccrual) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeAccrual.DiscardUnknown(m)
}

var xxx_messageInfo_FeeAccrual proto.InternalMessageInfo

func (m *FeeAccrual) GetFeeType() FeeType {
	if m != nil {
		return m.FeeType
	}
	return FEE_TYPE_MANAGEMENT
}

func (m *FeeAccrual) GetPeriodStart() time.Time {
	if m != nil {
		return m.PeriodStart
	}
	return time.Time{}
}

func (m *FeeAccrual) GetPeriodEnd() time.Time {
	if m != nil {
		return m.PeriodEnd
	}
	return time.Time{}
}

func (m *FeeAccrual) GetCollected() bool {
	if m != nil {
		return m.Collected
	}
	return false
}

// FeeCollection represents a completed fee collection event
type FeeCollection struct {
	// Collection timestamp
	Timestamp time.Time `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Total fee amount collected
	TotalAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_amount,json=totalAmount,proto3,customtype=cosmossdk.io/math.Int" json:"total_amount"`
	// Shares diluted for collection
	SharesDiluted cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=shares_diluted,json=sharesDiluted,proto3,customtype=cosmossdk.io/math.Int" json:"shares_diluted"`
	// Collection method used
	Method FeeCollectionMethod `protobuf:"varint,4,opt,name=method,proto3,enum=noble.dollar.vaults.v1.FeeCollectionMethod" json:"method,omitempty"`
	// Breakdown by fee type
	Breakdown []*FeeTypeBreakdown `protobuf:"bytes,5,rep,name=breakdown,proto3" json:"breakdown,omitempty"`
	// Block height when collected
	BlockHeight int64 `protobuf:"varint,6,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
}

func (m *FeeCollection) Reset()         { *m = FeeCollection{} }
func (m *FeeCollection) String() string { return proto.CompactTextString(m) }
func (*FeeCollection) ProtoMessage()    {}
func (*FeeCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_4005b30a35fc5b42, []int{3}
}
func (m *FeeCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeCollection.Merge(m, src)
}
func (m *FeeCollection) XXX_Size() int {
	return m.Size()
}
func (m *FeeCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeCollection.DiscardUnknown(m)
}

var xxx_messageInfo_FeeCollection proto.InternalMessageInfo

func (m *FeeCollection) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *FeeCollection) GetMethod() FeeCollectionMethod {
	if m != nil {
		return m.Method
	}
	return COLLECTION_SHARE_DILUTION
}

func (m *FeeCollection) GetBreakdown() []*FeeTypeBreakdown {
	if m != nil {
		return m.Breakdown
	}
	return nil
}

func (m *FeeCollection) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// FeeTypeBreakdown provides details for each fee type in a collection
type FeeTypeBreakdown struct {
	// Fee type
	FeeType FeeType `protobuf:"varint,1,opt,name=fee_type,json=feeType,proto3,enum=noble.dollar.vaults.v1.FeeType" json:"fee_type,omitempty"`
	// Amount for this fee type
	Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// Shares diluted for this fee type
	SharesDiluted cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=shares_diluted,json=sharesDiluted,proto3,customtype=cosmossdk.io/math.Int" json:"shares_diluted"`
	// Fee rate applied (basis points)
	RateApplied int32 `protobuf:"varint,4,opt,name=rate_applied,json=rateApplied,proto3" json:"rate_applied,omitempty"`
}

func (m *FeeTypeBreakdown) Reset()         { *m = FeeTypeBreakdown{} }
func (m *FeeTypeBreakdown) String() string { return proto.CompactTextString(m) }
func (*FeeTypeBreakdown) ProtoMessage()    {}
func (*FeeTypeBreakdown) Descriptor() ([]byte, []int) {
	return fileDescriptor_4005b30a35fc5b42, []int{4}
}
func (m *FeeTypeBreakdown) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeTypeBreakdown) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeTypeBreakdown.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeTypeBreakdown) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeTypeBreakdown.Merge(m, src)
}
func (m *FeeTypeBreakdown) XXX_Size() int {
	return m.Size()
}
func (m *FeeTypeBreakdown) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeTypeBreakdown.DiscardUnknown(m)
}

var xxx_messageInfo_FeeTypeBreakdown proto.InternalMessageInfo

func (m *FeeTypeBreakdown) GetFeeType() FeeType {
	if m != nil {
		return m.FeeType
	}
	return FEE_TYPE_MANAGEMENT
}

func (m *FeeTypeBreakdown) GetRateApplied() int32 {
	if m != nil {
		return m.RateApplied
	}
	return 0
}

// FeeStats provides statistics about fee collection
type FeeStats struct {
	// Total fees collected (all time)
	TotalFeesCollected cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_fees_collected,json=totalFeesCollected,proto3,customtype=cosmossdk.io/math.Int" json:"total_fees_collected"`
	// Total shares diluted for fees
	TotalSharesDiluted cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_shares_diluted,json=totalSharesDiluted,proto3,customtype=cosmossdk.io/math.Int" json:"total_shares_diluted"`
	// Current annualized fee rate (basis points)
	CurrentAnnualRate int32 `protobuf:"varint,3,opt,name=current_annual_rate,json=currentAnnualRate,proto3" json:"current_annual_rate,omitempty"`
	// Last fee collection timestamp
	LastCollection time.Time `protobuf:"bytes,4,opt,name=last_collection,json=lastCollection,proto3,stdtime" json:"last_collection"`
	// Average daily fee collection
	AvgDailyCollection cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=avg_daily_collection,json=avgDailyCollection,proto3,customtype=cosmossdk.io/math.Int" json:"avg_daily_collection"`
	// Fee collection frequency (seconds)
	CollectionFrequency int64 `protobuf:"varint,6,opt,name=collection_frequency,json=collectionFrequency,proto3" json:"collection_frequency,omitempty"`
}

func (m *FeeStats) Reset()         { *m = FeeStats{} }
func (m *FeeStats) String() string { return proto.CompactTextString(m) }
func (*FeeStats) ProtoMessage()    {}
func (*FeeStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_4005b30a35fc5b42, []int{5}
}
func (m *FeeStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeStats.Merge(m, src)
}
func (m *FeeStats) XXX_Size() int {
	return m.Size()
}
func (m *FeeStats) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeStats.DiscardUnknown(m)
}

var xxx_messageInfo_FeeStats proto.InternalMessageInfo

func (m *FeeStats) GetCurrentAnnualRate() int32 {
	if m != nil {
		return m.CurrentAnnualRate
	}
	return 0
}

func (m *FeeStats) GetLastCollection() time.Time {
	if m != nil {
		return m.LastCollection
	}
	return time.Time{}
}

func (m *FeeStats) GetCollectionFrequency() int64 {
	if m != nil {
		return m.CollectionFrequency
	}
	return 0
}

// PerformanceFeeState tracks performance fee calculations
type PerformanceFeeState struct {
	// Current high water mark (share price)
	HighWaterMark cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=high_water_mark,json=highWaterMark,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"high_water_mark"`
	// Last performance fee calculation
	LastCalculation time.Time `protobuf:"bytes,2,opt,name=last_calculation,json=lastCalculation,proto3,stdtime" json:"last_calculation"`
	// Current period start (for performance measurement)
	PeriodStart time.Time `protobuf:"bytes,3,opt,name=period_start,json=periodStart,proto3,stdtime" json:"period_start"`
	// Accrued performance fees (not yet collected)
	AccruedPerformanceFees cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=accrued_performance_fees,json=accruedPerformanceFees,proto3,customtype=cosmossdk.io/math.Int" json:"accrued_performance_fees"`
	// Whether performance fees are currently active
	Active bool `protobuf:"varint,5,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *PerformanceFeeState) Reset()         { *m = PerformanceFeeState{} }
func (m *PerformanceFeeState) String() string { return proto.CompactTextString(m) }
func (*PerformanceFeeState) ProtoMessage()    {}
func (*PerformanceFeeState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4005b30a35fc5b42, []int{6}
}
func (m *PerformanceFeeState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerformanceFeeState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerformanceFeeState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerformanceFeeState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerformanceFeeState.Merge(m, src)
}
func (m *PerformanceFeeState) XXX_Size() int {
	return m.Size()
}
func (m *PerformanceFeeState) XXX_DiscardUnknown() {
	xxx_messageInfo_PerformanceFeeState.DiscardUnknown(m)
}

var xxx_messageInfo_PerformanceFeeState proto.InternalMessageInfo

func (m *PerformanceFeeState) GetLastCalculation() time.Time {
	if m != nil {
		return m.LastCalculation
	}
	return time.Time{}
}

func (m *PerformanceFeeState) GetPeriodStart() time.Time {
	if m != nil {
		return m.PeriodStart
	}
	return time.Time{}
}

func (m *PerformanceFeeState) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// FeeExemption represents an exemption from certain fees for specific addresses
type FeeExemption struct {
	// Exempt address
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Exempted fee types
	ExemptedTypes []FeeType `protobuf:"varint,2,rep,packed,name=exempted_types,json=exemptedTypes,proto3,enum=noble.dollar.vaults.v1.FeeType" json:"exempted_types,omitempty"`
	// Exemption expiry (if applicable)
	Expiry *time.Time `protobuf:"bytes,3,opt,name=expiry,proto3,stdtime" json:"expiry,omitempty"`
	// Exemption reason
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	// Whether exemption is active
	Active bool `protobuf:"varint,5,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *FeeExemption) Reset()         { *m = FeeExemption{} }
func (m *FeeExemption) String() string { return proto.CompactTextString(m) }
func (*FeeExemption) ProtoMessage()    {}
func (*FeeExemption) Descriptor() ([]byte, []int) {
	return fileDescriptor_4005b30a35fc5b42, []int{7}
}
func (m *FeeExemption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeExemption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeExemption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeExemption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeExemption.Merge(m, src)
}
func (m *FeeExemption) XXX_Size() int {
	return m.Size()
}
func (m *FeeExemption) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeExemption.DiscardUnknown(m)
}

var xxx_messageInfo_FeeExemption proto.InternalMessageInfo

func (m *FeeExemption) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *FeeExemption) GetExemptedTypes() []FeeType {
	if m != nil {
		return m.ExemptedTypes
	}
	return nil
}

func (m *FeeExemption) GetExpiry() *time.Time {
	if m != nil {
		return m.Expiry
	}
	return nil
}

func (m *FeeExemption) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *FeeExemption) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// FeeSchedule defines time-based fee rate changes
type FeeSchedule struct {
	// Effective date for the fee rates
	EffectiveDate time.Time `protobuf:"bytes,1,opt,name=effective_date,json=effectiveDate,proto3,stdtime" json:"effective_date"`
	// Fee configuration for this schedule
	FeeConfig *FeeConfig `protobuf:"bytes,2,opt,name=fee_config,json=feeConfig,proto3" json:"fee_config,omitempty"`
	// Whether this schedule is active
	Active bool `protobuf:"varint,3,opt,name=active,proto3" json:"active,omitempty"`
	// Description of the schedule change
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *FeeSchedule) Reset()         { *m = FeeSchedule{} }
func (m *FeeSchedule) String() string { return proto.CompactTextString(m) }
func (*FeeSchedule) ProtoMessage()    {}
func (*FeeSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_4005b30a35fc5b42, []int{8}
}
func (m *FeeSchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeSchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeSchedule.Merge(m, src)
}
func (m *FeeSchedule) XXX_Size() int {
	return m.Size()
}
func (m *FeeSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_FeeSchedule proto.InternalMessageInfo

func (m *FeeSchedule) GetEffectiveDate() time.Time {
	if m != nil {
		return m.EffectiveDate
	}
	return time.Time{}
}

func (m *FeeSchedule) GetFeeConfig() *FeeConfig {
	if m != nil {
		return m.FeeConfig
	}
	return nil
}

func (m *FeeSchedule) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *FeeSchedule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func init() {
	proto.RegisterEnum("noble.dollar.vaults.v1.FeeType", FeeType_name, FeeType_value)
	proto.RegisterEnum("noble.dollar.vaults.v1.FeeCollectionMethod", FeeCollectionMethod_name, FeeCollectionMethod_value)
	proto.RegisterType((*FeeConfig)(nil), "noble.dollar.vaults.v1.FeeConfig")
	proto.RegisterType((*ShareDilutionParams)(nil), "noble.dollar.vaults.v1.ShareDilutionParams")
	proto.RegisterType((*FeeAccrual)(nil), "noble.dollar.vaults.v1.FeeAccrual")
	proto.RegisterType((*FeeCollection)(nil), "noble.dollar.vaults.v1.FeeCollection")
	proto.RegisterType((*FeeTypeBreakdown)(nil), "noble.dollar.vaults.v1.FeeTypeBreakdown")
	proto.RegisterType((*FeeStats)(nil), "noble.dollar.vaults.v1.FeeStats")
	proto.RegisterType((*PerformanceFeeState)(nil), "noble.dollar.vaults.v1.PerformanceFeeState")
	proto.RegisterType((*FeeExemption)(nil), "noble.dollar.vaults.v1.FeeExemption")
	proto.RegisterType((*FeeSchedule)(nil), "noble.dollar.vaults.v1.FeeSchedule")
}

func init() { proto.RegisterFile("noble/dollar/vaults/v1/fees.proto", fileDescriptor_4005b30a35fc5b42) }

var fileDescriptor_4005b30a35fc5b42 = []byte{
	// 1467 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xcd, 0x6f, 0xdb, 0xc6,
	0x12, 0x37, 0x2d, 0x7f, 0x69, 0x64, 0x29, 0xf4, 0x4a, 0xcf, 0x51, 0x9c, 0xf7, 0xfc, 0xa1, 0x93,
	0x91, 0xf7, 0x22, 0x25, 0x7e, 0x40, 0x0f, 0x41, 0x0b, 0x54, 0x96, 0xa8, 0x58, 0x8d, 0x2d, 0x1b,
	0x94, 0x52, 0x37, 0x39, 0x94, 0x5d, 0x91, 0x23, 0x89, 0x35, 0x3f, 0x54, 0x92, 0x92, 0xed, 0xde,
	0x0b, 0xf4, 0x18, 0xa0, 0xfd, 0x0f, 0x72, 0x69, 0x6f, 0x2d, 0x90, 0xbf, 0xa0, 0xa7, 0x1c, 0x83,
	0x1c, 0x8a, 0xa2, 0x87, 0xb4, 0x48, 0x0e, 0xed, 0x9f, 0x51, 0xec, 0x2e, 0x29, 0xca, 0x4e, 0x9a,
	0xfa, 0xa3, 0xbd, 0x08, 0xda, 0x99, 0xf9, 0xcd, 0xec, 0xce, 0x6f, 0x76, 0x66, 0x09, 0x6b, 0x8e,
	0xdb, 0xb6, 0xb0, 0x64, 0xb8, 0x96, 0x45, 0xbd, 0xd2, 0x90, 0x0e, 0xac, 0xc0, 0x2f, 0x0d, 0x6f,
	0x97, 0x3a, 0x88, 0x7e, 0xb1, 0xef, 0xb9, 0x81, 0x4b, 0x16, 0xb9, 0x49, 0x51, 0x98, 0x14, 0x85,
	0x49, 0x71, 0x78, 0x7b, 0x69, 0x81, 0xda, 0xa6, 0xe3, 0x96, 0xf8, 0xaf, 0x30, 0x5d, 0xba, 0xa6,
	0xbb, 0xbe, 0xed, 0xfa, 0x1a, 0x5f, 0x95, 0xc4, 0x22, 0x54, 0xe5, 0xba, 0x6e, 0xd7, 0x15, 0x72,
	0xf6, 0x2f, 0x94, 0xae, 0x74, 0x5d, 0xb7, 0x6b, 0x61, 0x89, 0xaf, 0xda, 0x83, 0x4e, 0x29, 0x30,
	0x6d, 0xf4, 0x03, 0x6a, 0xf7, 0x85, 0x41, 0xe1, 0x87, 0x29, 0x48, 0xd6, 0x10, 0x2b, 0xae, 0xd3,
	0x31, 0xbb, 0xa4, 0x08, 0x59, 0x9b, 0x3a, 0xb4, 0x8b, 0x36, 0x3a, 0x81, 0xd6, 0x41, 0xd4, 0x3c,
	0x1a, 0x60, 0x5e, 0x5a, 0x95, 0xd6, 0xa7, 0xd5, 0x85, 0x58, 0x55, 0x43, 0x54, 0x69, 0x80, 0xe4,
	0x16, 0xe4, 0xfa, 0xe8, 0x75, 0x5c, 0xcf, 0xa6, 0x8e, 0x8e, 0x31, 0x60, 0x92, 0x03, 0xc8, 0x98,
	0x2e, 0x42, 0xac, 0x83, 0x6c, 0x60, 0xdf, 0xf5, 0xcd, 0x31, 0xf7, 0x09, 0x6e, 0x9d, 0x09, 0xe5,
	0x91, 0x65, 0x11, 0xb2, 0x87, 0x66, 0xd0, 0x33, 0x3c, 0x7a, 0x48, 0xad, 0xd8, 0x78, 0x4a, 0xec,
	0x25, 0x56, 0x45, 0xf6, 0x25, 0xc8, 0xe9, 0x9e, 0xeb, 0xfb, 0x9a, 0xde, 0xa3, 0xa6, 0x13, 0x03,
	0xa6, 0x05, 0x80, 0xeb, 0x2a, 0x4c, 0x15, 0x01, 0xfe, 0x07, 0x04, 0x6d, 0xf4, 0xba, 0xe8, 0xe8,
	0xc7, 0xb1, 0xf9, 0x0c, 0x37, 0x97, 0x47, 0x9a, 0xc8, 0xfa, 0x23, 0x58, 0xd0, 0x5d, 0xcb, 0x42,
	0x3d, 0x30, 0x5d, 0x47, 0xb3, 0x31, 0xe8, 0xb9, 0x46, 0x7e, 0x76, 0x55, 0x5a, 0xcf, 0x6c, 0xfc,
	0xb7, 0xf8, 0x66, 0x06, 0x8b, 0x3c, 0xb1, 0x11, 0x66, 0x87, 0x43, 0x54, 0x59, 0x3f, 0x25, 0x21,
	0xef, 0x41, 0x9a, 0x47, 0x47, 0xdd, 0xec, 0x9b, 0xe8, 0x04, 0xf9, 0xb9, 0x55, 0x69, 0x3d, 0xb9,
	0x99, 0x7f, 0xfe, 0xe4, 0x66, 0x2e, 0xa4, 0xb8, 0x6c, 0x18, 0x1e, 0xfa, 0x7e, 0x33, 0xf0, 0x4c,
	0xa7, 0xab, 0xce, 0x77, 0x10, 0xd5, 0xc8, 0x9a, 0xac, 0x01, 0x5b, 0xfb, 0x1a, 0x3a, 0xb4, 0x6d,
	0xa1, 0x91, 0x4f, 0xae, 0x4a, 0xeb, 0x73, 0x6a, 0x8a, 0xc9, 0x14, 0x21, 0x22, 0x1f, 0xc3, 0x95,
	0x9e, 0xd9, 0xed, 0x69, 0x87, 0x34, 0x40, 0x4f, 0xb3, 0xa9, 0x77, 0x90, 0x07, 0x1e, 0xe3, 0x9d,
	0xa7, 0x2f, 0x56, 0x26, 0x7e, 0x7e, 0xb1, 0x72, 0x5d, 0xc4, 0xf1, 0x8d, 0x83, 0xa2, 0xe9, 0x96,
	0x6c, 0x1a, 0xf4, 0x8a, 0xdb, 0xd8, 0xa5, 0xfa, 0x71, 0x15, 0xf5, 0xe7, 0x4f, 0x6e, 0x42, 0xb8,
	0x8d, 0x2a, 0xea, 0xdf, 0xfc, 0xf6, 0xdd, 0x0d, 0x49, 0x4d, 0x33, 0x77, 0xfb, 0xcc, 0xdb, 0x0e,
	0xf5, 0x0e, 0x0a, 0x5f, 0x24, 0x20, 0xdb, 0xec, 0x51, 0x0f, 0xab, 0xa6, 0x35, 0x60, 0x27, 0xdb,
	0xa3, 0x1e, 0xb5, 0x7d, 0x56, 0x1e, 0x01, 0xf5, 0xba, 0x18, 0x68, 0x46, 0xa8, 0x18, 0xaf, 0x27,
	0x22, 0x74, 0x11, 0x86, 0x67, 0xf9, 0x13, 0xc8, 0xda, 0xa6, 0x13, 0x9b, 0x53, 0xdb, 0x1d, 0x38,
	0x01, 0xaf, 0xa7, 0xe4, 0xe6, 0xad, 0x70, 0xb7, 0xff, 0x7a, 0x7d, 0xb7, 0x75, 0x27, 0x18, 0xdb,
	0x67, 0xdd, 0x09, 0xc4, 0x3e, 0x17, 0x6c, 0xd3, 0x89, 0xfc, 0x97, 0xb9, 0x2b, 0x1e, 0x81, 0x1e,
	0xbd, 0x16, 0x21, 0x71, 0xe1, 0x08, 0xf4, 0xe8, 0x54, 0x84, 0x9b, 0x40, 0x46, 0xde, 0x3b, 0x1e,
	0x7e, 0x36, 0x60, 0x65, 0xc4, 0xeb, 0x36, 0xa1, 0x2e, 0x44, 0x9a, 0x5a, 0xa4, 0x20, 0x75, 0x48,
	0x5b, 0xd4, 0x8f, 0x53, 0xc4, 0x0b, 0x36, 0xb5, 0xb1, 0x54, 0x14, 0x57, 0xb7, 0x18, 0x5d, 0xdd,
	0x62, 0x2b, 0xba, 0xba, 0x9b, 0x73, 0x6c, 0x9b, 0x8f, 0x7e, 0x59, 0x91, 0xd4, 0x79, 0x06, 0x8d,
	0xe2, 0x17, 0xbe, 0x4d, 0x00, 0xd4, 0x10, 0xcb, 0xba, 0xee, 0x0d, 0xa8, 0x45, 0xee, 0xc0, 0x1c,
	0x2b, 0xac, 0xe0, 0xb8, 0x2f, 0x52, 0x9e, 0xd9, 0x58, 0x79, 0x4b, 0xa5, 0xb6, 0x8e, 0xfb, 0xa8,
	0xce, 0x76, 0xc4, 0x1f, 0xb2, 0x0f, 0x19, 0xca, 0xdc, 0xa0, 0x71, 0x59, 0x0e, 0xd2, 0xa1, 0x9f,
	0x30, 0x3b, 0x0f, 0x41, 0xf6, 0x59, 0xa9, 0xf8, 0x5a, 0xe0, 0x8a, 0x33, 0xe3, 0x85, 0x93, 0x9f,
	0x11, 0x9e, 0x5a, 0x2e, 0xcf, 0x00, 0x92, 0xbb, 0x30, 0xdf, 0x47, 0xcf, 0x74, 0x0d, 0xcd, 0x0f,
	0xa8, 0x17, 0xf0, 0x9c, 0x9f, 0x35, 0x93, 0x29, 0x81, 0x6c, 0x32, 0x20, 0xa9, 0x00, 0x84, 0x8e,
	0xd0, 0x31, 0xce, 0x45, 0x48, 0x52, 0xe0, 0x14, 0xc7, 0x20, 0xff, 0x86, 0x64, 0x78, 0xd7, 0xd1,
	0xe0, 0x6d, 0x65, 0x4e, 0x8d, 0x05, 0x85, 0xef, 0x13, 0x90, 0x3e, 0xd1, 0x1f, 0xc8, 0x26, 0x24,
	0x47, 0xdd, 0x99, 0xf3, 0x75, 0xe6, 0x98, 0x23, 0x18, 0x69, 0xc2, 0x7c, 0xe0, 0x06, 0xd4, 0xba,
	0x2c, 0x69, 0x29, 0xee, 0x25, 0xa4, 0x6c, 0x1f, 0xc2, 0x44, 0x87, 0x7c, 0x19, 0x17, 0x26, 0x2c,
	0x2d, 0xfc, 0x08, 0xba, 0x0c, 0x52, 0x81, 0x99, 0xb0, 0x91, 0x4e, 0x9d, 0xbf, 0x91, 0x86, 0x50,
	0x52, 0x83, 0x64, 0xdb, 0x43, 0x7a, 0x60, 0xb8, 0x87, 0xec, 0xee, 0x24, 0xd6, 0x53, 0x1b, 0xeb,
	0x7f, 0x51, 0xe6, 0x9b, 0x91, 0xbd, 0x1a, 0x43, 0x59, 0x1f, 0x6d, 0x5b, 0xae, 0x7e, 0xa0, 0xf5,
	0xd0, 0xec, 0xf6, 0x02, 0xce, 0x58, 0x42, 0x4d, 0x71, 0xd9, 0x16, 0x17, 0x15, 0xbe, 0x9e, 0x04,
	0xf9, 0xb4, 0x8b, 0x4b, 0xdd, 0xb2, 0x2d, 0x98, 0xb9, 0x24, 0x51, 0x21, 0xfe, 0x9f, 0xe3, 0x68,
	0x0d, 0xe6, 0x59, 0xcf, 0xd6, 0x68, 0xbf, 0x6f, 0x99, 0x68, 0x84, 0xf3, 0x37, 0xc5, 0x64, 0x65,
	0x21, 0x2a, 0xfc, 0x9e, 0x80, 0xb9, 0x1a, 0x62, 0x33, 0xa0, 0x81, 0x4f, 0xda, 0x90, 0x13, 0x15,
	0xc8, 0x87, 0x52, 0x7c, 0x01, 0xa4, 0x0b, 0x6e, 0x87, 0x70, 0x6f, 0x35, 0x44, 0xbf, 0x12, 0xf9,
	0x8a, 0x63, 0x9c, 0x3a, 0xf2, 0xe4, 0xa5, 0x62, 0x34, 0x4f, 0x9c, 0xbb, 0x08, 0x59, 0x7d, 0xe0,
	0x79, 0xec, 0x1d, 0x44, 0x1d, 0x67, 0x40, 0xad, 0xf1, 0xb7, 0xca, 0x42, 0xa8, 0x2a, 0x73, 0x0d,
	0x9f, 0x5c, 0x3b, 0x70, 0x85, 0xb7, 0xf1, 0x78, 0xbc, 0x9f, 0xab, 0xfd, 0x64, 0x18, 0x78, 0xac,
	0x19, 0xb4, 0x21, 0x47, 0x87, 0x5d, 0xcd, 0xa0, 0xa6, 0x75, 0x3c, 0xee, 0x73, 0xfa, 0xa2, 0x47,
	0xa4, 0xc3, 0x6e, 0x95, 0x39, 0x1b, 0x8b, 0x71, 0x1b, 0x72, 0x63, 0x4f, 0x9a, 0x78, 0x54, 0x89,
	0xca, 0xcf, 0xc6, 0xba, 0xd1, 0xb0, 0x2a, 0x7c, 0x95, 0x80, 0xec, 0xde, 0x89, 0x57, 0x1d, 0x63,
	0x1d, 0xdf, 0xf4, 0xc2, 0x90, 0xfe, 0xc6, 0x17, 0x06, 0xd9, 0x05, 0x59, 0x64, 0x97, 0x5a, 0xfa,
	0xc0, 0xa2, 0x3c, 0x15, 0x93, 0xe7, 0x48, 0x2f, 0xe7, 0xa6, 0x12, 0x83, 0x5f, 0x1b, 0x15, 0x89,
	0x8b, 0x8e, 0x8a, 0x4f, 0x21, 0x1f, 0x0d, 0xca, 0x53, 0x4f, 0x61, 0x9f, 0x17, 0xc0, 0x45, 0xc8,
	0x5a, 0x0c, 0x3d, 0x9e, 0xcc, 0xb4, 0x4f, 0x16, 0x61, 0x86, 0xea, 0x81, 0x39, 0x14, 0x8f, 0xda,
	0x39, 0x35, 0x5c, 0x15, 0x5e, 0x48, 0x30, 0x5f, 0x43, 0x54, 0x8e, 0xd0, 0xee, 0xf3, 0xd3, 0xe5,
	0x61, 0x96, 0x8a, 0x27, 0x23, 0xa7, 0x61, 0x5e, 0x8d, 0x96, 0xa4, 0x06, 0x19, 0xe4, 0x66, 0x68,
	0xf0, 0x96, 0xe5, 0xe7, 0x27, 0x57, 0x13, 0x67, 0xe9, 0x59, 0xe9, 0x08, 0xc6, 0x56, 0x3e, 0x79,
	0x17, 0x66, 0xf0, 0xa8, 0x6f, 0x7a, 0xc7, 0x67, 0xcc, 0x9c, 0xc4, 0x33, 0x17, 0x62, 0xd8, 0x41,
	0x3c, 0xa4, 0x7e, 0x78, 0x47, 0x92, 0x6a, 0xb8, 0xfa, 0xd3, 0x03, 0xfe, 0x28, 0x41, 0x8a, 0xd5,
	0x9a, 0xde, 0x43, 0x63, 0x60, 0x21, 0xb9, 0x07, 0x19, 0xec, 0x74, 0x90, 0x2b, 0x35, 0x23, 0x7a,
	0x52, 0x9e, 0x95, 0xbf, 0xf4, 0x08, 0x5b, 0x65, 0xb5, 0xfb, 0x3e, 0x00, 0x6b, 0xe0, 0x3a, 0xff,
	0x04, 0x0a, 0xab, 0x6a, 0xed, 0xad, 0x93, 0x88, 0x19, 0xaa, 0xc9, 0xce, 0xe8, 0xb3, 0x29, 0xde,
	0x76, 0x62, 0x7c, 0xdb, 0x64, 0x15, 0x52, 0x06, 0xfa, 0xba, 0x67, 0xf6, 0x47, 0xfd, 0x20, 0xa9,
	0x8e, 0x8b, 0x6e, 0x3c, 0x96, 0x60, 0x36, 0xcc, 0x30, 0xb9, 0x0a, 0xd9, 0x9a, 0xa2, 0x68, 0xad,
	0x07, 0x7b, 0x8a, 0xb6, 0x53, 0x6e, 0x94, 0xef, 0x2a, 0x3b, 0x4a, 0xa3, 0x25, 0x4f, 0x90, 0x3c,
	0xe4, 0x46, 0x8a, 0x3d, 0x45, 0xad, 0xed, 0xaa, 0x3b, 0xe5, 0x46, 0x45, 0x91, 0x25, 0x92, 0x03,
	0x79, 0xa4, 0xa9, 0x2a, 0x7b, 0xbb, 0xcd, 0x7a, 0x4b, 0x9e, 0x3c, 0xe1, 0x68, 0xbf, 0xde, 0xda,
	0xaa, 0xaa, 0xe5, 0xfd, 0xf2, 0xb6, 0x9c, 0x38, 0xe1, 0xa8, 0xa2, 0xee, 0x36, 0x9b, 0x5a, 0x65,
	0xab, 0x5c, 0x6f, 0xc8, 0x53, 0x64, 0x11, 0xc8, 0x48, 0xa3, 0xec, 0x28, 0xea, 0x5d, 0xa5, 0x51,
	0x79, 0x20, 0x4f, 0x2f, 0x4d, 0x7d, 0xf9, 0x78, 0x79, 0xe2, 0xc6, 0x10, 0xb2, 0x6f, 0x98, 0xc0,
	0xe4, 0x3f, 0x70, 0xad, 0xb2, 0xbb, 0xbd, 0xad, 0x54, 0x5a, 0xf5, 0xdd, 0x86, 0xd6, 0xdc, 0x2a,
	0xab, 0x8a, 0x56, 0xad, 0x6f, 0xdf, 0x67, 0x4b, 0x79, 0x82, 0x5c, 0x87, 0xab, 0x63, 0xea, 0xd6,
	0xee, 0x3d, 0xa5, 0xa1, 0x55, 0xeb, 0xaa, 0x52, 0x69, 0xc9, 0xd2, 0x29, 0x6c, 0xa3, 0xfc, 0xa1,
	0x56, 0xae, 0x7e, 0x70, 0xbf, 0xd9, 0xe2, 0x47, 0x9e, 0x14, 0x71, 0x37, 0xef, 0x3c, 0x7d, 0xb9,
	0x2c, 0x3d, 0x7b, 0xb9, 0x2c, 0xfd, 0xfa, 0x72, 0x59, 0x7a, 0xf4, 0x6a, 0x79, 0xe2, 0xd9, 0xab,
	0xe5, 0x89, 0x9f, 0x5e, 0x2d, 0x4f, 0x3c, 0x5c, 0x0d, 0x89, 0x11, 0x2c, 0x1d, 0x1d, 0x7f, 0x5e,
	0x1a, 0x6e, 0x94, 0x78, 0x3d, 0x87, 0xdf, 0xd8, 0xed, 0x19, 0x5e, 0x02, 0xff, 0xff, 0x23, 0x00,
	0x00, 0xff, 0xff, 0x56, 0x3f, 0xe8, 0x43, 0x81, 0x0f, 0x00, 0x00,
}

func (m *FeeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.HighWaterMark.Size()
		i -= size
		if _, err := m.HighWaterMark.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.FeesEnabled {
		i--
		if m.FeesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.FeeRecipient) > 0 {
		i -= len(m.FeeRecipient)
		copy(dAtA[i:], m.FeeRecipient)
		i = encodeVarintFees(dAtA, i, uint64(len(m.FeeRecipient)))
		i--
		dAtA[i] = 0x42
	}
	if m.CollectionMethod != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.CollectionMethod))
		i--
		dAtA[i] = 0x38
	}
	if m.EmergencyFeeRate != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.EmergencyFeeRate))
		i--
		dAtA[i] = 0x30
	}
	if m.CrossChainFeeRate != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.CrossChainFeeRate))
		i--
		dAtA[i] = 0x28
	}
	if m.WithdrawalFeeRate != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.WithdrawalFeeRate))
		i--
		dAtA[i] = 0x20
	}
	if m.DepositFeeRate != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.DepositFeeRate))
		i--
		dAtA[i] = 0x18
	}
	if m.PerformanceFeeRate != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.PerformanceFeeRate))
		i--
		dAtA[i] = 0x10
	}
	if m.ManagementFeeRate != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.ManagementFeeRate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShareDilutionParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShareDilutionParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShareDilutionParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastDilution, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastDilution):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintFees(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x2a
	if m.DilutionFrequency != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.DilutionFrequency))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.MaxDilutionAmount.Size()
		i -= size
		if _, err := m.MaxDilutionAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MinDilutionAmount.Size()
		i -= size
		if _, err := m.MinDilutionAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TargetDilutionRate != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.TargetDilutionRate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeeAccrual) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeAccrual) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeAccrual) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Collected {
		i--
		if m.Collected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.PeriodEnd, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PeriodEnd):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintFees(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x2a
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.PeriodStart, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PeriodStart):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintFees(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x22
	{
		size := m.SharesToDilute.Size()
		i -= size
		if _, err := m.SharesToDilute.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.AccruedAmount.Size()
		i -= size
		if _, err := m.AccruedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.FeeType != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.FeeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeeCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Breakdown) > 0 {
		for iNdEx := len(m.Breakdown) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Breakdown[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFees(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Method != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.SharesDiluted.Size()
		i -= size
		if _, err := m.SharesDiluted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalAmount.Size()
		i -= size
		if _, err := m.TotalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintFees(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeeTypeBreakdown) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeTypeBreakdown) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeTypeBreakdown) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RateApplied != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.RateApplied))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.SharesDiluted.Size()
		i -= size
		if _, err := m.SharesDiluted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.FeeType != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.FeeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeeStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CollectionFrequency != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.CollectionFrequency))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.AvgDailyCollection.Size()
		i -= size
		if _, err := m.AvgDailyCollection.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastCollection, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastCollection):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintFees(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x22
	if m.CurrentAnnualRate != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.CurrentAnnualRate))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.TotalSharesDiluted.Size()
		i -= size
		if _, err := m.TotalSharesDiluted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalFeesCollected.Size()
		i -= size
		if _, err := m.TotalFeesCollected.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PerformanceFeeState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerformanceFeeState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerformanceFeeState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.AccruedPerformanceFees.Size()
		i -= size
		if _, err := m.AccruedPerformanceFees.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.PeriodStart, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PeriodStart):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintFees(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x1a
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastCalculation, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastCalculation):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintFees(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x12
	{
		size := m.HighWaterMark.Size()
		i -= size
		if _, err := m.HighWaterMark.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeeExemption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeExemption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeExemption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintFees(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if m.Expiry != nil {
		n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.Expiry, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.Expiry):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintFees(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExemptedTypes) > 0 {
		dAtA10 := make([]byte, len(m.ExemptedTypes)*10)
		var j9 int
		for _, num := range m.ExemptedTypes {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintFees(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFees(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeeSchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeSchedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeSchedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFees(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.FeeConfig != nil {
		{
			size, err := m.FeeConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFees(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	n12, err12 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.EffectiveDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EffectiveDate):])
	if err12 != nil {
		return 0, err12
	}
	i -= n12
	i = encodeVarintFees(dAtA, i, uint64(n12))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintFees(dAtA []byte, offset int, v uint64) int {
	offset -= sovFees(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FeeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManagementFeeRate != 0 {
		n += 1 + sovFees(uint64(m.ManagementFeeRate))
	}
	if m.PerformanceFeeRate != 0 {
		n += 1 + sovFees(uint64(m.PerformanceFeeRate))
	}
	if m.DepositFeeRate != 0 {
		n += 1 + sovFees(uint64(m.DepositFeeRate))
	}
	if m.WithdrawalFeeRate != 0 {
		n += 1 + sovFees(uint64(m.WithdrawalFeeRate))
	}
	if m.CrossChainFeeRate != 0 {
		n += 1 + sovFees(uint64(m.CrossChainFeeRate))
	}
	if m.EmergencyFeeRate != 0 {
		n += 1 + sovFees(uint64(m.EmergencyFeeRate))
	}
	if m.CollectionMethod != 0 {
		n += 1 + sovFees(uint64(m.CollectionMethod))
	}
	l = len(m.FeeRecipient)
	if l > 0 {
		n += 1 + l + sovFees(uint64(l))
	}
	if m.FeesEnabled {
		n += 2
	}
	l = m.HighWaterMark.Size()
	n += 1 + l + sovFees(uint64(l))
	return n
}

func (m *ShareDilutionParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetDilutionRate != 0 {
		n += 1 + sovFees(uint64(m.TargetDilutionRate))
	}
	l = m.MinDilutionAmount.Size()
	n += 1 + l + sovFees(uint64(l))
	l = m.MaxDilutionAmount.Size()
	n += 1 + l + sovFees(uint64(l))
	if m.DilutionFrequency != 0 {
		n += 1 + sovFees(uint64(m.DilutionFrequency))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastDilution)
	n += 1 + l + sovFees(uint64(l))
	return n
}

func (m *FeeAccrual) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FeeType != 0 {
		n += 1 + sovFees(uint64(m.FeeType))
	}
	l = m.AccruedAmount.Size()
	n += 1 + l + sovFees(uint64(l))
	l = m.SharesToDilute.Size()
	n += 1 + l + sovFees(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PeriodStart)
	n += 1 + l + sovFees(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PeriodEnd)
	n += 1 + l + sovFees(uint64(l))
	if m.Collected {
		n += 2
	}
	return n
}

func (m *FeeCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovFees(uint64(l))
	l = m.TotalAmount.Size()
	n += 1 + l + sovFees(uint64(l))
	l = m.SharesDiluted.Size()
	n += 1 + l + sovFees(uint64(l))
	if m.Method != 0 {
		n += 1 + sovFees(uint64(m.Method))
	}
	if len(m.Breakdown) > 0 {
		for _, e := range m.Breakdown {
			l = e.Size()
			n += 1 + l + sovFees(uint64(l))
		}
	}
	if m.BlockHeight != 0 {
		n += 1 + sovFees(uint64(m.BlockHeight))
	}
	return n
}

func (m *FeeTypeBreakdown) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FeeType != 0 {
		n += 1 + sovFees(uint64(m.FeeType))
	}
	l = m.Amount.Size()
	n += 1 + l + sovFees(uint64(l))
	l = m.SharesDiluted.Size()
	n += 1 + l + sovFees(uint64(l))
	if m.RateApplied != 0 {
		n += 1 + sovFees(uint64(m.RateApplied))
	}
	return n
}

func (m *FeeStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalFeesCollected.Size()
	n += 1 + l + sovFees(uint64(l))
	l = m.TotalSharesDiluted.Size()
	n += 1 + l + sovFees(uint64(l))
	if m.CurrentAnnualRate != 0 {
		n += 1 + sovFees(uint64(m.CurrentAnnualRate))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastCollection)
	n += 1 + l + sovFees(uint64(l))
	l = m.AvgDailyCollection.Size()
	n += 1 + l + sovFees(uint64(l))
	if m.CollectionFrequency != 0 {
		n += 1 + sovFees(uint64(m.CollectionFrequency))
	}
	return n
}

func (m *PerformanceFeeState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.HighWaterMark.Size()
	n += 1 + l + sovFees(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastCalculation)
	n += 1 + l + sovFees(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PeriodStart)
	n += 1 + l + sovFees(uint64(l))
	l = m.AccruedPerformanceFees.Size()
	n += 1 + l + sovFees(uint64(l))
	if m.Active {
		n += 2
	}
	return n
}

func (m *FeeExemption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFees(uint64(l))
	}
	if len(m.ExemptedTypes) > 0 {
		l = 0
		for _, e := range m.ExemptedTypes {
			l += sovFees(uint64(e))
		}
		n += 1 + sovFees(uint64(l)) + l
	}
	if m.Expiry != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.Expiry)
		n += 1 + l + sovFees(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovFees(uint64(l))
	}
	if m.Active {
		n += 2
	}
	return n
}

func (m *FeeSchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EffectiveDate)
	n += 1 + l + sovFees(uint64(l))
	if m.FeeConfig != nil {
		l = m.FeeConfig.Size()
		n += 1 + l + sovFees(uint64(l))
	}
	if m.Active {
		n += 2
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFees(uint64(l))
	}
	return n
}

func sovFees(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFees(x uint64) (n int) {
	return sovFees(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FeeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementFeeRate", wireType)
			}
			m.ManagementFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ManagementFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerformanceFeeRate", wireType)
			}
			m.PerformanceFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerformanceFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositFeeRate", wireType)
			}
			m.DepositFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepositFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawalFeeRate", wireType)
			}
			m.WithdrawalFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithdrawalFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossChainFeeRate", wireType)
			}
			m.CrossChainFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossChainFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmergencyFeeRate", wireType)
			}
			m.EmergencyFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmergencyFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMethod", wireType)
			}
			m.CollectionMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionMethod |= FeeCollectionMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FeesEnabled = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWaterMark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HighWaterMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShareDilutionParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShareDilutionParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShareDilutionParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetDilutionRate", wireType)
			}
			m.TargetDilutionRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetDilutionRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDilutionAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinDilutionAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDilutionAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxDilutionAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DilutionFrequency", wireType)
			}
			m.DilutionFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DilutionFrequency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDilution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastDilution, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeAccrual) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeAccrual: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeAccrual: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeType", wireType)
			}
			m.FeeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeType |= FeeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccruedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AccruedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesToDilute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesToDilute.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.PeriodStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.PeriodEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Collected = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesDiluted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesDiluted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= FeeCollectionMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Breakdown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Breakdown = append(m.Breakdown, &FeeTypeBreakdown{})
			if err := m.Breakdown[len(m.Breakdown)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeTypeBreakdown) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeTypeBreakdown: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeTypeBreakdown: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeType", wireType)
			}
			m.FeeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeType |= FeeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesDiluted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesDiluted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateApplied", wireType)
			}
			m.RateApplied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateApplied |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFeesCollected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalFeesCollected.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSharesDiluted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSharesDiluted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentAnnualRate", wireType)
			}
			m.CurrentAnnualRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentAnnualRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastCollection, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgDailyCollection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvgDailyCollection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionFrequency", wireType)
			}
			m.CollectionFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionFrequency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerformanceFeeState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerformanceFeeState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerformanceFeeState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWaterMark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HighWaterMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCalculation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastCalculation, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.PeriodStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccruedPerformanceFees", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AccruedPerformanceFees.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeExemption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeExemption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeExemption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v FeeType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFees
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= FeeType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExemptedTypes = append(m.ExemptedTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFees
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFees
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFees
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ExemptedTypes) == 0 {
					m.ExemptedTypes = make([]FeeType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v FeeType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFees
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= FeeType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExemptedTypes = append(m.ExemptedTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExemptedTypes", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiry == nil {
				m.Expiry = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.Expiry, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeSchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeSchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeSchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.EffectiveDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeeConfig == nil {
				m.FeeConfig = &FeeConfig{}
			}
			if err := m.FeeConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFees(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFees
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFees
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFees
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFees
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFees
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFees
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFees        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFees          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFees = fmt.Errorf("proto: unexpected end of group")
)
