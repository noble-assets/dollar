// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v1/migration.proto

package vaults

import (
	context "context"
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MigrationState represents the current state of the migration process
type MigrationState int32

const (
	// Migration has not started yet
	MIGRATION_STATE_NOT_STARTED MigrationState = 0
	// Migration is active, users can migrate
	MIGRATION_STATE_ACTIVE MigrationState = 1
	// Migration is in closing period (grace period warning)
	MIGRATION_STATE_CLOSING MigrationState = 2
	// Migration is locked, no new migrations allowed
	MIGRATION_STATE_LOCKED MigrationState = 3
	// Legacy vault is deprecated
	MIGRATION_STATE_DEPRECATED MigrationState = 4
	// Migration has been cancelled
	MIGRATION_STATE_CANCELLED MigrationState = 5
)

var MigrationState_name = map[int32]string{
	0: "MIGRATION_STATE_NOT_STARTED",
	1: "MIGRATION_STATE_ACTIVE",
	2: "MIGRATION_STATE_CLOSING",
	3: "MIGRATION_STATE_LOCKED",
	4: "MIGRATION_STATE_DEPRECATED",
	5: "MIGRATION_STATE_CANCELLED",
}

var MigrationState_value = map[string]int32{
	"MIGRATION_STATE_NOT_STARTED": 0,
	"MIGRATION_STATE_ACTIVE":      1,
	"MIGRATION_STATE_CLOSING":     2,
	"MIGRATION_STATE_LOCKED":      3,
	"MIGRATION_STATE_DEPRECATED":  4,
	"MIGRATION_STATE_CANCELLED":   5,
}

func (x MigrationState) String() string {
	return proto.EnumName(MigrationState_name, int32(x))
}

func (MigrationState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{0}
}

// MsgMigratePosition allows users to migrate their legacy positions to the new vault system
type MsgMigratePosition struct {
	// User initiating the migration
	Signer string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	// Vault type to migrate from
	VaultType VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// Amount to migrate (0 = migrate all positions)
	Amount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// Whether user wants to forgo yield (for yield redistribution)
	ForgoYield bool `protobuf:"varint,4,opt,name=forgo_yield,json=forgoYield,proto3" json:"forgo_yield,omitempty"`
}

func (m *MsgMigratePosition) Reset()         { *m = MsgMigratePosition{} }
func (m *MsgMigratePosition) String() string { return proto.CompactTextString(m) }
func (*MsgMigratePosition) ProtoMessage()    {}
func (*MsgMigratePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{0}
}
func (m *MsgMigratePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMigratePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMigratePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMigratePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMigratePosition.Merge(m, src)
}
func (m *MsgMigratePosition) XXX_Size() int {
	return m.Size()
}
func (m *MsgMigratePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMigratePosition.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMigratePosition proto.InternalMessageInfo

// MsgMigratePositionResponse returns the results of a position migration
type MsgMigratePositionResponse struct {
	// Shares received in the new vault system
	SharesReceived cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=shares_received,json=sharesReceived,proto3,customtype=cosmossdk.io/math.Int" json:"shares_received"`
	// Principal amount migrated
	PrincipalMigrated cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=principal_migrated,json=principalMigrated,proto3,customtype=cosmossdk.io/math.Int" json:"principal_migrated"`
	// Rewards included in migration
	RewardsMigrated cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=rewards_migrated,json=rewardsMigrated,proto3,customtype=cosmossdk.io/math.Int" json:"rewards_migrated"`
	// Transaction hash for reference
	MigrationTxHash string `protobuf:"bytes,4,opt,name=migration_tx_hash,json=migrationTxHash,proto3" json:"migration_tx_hash,omitempty"`
	// Gas used for the migration
	GasUsed uint64 `protobuf:"varint,5,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
}

func (m *MsgMigratePositionResponse) Reset()         { *m = MsgMigratePositionResponse{} }
func (m *MsgMigratePositionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMigratePositionResponse) ProtoMessage()    {}
func (*MsgMigratePositionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{1}
}
func (m *MsgMigratePositionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMigratePositionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMigratePositionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMigratePositionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMigratePositionResponse.Merge(m, src)
}
func (m *MsgMigratePositionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMigratePositionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMigratePositionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMigratePositionResponse proto.InternalMessageInfo

func (m *MsgMigratePositionResponse) GetMigrationTxHash() string {
	if m != nil {
		return m.MigrationTxHash
	}
	return ""
}

func (m *MsgMigratePositionResponse) GetGasUsed() uint64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

// MsgEmergencyWithdrawLegacy allows users to withdraw from legacy positions in emergency scenarios
type MsgEmergencyWithdrawLegacy struct {
	// User requesting emergency withdrawal
	Signer string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	// Vault type to withdraw from
	VaultType VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// Specific position indices to withdraw (empty = all positions)
	PositionIndices []int64 `protobuf:"varint,3,rep,packed,name=position_indices,json=positionIndices,proto3" json:"position_indices,omitempty"`
}

func (m *MsgEmergencyWithdrawLegacy) Reset()         { *m = MsgEmergencyWithdrawLegacy{} }
func (m *MsgEmergencyWithdrawLegacy) String() string { return proto.CompactTextString(m) }
func (*MsgEmergencyWithdrawLegacy) ProtoMessage()    {}
func (*MsgEmergencyWithdrawLegacy) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{2}
}
func (m *MsgEmergencyWithdrawLegacy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEmergencyWithdrawLegacy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEmergencyWithdrawLegacy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEmergencyWithdrawLegacy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEmergencyWithdrawLegacy.Merge(m, src)
}
func (m *MsgEmergencyWithdrawLegacy) XXX_Size() int {
	return m.Size()
}
func (m *MsgEmergencyWithdrawLegacy) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEmergencyWithdrawLegacy.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEmergencyWithdrawLegacy proto.InternalMessageInfo

// MsgEmergencyWithdrawLegacyResponse returns the results of emergency withdrawal
type MsgEmergencyWithdrawLegacyResponse struct {
	// Amount withdrawn
	AmountWithdrawn cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=amount_withdrawn,json=amountWithdrawn,proto3,customtype=cosmossdk.io/math.Int" json:"amount_withdrawn"`
	// Number of positions withdrawn
	PositionsWithdrawn int64 `protobuf:"varint,2,opt,name=positions_withdrawn,json=positionsWithdrawn,proto3" json:"positions_withdrawn,omitempty"`
}

func (m *MsgEmergencyWithdrawLegacyResponse) Reset()         { *m = MsgEmergencyWithdrawLegacyResponse{} }
func (m *MsgEmergencyWithdrawLegacyResponse) String() string { return proto.CompactTextString(m) }
func (*MsgEmergencyWithdrawLegacyResponse) ProtoMessage()    {}
func (*MsgEmergencyWithdrawLegacyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{3}
}
func (m *MsgEmergencyWithdrawLegacyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEmergencyWithdrawLegacyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEmergencyWithdrawLegacyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEmergencyWithdrawLegacyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEmergencyWithdrawLegacyResponse.Merge(m, src)
}
func (m *MsgEmergencyWithdrawLegacyResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgEmergencyWithdrawLegacyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEmergencyWithdrawLegacyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEmergencyWithdrawLegacyResponse proto.InternalMessageInfo

func (m *MsgEmergencyWithdrawLegacyResponse) GetPositionsWithdrawn() int64 {
	if m != nil {
		return m.PositionsWithdrawn
	}
	return 0
}

// MsgUpdateMigrationState allows authority to update migration state
type MsgUpdateMigrationState struct {
	// Authority address
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// New migration state
	NewState MigrationState `protobuf:"varint,2,opt,name=new_state,json=newState,proto3,enum=noble.dollar.vaults.v1.MigrationState" json:"new_state,omitempty"`
	// Reason for state change
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgUpdateMigrationState) Reset()         { *m = MsgUpdateMigrationState{} }
func (m *MsgUpdateMigrationState) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateMigrationState) ProtoMessage()    {}
func (*MsgUpdateMigrationState) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{4}
}
func (m *MsgUpdateMigrationState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateMigrationState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateMigrationState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateMigrationState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateMigrationState.Merge(m, src)
}
func (m *MsgUpdateMigrationState) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateMigrationState) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateMigrationState.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateMigrationState proto.InternalMessageInfo

// MsgUpdateMigrationStateResponse confirms migration state update
type MsgUpdateMigrationStateResponse struct {
	// Previous state
	PreviousState MigrationState `protobuf:"varint,1,opt,name=previous_state,json=previousState,proto3,enum=noble.dollar.vaults.v1.MigrationState" json:"previous_state,omitempty"`
	// New state
	NewState MigrationState `protobuf:"varint,2,opt,name=new_state,json=newState,proto3,enum=noble.dollar.vaults.v1.MigrationState" json:"new_state,omitempty"`
	// Update timestamp
	UpdatedAt time.Time `protobuf:"bytes,3,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at"`
}

func (m *MsgUpdateMigrationStateResponse) Reset()         { *m = MsgUpdateMigrationStateResponse{} }
func (m *MsgUpdateMigrationStateResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateMigrationStateResponse) ProtoMessage()    {}
func (*MsgUpdateMigrationStateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{5}
}
func (m *MsgUpdateMigrationStateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateMigrationStateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateMigrationStateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateMigrationStateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateMigrationStateResponse.Merge(m, src)
}
func (m *MsgUpdateMigrationStateResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateMigrationStateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateMigrationStateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateMigrationStateResponse proto.InternalMessageInfo

func (m *MsgUpdateMigrationStateResponse) GetPreviousState() MigrationState {
	if m != nil {
		return m.PreviousState
	}
	return MIGRATION_STATE_NOT_STARTED
}

func (m *MsgUpdateMigrationStateResponse) GetNewState() MigrationState {
	if m != nil {
		return m.NewState
	}
	return MIGRATION_STATE_NOT_STARTED
}

func (m *MsgUpdateMigrationStateResponse) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

// MigrationConfig defines configuration parameters for the migration process
type MigrationConfig struct {
	// Migration start time
	StartTime time.Time `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3,stdtime" json:"start_time"`
	// Time when migration enters closing period
	ClosingTime time.Time `protobuf:"bytes,2,opt,name=closing_time,json=closingTime,proto3,stdtime" json:"closing_time"`
	// Final deadline for migrations
	FinalDeadline time.Time `protobuf:"bytes,3,opt,name=final_deadline,json=finalDeadline,proto3,stdtime" json:"final_deadline"`
	// Maximum number of migrations allowed per block
	MaxMigrationPerBlock int64 `protobuf:"varint,4,opt,name=max_migration_per_block,json=maxMigrationPerBlock,proto3" json:"max_migration_per_block,omitempty"`
	// Minimum amount required for migration
	MinMigrationAmount cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=min_migration_amount,json=minMigrationAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_migration_amount"`
	// Whether full migration is required (cannot partial migrate)
	RequireFullMigration bool `protobuf:"varint,6,opt,name=require_full_migration,json=requireFullMigration,proto3" json:"require_full_migration,omitempty"`
	// Whether migration is enabled
	MigrationEnabled bool `protobuf:"varint,7,opt,name=migration_enabled,json=migrationEnabled,proto3" json:"migration_enabled,omitempty"`
}

func (m *MigrationConfig) Reset()         { *m = MigrationConfig{} }
func (m *MigrationConfig) String() string { return proto.CompactTextString(m) }
func (*MigrationConfig) ProtoMessage()    {}
func (*MigrationConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{6}
}
func (m *MigrationConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrationConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrationConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrationConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrationConfig.Merge(m, src)
}
func (m *MigrationConfig) XXX_Size() int {
	return m.Size()
}
func (m *MigrationConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrationConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MigrationConfig proto.InternalMessageInfo

func (m *MigrationConfig) GetStartTime() time.Time {
	if m != nil {
		return m.StartTime
	}
	return time.Time{}
}

func (m *MigrationConfig) GetClosingTime() time.Time {
	if m != nil {
		return m.ClosingTime
	}
	return time.Time{}
}

func (m *MigrationConfig) GetFinalDeadline() time.Time {
	if m != nil {
		return m.FinalDeadline
	}
	return time.Time{}
}

func (m *MigrationConfig) GetMaxMigrationPerBlock() int64 {
	if m != nil {
		return m.MaxMigrationPerBlock
	}
	return 0
}

func (m *MigrationConfig) GetRequireFullMigration() bool {
	if m != nil {
		return m.RequireFullMigration
	}
	return false
}

func (m *MigrationConfig) GetMigrationEnabled() bool {
	if m != nil {
		return m.MigrationEnabled
	}
	return false
}

// UserMigrationRecord tracks migration details for a specific user
type UserMigrationRecord struct {
	// When the user migrated
	MigratedAt time.Time `protobuf:"bytes,1,opt,name=migrated_at,json=migratedAt,proto3,stdtime" json:"migrated_at"`
	// Vault type migrated from
	FromVaultType VaultType `protobuf:"varint,2,opt,name=from_vault_type,json=fromVaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"from_vault_type,omitempty"`
	// Number of legacy positions migrated
	LegacyPositionCount int64 `protobuf:"varint,3,opt,name=legacy_position_count,json=legacyPositionCount,proto3" json:"legacy_position_count,omitempty"`
	// Principal amount migrated
	PrincipalMigrated cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=principal_migrated,json=principalMigrated,proto3,customtype=cosmossdk.io/math.Int" json:"principal_migrated"`
	// Rewards amount migrated
	RewardsMigrated cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=rewards_migrated,json=rewardsMigrated,proto3,customtype=cosmossdk.io/math.Int" json:"rewards_migrated"`
	// Shares received in new system
	SharesReceived cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=shares_received,json=sharesReceived,proto3,customtype=cosmossdk.io/math.Int" json:"shares_received"`
	// Migration transaction hash
	MigrationTxHash string `protobuf:"bytes,7,opt,name=migration_tx_hash,json=migrationTxHash,proto3" json:"migration_tx_hash,omitempty"`
	// Gas used for migration
	GasUsed uint64 `protobuf:"varint,8,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	// Whether user chose to forgo yield
	YieldForgone bool `protobuf:"varint,9,opt,name=yield_forgone,json=yieldForgone,proto3" json:"yield_forgone,omitempty"`
}

func (m *UserMigrationRecord) Reset()         { *m = UserMigrationRecord{} }
func (m *UserMigrationRecord) String() string { return proto.CompactTextString(m) }
func (*UserMigrationRecord) ProtoMessage()    {}
func (*UserMigrationRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{7}
}
func (m *UserMigrationRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserMigrationRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserMigrationRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserMigrationRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMigrationRecord.Merge(m, src)
}
func (m *UserMigrationRecord) XXX_Size() int {
	return m.Size()
}
func (m *UserMigrationRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMigrationRecord.DiscardUnknown(m)
}

var xxx_messageInfo_UserMigrationRecord proto.InternalMessageInfo

func (m *UserMigrationRecord) GetMigratedAt() time.Time {
	if m != nil {
		return m.MigratedAt
	}
	return time.Time{}
}

func (m *UserMigrationRecord) GetFromVaultType() VaultType {
	if m != nil {
		return m.FromVaultType
	}
	return UNSPECIFIED
}

func (m *UserMigrationRecord) GetLegacyPositionCount() int64 {
	if m != nil {
		return m.LegacyPositionCount
	}
	return 0
}

func (m *UserMigrationRecord) GetMigrationTxHash() string {
	if m != nil {
		return m.MigrationTxHash
	}
	return ""
}

func (m *UserMigrationRecord) GetGasUsed() uint64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

func (m *UserMigrationRecord) GetYieldForgone() bool {
	if m != nil {
		return m.YieldForgone
	}
	return false
}

// MigrationStats tracks overall migration progress and statistics
type MigrationStats struct {
	// Total number of users in legacy system
	TotalUsers uint64 `protobuf:"varint,1,opt,name=total_users,json=totalUsers,proto3" json:"total_users,omitempty"`
	// Number of users who have migrated
	UsersMigrated uint64 `protobuf:"varint,2,opt,name=users_migrated,json=usersMigrated,proto3" json:"users_migrated,omitempty"`
	// Total value locked in legacy system
	TotalValueLocked cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_value_locked,json=totalValueLocked,proto3,customtype=cosmossdk.io/math.Int" json:"total_value_locked"`
	// Total value migrated to new system
	ValueMigrated cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=value_migrated,json=valueMigrated,proto3,customtype=cosmossdk.io/math.Int" json:"value_migrated"`
	// Total shares issued through migration
	TotalSharesIssued cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=total_shares_issued,json=totalSharesIssued,proto3,customtype=cosmossdk.io/math.Int" json:"total_shares_issued"`
	// Last migration timestamp
	LastMigrationTime time.Time `protobuf:"bytes,6,opt,name=last_migration_time,json=lastMigrationTime,proto3,stdtime" json:"last_migration_time"`
	// Average gas used per migration
	AverageGasPerMigration uint64 `protobuf:"varint,7,opt,name=average_gas_per_migration,json=averageGasPerMigration,proto3" json:"average_gas_per_migration,omitempty"`
	// Migration completion percentage (basis points)
	CompletionPercentage int32 `protobuf:"varint,8,opt,name=completion_percentage,json=completionPercentage,proto3" json:"completion_percentage,omitempty"`
}

func (m *MigrationStats) Reset()         { *m = MigrationStats{} }
func (m *MigrationStats) String() string { return proto.CompactTextString(m) }
func (*MigrationStats) ProtoMessage()    {}
func (*MigrationStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{8}
}
func (m *MigrationStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrationStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrationStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrationStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrationStats.Merge(m, src)
}
func (m *MigrationStats) XXX_Size() int {
	return m.Size()
}
func (m *MigrationStats) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrationStats.DiscardUnknown(m)
}

var xxx_messageInfo_MigrationStats proto.InternalMessageInfo

func (m *MigrationStats) GetTotalUsers() uint64 {
	if m != nil {
		return m.TotalUsers
	}
	return 0
}

func (m *MigrationStats) GetUsersMigrated() uint64 {
	if m != nil {
		return m.UsersMigrated
	}
	return 0
}

func (m *MigrationStats) GetLastMigrationTime() time.Time {
	if m != nil {
		return m.LastMigrationTime
	}
	return time.Time{}
}

func (m *MigrationStats) GetAverageGasPerMigration() uint64 {
	if m != nil {
		return m.AverageGasPerMigration
	}
	return 0
}

func (m *MigrationStats) GetCompletionPercentage() int32 {
	if m != nil {
		return m.CompletionPercentage
	}
	return 0
}

// LockedLegacyPosition represents a legacy position that has been locked during migration
type LockedLegacyPosition struct {
	// Original position details
	Position *Position `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
	// When the position was locked
	LockedAt time.Time `protobuf:"bytes,2,opt,name=locked_at,json=lockedAt,proto3,stdtime" json:"locked_at"`
	// Address it was migrated to (in new system)
	MigratedTo []byte `protobuf:"bytes,3,opt,name=migrated_to,json=migratedTo,proto3" json:"migrated_to,omitempty"`
	// Unique migration ID
	MigrationId string `protobuf:"bytes,4,opt,name=migration_id,json=migrationId,proto3" json:"migration_id,omitempty"`
	// Whether unlock is enabled (for emergency scenarios)
	UnlockEnabled bool `protobuf:"varint,5,opt,name=unlock_enabled,json=unlockEnabled,proto3" json:"unlock_enabled,omitempty"`
	// Lock reason
	LockReason string `protobuf:"bytes,6,opt,name=lock_reason,json=lockReason,proto3" json:"lock_reason,omitempty"`
}

func (m *LockedLegacyPosition) Reset()         { *m = LockedLegacyPosition{} }
func (m *LockedLegacyPosition) String() string { return proto.CompactTextString(m) }
func (*LockedLegacyPosition) ProtoMessage()    {}
func (*LockedLegacyPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{9}
}
func (m *LockedLegacyPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockedLegacyPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockedLegacyPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockedLegacyPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockedLegacyPosition.Merge(m, src)
}
func (m *LockedLegacyPosition) XXX_Size() int {
	return m.Size()
}
func (m *LockedLegacyPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_LockedLegacyPosition.DiscardUnknown(m)
}

var xxx_messageInfo_LockedLegacyPosition proto.InternalMessageInfo

func (m *LockedLegacyPosition) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *LockedLegacyPosition) GetLockedAt() time.Time {
	if m != nil {
		return m.LockedAt
	}
	return time.Time{}
}

func (m *LockedLegacyPosition) GetMigratedTo() []byte {
	if m != nil {
		return m.MigratedTo
	}
	return nil
}

func (m *LockedLegacyPosition) GetMigrationId() string {
	if m != nil {
		return m.MigrationId
	}
	return ""
}

func (m *LockedLegacyPosition) GetUnlockEnabled() bool {
	if m != nil {
		return m.UnlockEnabled
	}
	return false
}

func (m *LockedLegacyPosition) GetLockReason() string {
	if m != nil {
		return m.LockReason
	}
	return ""
}

// MigrationPreview provides a preview of what a user would receive from migration
type MigrationPreview struct {
	// Total value to be migrated
	TotalValue cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_value,json=totalValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_value"`
	// Principal component
	PrincipalAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=principal_amount,json=principalAmount,proto3,customtype=cosmossdk.io/math.Int" json:"principal_amount"`
	// Accrued rewards component
	AccruedRewards cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=accrued_rewards,json=accruedRewards,proto3,customtype=cosmossdk.io/math.Int" json:"accrued_rewards"`
	// Estimated shares to receive
	EstimatedShares cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=estimated_shares,json=estimatedShares,proto3,customtype=cosmossdk.io/math.Int" json:"estimated_shares"`
	// Current NAV used for calculation
	CurrentNav cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=current_nav,json=currentNav,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"current_nav"`
	// Number of positions to be migrated
	PositionCount int64 `protobuf:"varint,6,opt,name=position_count,json=positionCount,proto3" json:"position_count,omitempty"`
}

func (m *MigrationPreview) Reset()         { *m = MigrationPreview{} }
func (m *MigrationPreview) String() string { return proto.CompactTextString(m) }
func (*MigrationPreview) ProtoMessage()    {}
func (*MigrationPreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{10}
}
func (m *MigrationPreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrationPreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrationPreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrationPreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrationPreview.Merge(m, src)
}
func (m *MigrationPreview) XXX_Size() int {
	return m.Size()
}
func (m *MigrationPreview) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrationPreview.DiscardUnknown(m)
}

var xxx_messageInfo_MigrationPreview proto.InternalMessageInfo

func (m *MigrationPreview) GetPositionCount() int64 {
	if m != nil {
		return m.PositionCount
	}
	return 0
}

// MigrationBlockReason represents reasons why a user cannot migrate
type MigrationBlockReason struct {
	// Block reason code
	ReasonCode string `protobuf:"bytes,1,opt,name=reason_code,json=reasonCode,proto3" json:"reason_code,omitempty"`
	// Human readable reason
	ReasonMessage string `protobuf:"bytes,2,opt,name=reason_message,json=reasonMessage,proto3" json:"reason_message,omitempty"`
	// Whether this is a temporary block
	Temporary bool `protobuf:"varint,3,opt,name=temporary,proto3" json:"temporary,omitempty"`
	// When the block expires (if temporary)
	ExpiresAt *time.Time `protobuf:"bytes,4,opt,name=expires_at,json=expiresAt,proto3,stdtime" json:"expires_at,omitempty"`
}

func (m *MigrationBlockReason) Reset()         { *m = MigrationBlockReason{} }
func (m *MigrationBlockReason) String() string { return proto.CompactTextString(m) }
func (*MigrationBlockReason) ProtoMessage()    {}
func (*MigrationBlockReason) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{11}
}
func (m *MigrationBlockReason) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrationBlockReason) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrationBlockReason.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrationBlockReason) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrationBlockReason.Merge(m, src)
}
func (m *MigrationBlockReason) XXX_Size() int {
	return m.Size()
}
func (m *MigrationBlockReason) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrationBlockReason.DiscardUnknown(m)
}

var xxx_messageInfo_MigrationBlockReason proto.InternalMessageInfo

func (m *MigrationBlockReason) GetReasonCode() string {
	if m != nil {
		return m.ReasonCode
	}
	return ""
}

func (m *MigrationBlockReason) GetReasonMessage() string {
	if m != nil {
		return m.ReasonMessage
	}
	return ""
}

func (m *MigrationBlockReason) GetTemporary() bool {
	if m != nil {
		return m.Temporary
	}
	return false
}

func (m *MigrationBlockReason) GetExpiresAt() *time.Time {
	if m != nil {
		return m.ExpiresAt
	}
	return nil
}

type QueryMigrationStatusRequest struct {
}

func (m *QueryMigrationStatusRequest) Reset()         { *m = QueryMigrationStatusRequest{} }
func (m *QueryMigrationStatusRequest) String() string { return proto.CompactTextString(m) }
func (*QueryMigrationStatusRequest) ProtoMessage()    {}
func (*QueryMigrationStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{12}
}
func (m *QueryMigrationStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMigrationStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMigrationStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMigrationStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMigrationStatusRequest.Merge(m, src)
}
func (m *QueryMigrationStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryMigrationStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMigrationStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMigrationStatusRequest proto.InternalMessageInfo

type QueryMigrationStatusResponse struct {
	// Current migration state
	State MigrationState `protobuf:"varint,1,opt,name=state,proto3,enum=noble.dollar.vaults.v1.MigrationState" json:"state,omitempty"`
	// Total value migrated
	TotalMigrated cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_migrated,json=totalMigrated,proto3,customtype=cosmossdk.io/math.Int" json:"total_migrated"`
	// Total value remaining to migrate
	TotalRemaining cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_remaining,json=totalRemaining,proto3,customtype=cosmossdk.io/math.Int" json:"total_remaining"`
	// Number of users migrated
	UsersMigrated int64 `protobuf:"varint,4,opt,name=users_migrated,json=usersMigrated,proto3" json:"users_migrated,omitempty"`
	// Number of users remaining
	UsersRemaining int64 `protobuf:"varint,5,opt,name=users_remaining,json=usersRemaining,proto3" json:"users_remaining,omitempty"`
}

func (m *QueryMigrationStatusResponse) Reset()         { *m = QueryMigrationStatusResponse{} }
func (m *QueryMigrationStatusResponse) String() string { return proto.CompactTextString(m) }
func (*QueryMigrationStatusResponse) ProtoMessage()    {}
func (*QueryMigrationStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{13}
}
func (m *QueryMigrationStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMigrationStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMigrationStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMigrationStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMigrationStatusResponse.Merge(m, src)
}
func (m *QueryMigrationStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryMigrationStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMigrationStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMigrationStatusResponse proto.InternalMessageInfo

func (m *QueryMigrationStatusResponse) GetState() MigrationState {
	if m != nil {
		return m.State
	}
	return MIGRATION_STATE_NOT_STARTED
}

func (m *QueryMigrationStatusResponse) GetUsersMigrated() int64 {
	if m != nil {
		return m.UsersMigrated
	}
	return 0
}

func (m *QueryMigrationStatusResponse) GetUsersRemaining() int64 {
	if m != nil {
		return m.UsersRemaining
	}
	return 0
}

type QueryUserMigrationStatusRequest struct {
	// User address to check
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Vault type (optional, defaults to all)
	VaultType VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
}

func (m *QueryUserMigrationStatusRequest) Reset()         { *m = QueryUserMigrationStatusRequest{} }
func (m *QueryUserMigrationStatusRequest) String() string { return proto.CompactTextString(m) }
func (*QueryUserMigrationStatusRequest) ProtoMessage()    {}
func (*QueryUserMigrationStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{14}
}
func (m *QueryUserMigrationStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUserMigrationStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUserMigrationStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUserMigrationStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUserMigrationStatusRequest.Merge(m, src)
}
func (m *QueryUserMigrationStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryUserMigrationStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUserMigrationStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUserMigrationStatusRequest proto.InternalMessageInfo

func (m *QueryUserMigrationStatusRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *QueryUserMigrationStatusRequest) GetVaultType() VaultType {
	if m != nil {
		return m.VaultType
	}
	return UNSPECIFIED
}

type QueryUserMigrationStatusResponse struct {
	// Whether user has migrated
	HasMigrated bool `protobuf:"varint,1,opt,name=has_migrated,json=hasMigrated,proto3" json:"has_migrated,omitempty"`
	// Legacy positions (if not migrated)
	LegacyPositions []*Position `protobuf:"bytes,2,rep,name=legacy_positions,json=legacyPositions,proto3" json:"legacy_positions,omitempty"`
	// Migration record (if migrated)
	MigrationRecord *UserMigrationRecord `protobuf:"bytes,3,opt,name=migration_record,json=migrationRecord,proto3" json:"migration_record,omitempty"`
	// Estimated shares if they migrate now
	EstimatedShares cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=estimated_shares,json=estimatedShares,proto3,customtype=cosmossdk.io/math.Int" json:"estimated_shares"`
}

func (m *QueryUserMigrationStatusResponse) Reset()         { *m = QueryUserMigrationStatusResponse{} }
func (m *QueryUserMigrationStatusResponse) String() string { return proto.CompactTextString(m) }
func (*QueryUserMigrationStatusResponse) ProtoMessage()    {}
func (*QueryUserMigrationStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{15}
}
func (m *QueryUserMigrationStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUserMigrationStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUserMigrationStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUserMigrationStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUserMigrationStatusResponse.Merge(m, src)
}
func (m *QueryUserMigrationStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryUserMigrationStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUserMigrationStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUserMigrationStatusResponse proto.InternalMessageInfo

func (m *QueryUserMigrationStatusResponse) GetHasMigrated() bool {
	if m != nil {
		return m.HasMigrated
	}
	return false
}

func (m *QueryUserMigrationStatusResponse) GetLegacyPositions() []*Position {
	if m != nil {
		return m.LegacyPositions
	}
	return nil
}

func (m *QueryUserMigrationStatusResponse) GetMigrationRecord() *UserMigrationRecord {
	if m != nil {
		return m.MigrationRecord
	}
	return nil
}

type QueryMigrationPreviewRequest struct {
	// User address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Vault type
	VaultType VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
}

func (m *QueryMigrationPreviewRequest) Reset()         { *m = QueryMigrationPreviewRequest{} }
func (m *QueryMigrationPreviewRequest) String() string { return proto.CompactTextString(m) }
func (*QueryMigrationPreviewRequest) ProtoMessage()    {}
func (*QueryMigrationPreviewRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{16}
}
func (m *QueryMigrationPreviewRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMigrationPreviewRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMigrationPreviewRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMigrationPreviewRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMigrationPreviewRequest.Merge(m, src)
}
func (m *QueryMigrationPreviewRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryMigrationPreviewRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMigrationPreviewRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMigrationPreviewRequest proto.InternalMessageInfo

func (m *QueryMigrationPreviewRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *QueryMigrationPreviewRequest) GetVaultType() VaultType {
	if m != nil {
		return m.VaultType
	}
	return UNSPECIFIED
}

type QueryMigrationPreviewResponse struct {
	// Total value to be migrated
	TotalValue cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_value,json=totalValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_value"`
	// Principal component
	PrincipalAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=principal_amount,json=principalAmount,proto3,customtype=cosmossdk.io/math.Int" json:"principal_amount"`
	// Accrued rewards component
	AccruedRewards cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=accrued_rewards,json=accruedRewards,proto3,customtype=cosmossdk.io/math.Int" json:"accrued_rewards"`
	// Estimated shares to receive
	EstimatedShares cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=estimated_shares,json=estimatedShares,proto3,customtype=cosmossdk.io/math.Int" json:"estimated_shares"`
	// Current NAV used for calculation
	CurrentNav cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=current_nav,json=currentNav,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"current_nav"`
	// Number of positions to be migrated
	PositionCount int64 `protobuf:"varint,6,opt,name=position_count,json=positionCount,proto3" json:"position_count,omitempty"`
}

func (m *QueryMigrationPreviewResponse) Reset()         { *m = QueryMigrationPreviewResponse{} }
func (m *QueryMigrationPreviewResponse) String() string { return proto.CompactTextString(m) }
func (*QueryMigrationPreviewResponse) ProtoMessage()    {}
func (*QueryMigrationPreviewResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fbe48f9540a0249f, []int{17}
}
func (m *QueryMigrationPreviewResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMigrationPreviewResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMigrationPreviewResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMigrationPreviewResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMigrationPreviewResponse.Merge(m, src)
}
func (m *QueryMigrationPreviewResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryMigrationPreviewResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMigrationPreviewResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMigrationPreviewResponse proto.InternalMessageInfo

func (m *QueryMigrationPreviewResponse) GetPositionCount() int64 {
	if m != nil {
		return m.PositionCount
	}
	return 0
}

func init() {
	proto.RegisterEnum("noble.dollar.vaults.v1.MigrationState", MigrationState_name, MigrationState_value)
	proto.RegisterType((*MsgMigratePosition)(nil), "noble.dollar.vaults.v1.MsgMigratePosition")
	proto.RegisterType((*MsgMigratePositionResponse)(nil), "noble.dollar.vaults.v1.MsgMigratePositionResponse")
	proto.RegisterType((*MsgEmergencyWithdrawLegacy)(nil), "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy")
	proto.RegisterType((*MsgEmergencyWithdrawLegacyResponse)(nil), "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse")
	proto.RegisterType((*MsgUpdateMigrationState)(nil), "noble.dollar.vaults.v1.MsgUpdateMigrationState")
	proto.RegisterType((*MsgUpdateMigrationStateResponse)(nil), "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse")
	proto.RegisterType((*MigrationConfig)(nil), "noble.dollar.vaults.v1.MigrationConfig")
	proto.RegisterType((*UserMigrationRecord)(nil), "noble.dollar.vaults.v1.UserMigrationRecord")
	proto.RegisterType((*MigrationStats)(nil), "noble.dollar.vaults.v1.MigrationStats")
	proto.RegisterType((*LockedLegacyPosition)(nil), "noble.dollar.vaults.v1.LockedLegacyPosition")
	proto.RegisterType((*MigrationPreview)(nil), "noble.dollar.vaults.v1.MigrationPreview")
	proto.RegisterType((*MigrationBlockReason)(nil), "noble.dollar.vaults.v1.MigrationBlockReason")
	proto.RegisterType((*QueryMigrationStatusRequest)(nil), "noble.dollar.vaults.v1.QueryMigrationStatusRequest")
	proto.RegisterType((*QueryMigrationStatusResponse)(nil), "noble.dollar.vaults.v1.QueryMigrationStatusResponse")
	proto.RegisterType((*QueryUserMigrationStatusRequest)(nil), "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest")
	proto.RegisterType((*QueryUserMigrationStatusResponse)(nil), "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse")
	proto.RegisterType((*QueryMigrationPreviewRequest)(nil), "noble.dollar.vaults.v1.QueryMigrationPreviewRequest")
	proto.RegisterType((*QueryMigrationPreviewResponse)(nil), "noble.dollar.vaults.v1.QueryMigrationPreviewResponse")
}

func init() {
	proto.RegisterFile("noble/dollar/vaults/v1/migration.proto", fileDescriptor_fbe48f9540a0249f)
}

var fileDescriptor_fbe48f9540a0249f = []byte{
	// 2024 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0x8a, 0x94, 0x2c, 0x3d, 0x89, 0x22, 0x35, 0x92, 0x25, 0x9a, 0x8e, 0x45, 0x99, 0x41,
	0x52, 0x55, 0x41, 0xc8, 0x44, 0x8e, 0x93, 0xd6, 0x48, 0x81, 0x52, 0x14, 0xe3, 0x10, 0x96, 0x64,
	0x65, 0x45, 0xdb, 0x70, 0x03, 0x74, 0x3b, 0xda, 0x1d, 0xad, 0x16, 0xd9, 0x0f, 0x7a, 0x67, 0x49,
	0x89, 0x45, 0x81, 0x06, 0xbd, 0xd4, 0xed, 0x29, 0x87, 0x02, 0x01, 0x7a, 0x0a, 0x90, 0x4b, 0xd1,
	0x93, 0x51, 0xe4, 0xd2, 0x63, 0x4f, 0x0d, 0xd0, 0x4b, 0x90, 0x53, 0xd1, 0x43, 0x6a, 0xd8, 0x07,
	0x17, 0x05, 0xfa, 0x0f, 0x04, 0x3d, 0x14, 0xf3, 0xb1, 0xbb, 0x24, 0x4d, 0xda, 0x26, 0xe5, 0x20,
	0x87, 0xe6, 0x42, 0x70, 0xdf, 0xcc, 0xfb, 0xcd, 0xbc, 0xcf, 0xdf, 0xdb, 0x85, 0x97, 0x5d, 0xef,
	0xc0, 0x26, 0x25, 0xc3, 0xb3, 0x6d, 0xec, 0x97, 0x5a, 0xb8, 0x69, 0x07, 0xb4, 0xd4, 0x7a, 0xbd,
	0xe4, 0x58, 0xa6, 0x8f, 0x03, 0xcb, 0x73, 0x8b, 0x0d, 0xdf, 0x0b, 0x3c, 0xb4, 0xc4, 0xf7, 0x15,
	0xc5, 0xbe, 0xa2, 0xd8, 0x57, 0x6c, 0xbd, 0x9e, 0x9b, 0xc7, 0x8e, 0xe5, 0x7a, 0x25, 0xfe, 0x2b,
	0xb6, 0xe6, 0x96, 0x75, 0x8f, 0x3a, 0x1e, 0x2d, 0x39, 0xd4, 0xe4, 0x48, 0xd4, 0x94, 0x0b, 0xe7,
	0xc4, 0x82, 0xc6, 0x9f, 0x4a, 0xe2, 0x41, 0x2e, 0x2d, 0x9a, 0x9e, 0xe9, 0x09, 0x39, 0xfb, 0x27,
	0xa5, 0x79, 0xd3, 0xf3, 0x4c, 0x9b, 0x94, 0xf8, 0xd3, 0x41, 0xf3, 0xb0, 0x14, 0x58, 0x0e, 0xa1,
	0x01, 0x76, 0x1a, 0x72, 0xc3, 0x8b, 0x03, 0x6e, 0x2f, 0xef, 0xc7, 0x37, 0x15, 0xfe, 0x38, 0x0e,
	0x68, 0x87, 0x9a, 0x3b, 0xdc, 0x22, 0xb2, 0xe7, 0x51, 0x8b, 0xd9, 0x85, 0x5e, 0x83, 0x49, 0x6a,
	0x99, 0x2e, 0xf1, 0xb3, 0xca, 0xaa, 0xb2, 0x36, 0xbd, 0x99, 0xfd, 0xf2, 0xb3, 0x57, 0x17, 0xe5,
	0xa5, 0xca, 0x86, 0xe1, 0x13, 0x4a, 0xf7, 0x03, 0xdf, 0x72, 0x4d, 0x55, 0xee, 0x43, 0x3f, 0x06,
	0xe0, 0xc0, 0x5a, 0xd0, 0x6e, 0x90, 0xec, 0xf8, 0xaa, 0xb2, 0x36, 0xb7, 0x71, 0xb1, 0xd8, 0xdf,
	0x31, 0xc5, 0x9b, 0xec, 0x5f, 0xbd, 0xdd, 0x20, 0xea, 0x74, 0x2b, 0xfc, 0x8b, 0xde, 0x85, 0x49,
	0xec, 0x78, 0x4d, 0x37, 0xc8, 0x26, 0xf8, 0x99, 0xaf, 0x7d, 0xfe, 0x55, 0x7e, 0xec, 0x1f, 0x5f,
	0xe5, 0xcf, 0x8a, 0x73, 0xa9, 0xf1, 0x41, 0xd1, 0xf2, 0x4a, 0x0e, 0x0e, 0x8e, 0x8a, 0x35, 0x37,
	0xf8, 0xf2, 0xb3, 0x57, 0x41, 0x5e, 0xa8, 0xe6, 0x06, 0x7f, 0x78, 0x74, 0x6f, 0x5d, 0x51, 0xa5,
	0x3e, 0xca, 0xc3, 0xcc, 0xa1, 0xe7, 0x9b, 0x9e, 0xd6, 0xb6, 0x88, 0x6d, 0x64, 0x93, 0xab, 0xca,
	0xda, 0x94, 0x0a, 0x5c, 0x74, 0x9b, 0x49, 0xae, 0x5c, 0xbe, 0xfb, 0x49, 0x7e, 0xec, 0x5f, 0x9f,
	0xe4, 0xc7, 0x7e, 0xf5, 0xe8, 0xde, 0xba, 0xb4, 0xe0, 0xb7, 0x8f, 0xee, 0xad, 0x5f, 0xe8, 0x76,
	0x56, 0x8f, 0x57, 0x0a, 0xff, 0x1d, 0x87, 0xdc, 0xe3, 0xce, 0x52, 0x09, 0x6d, 0x78, 0x2e, 0x25,
	0xe8, 0x36, 0xa4, 0xe9, 0x11, 0xf6, 0x09, 0xd5, 0x7c, 0xa2, 0x13, 0xab, 0x45, 0x0c, 0xe9, 0xbd,
	0xe1, 0x2d, 0x99, 0x13, 0x40, 0xaa, 0xc4, 0x41, 0x1a, 0xa0, 0x86, 0x6f, 0xb9, 0xba, 0xd5, 0xc0,
	0xb6, 0x26, 0xd2, 0x8f, 0x18, 0xdc, 0xcb, 0xa3, 0xa0, 0xcf, 0x47, 0x58, 0xd2, 0x14, 0x03, 0xbd,
	0x0f, 0x19, 0x9f, 0x1c, 0x63, 0xdf, 0xa0, 0x31, 0xfc, 0xa8, 0x61, 0x48, 0x4b, 0xa4, 0x08, 0x7c,
	0x1d, 0xe6, 0xa3, 0x92, 0xd1, 0x82, 0x13, 0xed, 0x08, 0xd3, 0x23, 0x1e, 0x95, 0x69, 0x35, 0x1d,
	0x2d, 0xd4, 0x4f, 0xde, 0xc5, 0xf4, 0x08, 0x9d, 0x83, 0x29, 0x13, 0x53, 0xad, 0x49, 0x89, 0x91,
	0x9d, 0x58, 0x55, 0xd6, 0x92, 0xea, 0x19, 0x13, 0xd3, 0x1b, 0x94, 0x18, 0x85, 0xaf, 0x15, 0xee,
	0xfe, 0xaa, 0x43, 0x7c, 0x93, 0xb8, 0x7a, 0xfb, 0x96, 0x15, 0x1c, 0x19, 0x3e, 0x3e, 0xde, 0x26,
	0x26, 0xd6, 0xdb, 0xdf, 0x4a, 0xce, 0x7e, 0x1f, 0x32, 0x0d, 0x99, 0x06, 0x9a, 0xe5, 0x1a, 0x96,
	0x4e, 0x68, 0x36, 0xb1, 0x9a, 0x58, 0x4b, 0xa8, 0xe9, 0x50, 0x5e, 0x13, 0xe2, 0x2b, 0x3f, 0x1a,
	0x90, 0x73, 0x2f, 0x75, 0xe7, 0xdc, 0x00, 0xeb, 0x0a, 0x7f, 0x52, 0xa0, 0x30, 0xd8, 0xf8, 0x28,
	0x07, 0xdf, 0x87, 0x8c, 0x28, 0x02, 0xed, 0x58, 0x6e, 0x70, 0x47, 0x4e, 0xc2, 0xb4, 0x40, 0x0a,
	0x4f, 0x72, 0x51, 0x09, 0x16, 0x42, 0xab, 0x68, 0x07, 0x3e, 0x73, 0x5c, 0x42, 0x45, 0xd1, 0x52,
	0xa4, 0x50, 0xf8, 0x8f, 0x02, 0xcb, 0x3b, 0xd4, 0xbc, 0xd1, 0x30, 0x70, 0x40, 0x76, 0xc2, 0x48,
	0xef, 0x07, 0x38, 0x20, 0xe8, 0x4d, 0x98, 0xc6, 0xcd, 0xe0, 0xc8, 0xf3, 0xad, 0xa0, 0xfd, 0xd4,
	0x88, 0xc5, 0x5b, 0x51, 0x05, 0xa6, 0x5d, 0x72, 0xac, 0x51, 0x06, 0x22, 0x63, 0xf6, 0xf2, 0xa0,
	0x98, 0x75, 0x1f, 0xa9, 0x4e, 0xb9, 0xe4, 0x58, 0x1c, 0xbe, 0x04, 0x93, 0x3e, 0xc1, 0xd4, 0x73,
	0x45, 0x92, 0xab, 0xf2, 0xa9, 0x3b, 0x48, 0xf1, 0xa1, 0x2c, 0x4e, 0x85, 0xee, 0x38, 0xf5, 0xb3,
	0x89, 0x65, 0x68, 0x7e, 0x80, 0xbd, 0x51, 0x84, 0x76, 0x60, 0xae, 0xe1, 0x93, 0x96, 0xe5, 0x35,
	0xa9, 0x34, 0x42, 0x19, 0xca, 0x88, 0x54, 0xa8, 0x2d, 0x2c, 0x79, 0x2e, 0xee, 0xa8, 0x00, 0x34,
	0xf9, 0x9d, 0x0d, 0x0d, 0x8b, 0xf6, 0x3b, 0xb3, 0x91, 0x2b, 0x0a, 0x82, 0x29, 0x86, 0x04, 0x53,
	0xac, 0x87, 0x04, 0xb3, 0x39, 0xc5, 0x72, 0xe9, 0xa3, 0x7f, 0xe6, 0x15, 0x75, 0x5a, 0xea, 0x95,
	0x83, 0xc2, 0xbf, 0x13, 0x90, 0x8e, 0x4e, 0xa8, 0x78, 0xee, 0xa1, 0x65, 0x32, 0x60, 0x1a, 0x60,
	0x3f, 0xd0, 0x18, 0x39, 0x71, 0x43, 0x9f, 0x19, 0x98, 0xeb, 0xb1, 0x15, 0x74, 0x15, 0x66, 0x75,
	0xdb, 0xa3, 0x96, 0x6b, 0x0a, 0x98, 0xf1, 0x21, 0x60, 0x66, 0xa4, 0x26, 0x07, 0xba, 0x06, 0x73,
	0x87, 0x96, 0x8b, 0x6d, 0xcd, 0x20, 0xd8, 0xb0, 0x2d, 0x97, 0x0c, 0x65, 0x6a, 0x8a, 0xeb, 0x6e,
	0x49, 0x55, 0x74, 0x19, 0x96, 0x1d, 0x7c, 0xa2, 0xc5, 0x8d, 0xad, 0x41, 0x7c, 0xed, 0xc0, 0xf6,
	0xf4, 0x0f, 0x78, 0x6b, 0x4b, 0xa8, 0x8b, 0x0e, 0x3e, 0x89, 0xfc, 0xb1, 0x47, 0xfc, 0x4d, 0xb6,
	0x86, 0x0e, 0x60, 0xd1, 0xb1, 0xdc, 0x0e, 0x35, 0xc9, 0x79, 0x13, 0x23, 0x16, 0x29, 0x72, 0x2c,
	0x37, 0x3a, 0xa5, 0x2c, 0xf8, 0xef, 0x0d, 0x58, 0xf2, 0xc9, 0x9d, 0xa6, 0xe5, 0x13, 0xed, 0xb0,
	0x69, 0xdb, 0xf1, 0x61, 0xd9, 0x49, 0x4e, 0x85, 0x8b, 0x72, 0xf5, 0x9d, 0xa6, 0x6d, 0x47, 0xba,
	0xe8, 0x95, 0xce, 0x2e, 0x4d, 0x5c, 0x7c, 0x60, 0x13, 0x23, 0x7b, 0x86, 0x2b, 0x64, 0xa2, 0x85,
	0xaa, 0x90, 0x17, 0xee, 0x27, 0x61, 0xe1, 0x06, 0x25, 0x7e, 0xa4, 0xae, 0x12, 0xdd, 0xf3, 0x0d,
	0x54, 0x85, 0x99, 0x90, 0x3f, 0x58, 0x2a, 0x0d, 0x13, 0x71, 0x08, 0x15, 0xcb, 0x01, 0xaa, 0x41,
	0xfa, 0xd0, 0xf7, 0x1c, 0x6d, 0x94, 0xf6, 0x9c, 0x62, 0x9a, 0xd1, 0x23, 0xda, 0x80, 0xb3, 0x36,
	0xef, 0x91, 0x5a, 0xd4, 0xa9, 0xf5, 0x68, 0xca, 0x48, 0xa8, 0x0b, 0x62, 0x31, 0x24, 0xf3, 0x0a,
	0x77, 0x60, 0x7f, 0xba, 0x4d, 0x7e, 0xb3, 0x74, 0x3b, 0xf1, 0xbc, 0xe8, 0xb6, 0xcf, 0x1c, 0x32,
	0xf9, 0x9c, 0xe6, 0x90, 0xbe, 0x4c, 0x7e, 0xe6, 0xe9, 0x4c, 0x3e, 0xd5, 0xc5, 0xe4, 0xe8, 0x45,
	0x48, 0xf1, 0xd1, 0x4c, 0xe3, 0x33, 0x99, 0x4b, 0xb2, 0xd3, 0x3c, 0xcd, 0x66, 0xb9, 0xf0, 0x1d,
	0x21, 0x2b, 0xfc, 0x39, 0x09, 0x73, 0x5d, 0x1d, 0x8b, 0xb2, 0xc1, 0x2e, 0xf0, 0x02, 0x6c, 0x33,
	0x50, 0x9f, 0xf2, 0xec, 0x4a, 0xaa, 0xc0, 0x45, 0x2c, 0x19, 0x29, 0x7a, 0x09, 0xe6, 0xf8, 0x52,
	0xf7, 0x8c, 0x94, 0x54, 0x53, 0x5c, 0x1a, 0x79, 0xe8, 0xa7, 0x80, 0x04, 0x4e, 0x0b, 0xdb, 0x4d,
	0xa2, 0xb1, 0xc2, 0x3c, 0xc5, 0xbc, 0x93, 0xe1, 0x58, 0x37, 0x19, 0xd4, 0x36, 0x47, 0x42, 0xb7,
	0x60, 0x4e, 0x20, 0x9f, 0x3a, 0x77, 0x52, 0x1c, 0x27, 0xba, 0xf8, 0xcf, 0x60, 0x41, 0x5c, 0x5c,
	0x06, 0xd8, 0xa2, 0xb4, 0x79, 0x8a, 0xd4, 0x99, 0xe7, 0x60, 0xfb, 0x1c, 0xab, 0xc6, 0xa1, 0x50,
	0x1d, 0x16, 0x6c, 0x4c, 0x83, 0x8e, 0x06, 0xc5, 0x7b, 0xee, 0xe4, 0x10, 0x85, 0x3c, 0xcf, 0x00,
	0xa2, 0xc8, 0xf1, 0xce, 0xfb, 0x43, 0x38, 0x87, 0x5b, 0xc4, 0xc7, 0x26, 0xd1, 0x58, 0x4e, 0xb0,
	0x56, 0x19, 0x37, 0xa5, 0x33, 0x3c, 0x44, 0x4b, 0x72, 0xc3, 0x55, 0x4c, 0xf7, 0x3a, 0xfa, 0x0a,
	0xba, 0x04, 0x67, 0x75, 0xcf, 0x69, 0xd8, 0x24, 0x6c, 0xb2, 0x3a, 0x71, 0x03, 0x6c, 0x12, 0x9e,
	0x53, 0x13, 0xea, 0x62, 0xbc, 0xb8, 0x17, 0xad, 0x15, 0x3e, 0x1d, 0x87, 0x45, 0x11, 0x8b, 0xed,
	0xae, 0xf2, 0x46, 0x6f, 0xc3, 0x54, 0xd8, 0x06, 0x64, 0x73, 0x5a, 0x1d, 0xd4, 0x51, 0xa2, 0xf9,
	0x3e, 0xd2, 0x40, 0x65, 0x98, 0x16, 0xb9, 0xc2, 0x7a, 0xdb, 0x30, 0x34, 0x34, 0x25, 0xd4, 0xca,
	0xfc, 0xdd, 0x24, 0x6a, 0x90, 0x81, 0xc7, 0x73, 0x6e, 0x36, 0x6e, 0x7d, 0x75, 0x0f, 0x5d, 0x84,
	0xd9, 0xd8, 0xf7, 0x96, 0xcc, 0x1c, 0x75, 0x26, 0x92, 0xd5, 0x0c, 0x9e, 0xe5, 0x2e, 0x43, 0x8c,
	0xda, 0xf4, 0x04, 0xaf, 0x9f, 0x94, 0x90, 0xca, 0x1e, 0xcd, 0x8e, 0xe2, 0x9b, 0xe4, 0xa4, 0xc3,
	0x7b, 0x80, 0x0a, 0x4c, 0xa4, 0x72, 0x49, 0xe1, 0xeb, 0x04, 0x64, 0x62, 0x86, 0x62, 0x63, 0x05,
	0x39, 0x46, 0xef, 0x85, 0x35, 0xc6, 0x33, 0x6f, 0xe4, 0xe1, 0x11, 0xe2, 0xa2, 0x60, 0xdd, 0x2e,
	0x6e, 0xa7, 0x92, 0xef, 0x46, 0x7d, 0x77, 0x49, 0x47, 0x48, 0x92, 0xec, 0x6e, 0x43, 0x1a, 0xeb,
	0xba, 0xdf, 0x24, 0x86, 0x26, 0x1b, 0xe1, 0xc8, 0x85, 0x3c, 0x27, 0x81, 0x54, 0x81, 0xc3, 0xee,
	0x4d, 0x68, 0x60, 0x39, 0x3c, 0x58, 0xa2, 0xe2, 0x46, 0x2e, 0xe4, 0x74, 0x84, 0x24, 0xca, 0x0d,
	0xdd, 0x82, 0x19, 0xbd, 0xe9, 0xfb, 0xc4, 0x0d, 0x34, 0x17, 0xb7, 0x64, 0x09, 0xbf, 0x29, 0x71,
	0xcf, 0x3f, 0x8e, 0x2b, 0x12, 0x79, 0x8b, 0xe8, 0x1d, 0xe8, 0x5b, 0x44, 0x97, 0xde, 0x96, 0x50,
	0xbb, 0xb8, 0xc5, 0xb2, 0xa3, 0x87, 0xe9, 0x26, 0x39, 0xd3, 0xa5, 0x1a, 0x9d, 0x1c, 0x57, 0xf8,
	0x8b, 0x02, 0x8b, 0x51, 0xf0, 0x37, 0xe3, 0xac, 0x60, 0x69, 0x23, 0x32, 0x46, 0xd3, 0x3d, 0x43,
	0x26, 0x80, 0x0a, 0x42, 0x54, 0xf1, 0x0c, 0xc2, 0x0e, 0x90, 0x1b, 0x1c, 0x42, 0x29, 0x2b, 0x45,
	0x1e, 0x4c, 0x35, 0x25, 0xa4, 0x3b, 0x42, 0x88, 0x5e, 0x80, 0xe9, 0x80, 0x38, 0x0d, 0xcf, 0xc7,
	0x7e, 0x9b, 0x87, 0x64, 0x4a, 0x8d, 0x05, 0x6c, 0x32, 0x24, 0x27, 0x0d, 0x8b, 0x35, 0x31, 0x1c,
	0x70, 0xaf, 0x3e, 0xbd, 0x96, 0x14, 0x31, 0x19, 0x4a, 0xbd, 0x72, 0x50, 0xb8, 0x00, 0xe7, 0xdf,
	0x6b, 0x12, 0xbf, 0xdd, 0x45, 0x13, 0x4d, 0xaa, 0x92, 0x3b, 0x4d, 0x42, 0x83, 0xc2, 0xfd, 0x71,
	0x78, 0xa1, 0xff, 0xba, 0x9c, 0xc5, 0xdf, 0x86, 0x89, 0x51, 0x46, 0x70, 0xa1, 0xc4, 0xba, 0xbc,
	0xa8, 0x94, 0x53, 0xbf, 0x90, 0xa7, 0x38, 0x4e, 0x27, 0x81, 0x0b, 0x60, 0x9f, 0x38, 0xd8, 0x72,
	0x2d, 0xd7, 0x1c, 0x3d, 0xa5, 0x39, 0x90, 0x1a, 0xe2, 0xf4, 0x21, 0x48, 0x31, 0xac, 0xf6, 0x10,
	0xe4, 0xf7, 0x20, 0x2d, 0xb6, 0xc5, 0x37, 0x98, 0xe0, 0xfb, 0x84, 0x76, 0x84, 0x57, 0xf8, 0x58,
	0x81, 0x3c, 0x77, 0x71, 0xd7, 0x30, 0xd8, 0x15, 0x06, 0xb4, 0x01, 0x67, 0xb0, 0x78, 0x9b, 0x7b,
	0xea, 0x7b, 0x5e, 0xb8, 0xf1, 0xf4, 0xaf, 0xe6, 0x85, 0xbf, 0x8e, 0xc3, 0xea, 0xe0, 0x9b, 0xc9,
	0x04, 0xb8, 0x08, 0xb3, 0x47, 0xb8, 0xc3, 0x19, 0x0a, 0x4f, 0xd3, 0x99, 0x23, 0x1c, 0xbb, 0xe2,
	0x1a, 0x64, 0x7a, 0xe6, 0x47, 0x9a, 0x1d, 0x5f, 0x4d, 0x3c, 0x13, 0x73, 0xa4, 0xbb, 0x87, 0x4b,
	0x8a, 0x6e, 0x42, 0x3c, 0x4a, 0xb3, 0xe9, 0xcc, 0xf3, 0x0d, 0xf9, 0x0e, 0xf2, 0xca, 0x20, 0xb0,
	0x3e, 0x53, 0x76, 0xc7, 0xac, 0x25, 0xc7, 0xee, 0x6f, 0xb2, 0x53, 0x15, 0x7e, 0xa7, 0xf4, 0x96,
	0x91, 0xe4, 0x8a, 0x6f, 0x37, 0xc0, 0xbf, 0x4e, 0xc2, 0x85, 0x01, 0xd7, 0x92, 0xd1, 0xfd, 0x8e,
	0xca, 0xfe, 0x2f, 0xa8, 0x6c, 0xfd, 0x6f, 0x4a, 0xcf, 0x9b, 0x02, 0x41, 0x79, 0x38, 0xbf, 0x53,
	0xbb, 0xaa, 0x96, 0xeb, 0xb5, 0xeb, 0xbb, 0xda, 0x7e, 0xbd, 0x5c, 0xaf, 0x6a, 0xbb, 0xd7, 0xeb,
	0xec, 0x9f, 0x5a, 0xaf, 0x6e, 0x65, 0xc6, 0x50, 0x0e, 0x96, 0x7a, 0x37, 0x94, 0x2b, 0xf5, 0xda,
	0xcd, 0x6a, 0x46, 0x41, 0xe7, 0x61, 0xb9, 0x77, 0xad, 0xb2, 0x7d, 0x7d, 0xbf, 0xb6, 0x7b, 0x35,
	0x33, 0xde, 0x4f, 0x71, 0xfb, 0x7a, 0xe5, 0x5a, 0x75, 0x2b, 0x93, 0x40, 0x2b, 0x90, 0xeb, 0x5d,
	0xdb, 0xaa, 0xee, 0xa9, 0xd5, 0x4a, 0x99, 0x1d, 0x9a, 0x44, 0x17, 0xe0, 0xdc, 0x63, 0xc0, 0xe5,
	0xdd, 0x4a, 0x75, 0x7b, 0xbb, 0xba, 0x95, 0x99, 0xc8, 0x25, 0xef, 0x7e, 0xba, 0x32, 0xb6, 0xf1,
	0x71, 0x02, 0x66, 0x23, 0x6b, 0x76, 0xa8, 0x89, 0xee, 0x84, 0xdf, 0x55, 0xe2, 0xef, 0xf3, 0xeb,
	0x03, 0x99, 0xea, 0xb1, 0xcf, 0xd3, 0xb9, 0x8d, 0x67, 0xdf, 0x1b, 0x55, 0xce, 0x6f, 0x14, 0x58,
	0x1e, 0xf4, 0x9d, 0xf5, 0x49, 0x78, 0x03, 0x74, 0x72, 0x57, 0x86, 0xd7, 0x89, 0xee, 0xf2, 0xa1,
	0x02, 0x8b, 0x7d, 0xbf, 0x20, 0x96, 0x9e, 0x00, 0xda, 0x4f, 0x21, 0xf7, 0xd6, 0x90, 0x0a, 0xe1,
	0x15, 0x72, 0x13, 0x1f, 0xb2, 0xd4, 0xdc, 0xf8, 0x7d, 0xa2, 0x23, 0xcf, 0x78, 0xeb, 0x41, 0xbf,
	0xe8, 0xf8, 0xe6, 0x25, 0xb8, 0x05, 0x5d, 0x1a, 0x74, 0xca, 0x13, 0x46, 0x95, 0xdc, 0x1b, 0xc3,
	0x29, 0x49, 0xd7, 0xdc, 0x55, 0x7a, 0xbe, 0xc2, 0xc8, 0x2b, 0xbc, 0xf5, 0x44, 0xb4, 0xc1, 0x54,
	0x9d, 0xfb, 0xc1, 0xf0, 0x8a, 0xf2, 0x2a, 0xbf, 0xec, 0xf3, 0x2a, 0xf1, 0x8c, 0x46, 0x75, 0xb3,
	0x49, 0xee, 0xf2, 0x90, 0x5a, 0xe2, 0x02, 0x9b, 0x57, 0x3e, 0x7f, 0xb0, 0xa2, 0x7c, 0xf1, 0x60,
	0x45, 0xb9, 0xff, 0x60, 0x45, 0xf9, 0xe8, 0xe1, 0xca, 0xd8, 0x17, 0x0f, 0x57, 0xc6, 0xfe, 0xfe,
	0x70, 0x65, 0xec, 0x27, 0xab, 0x12, 0x49, 0xc0, 0x9e, 0xb4, 0x7f, 0x5e, 0x6a, 0x6d, 0x94, 0x18,
	0xed, 0x50, 0xf9, 0x31, 0xf7, 0x60, 0x92, 0x0f, 0x9c, 0x97, 0xfe, 0x17, 0x00, 0x00, 0xff, 0xff,
	0xf1, 0x98, 0x0c, 0xde, 0xf1, 0x1b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MigrationMsgClient is the client API for MigrationMsg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MigrationMsgClient interface {
	// Migrate user position from legacy vault to new share-based vault
	MigratePosition(ctx context.Context, in *MsgMigratePosition, opts ...grpc.CallOption) (*MsgMigratePositionResponse, error)
	// Emergency withdrawal from legacy vault (when migration is cancelled/failed)
	EmergencyWithdrawLegacy(ctx context.Context, in *MsgEmergencyWithdrawLegacy, opts ...grpc.CallOption) (*MsgEmergencyWithdrawLegacyResponse, error)
	// Update migration state (authority only)
	UpdateMigrationState(ctx context.Context, in *MsgUpdateMigrationState, opts ...grpc.CallOption) (*MsgUpdateMigrationStateResponse, error)
}

type migrationMsgClient struct {
	cc grpc1.ClientConn
}

func NewMigrationMsgClient(cc grpc1.ClientConn) MigrationMsgClient {
	return &migrationMsgClient{cc}
}

func (c *migrationMsgClient) MigratePosition(ctx context.Context, in *MsgMigratePosition, opts ...grpc.CallOption) (*MsgMigratePositionResponse, error) {
	out := new(MsgMigratePositionResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v1.MigrationMsg/MigratePosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *migrationMsgClient) EmergencyWithdrawLegacy(ctx context.Context, in *MsgEmergencyWithdrawLegacy, opts ...grpc.CallOption) (*MsgEmergencyWithdrawLegacyResponse, error) {
	out := new(MsgEmergencyWithdrawLegacyResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v1.MigrationMsg/EmergencyWithdrawLegacy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *migrationMsgClient) UpdateMigrationState(ctx context.Context, in *MsgUpdateMigrationState, opts ...grpc.CallOption) (*MsgUpdateMigrationStateResponse, error) {
	out := new(MsgUpdateMigrationStateResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v1.MigrationMsg/UpdateMigrationState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MigrationMsgServer is the server API for MigrationMsg service.
type MigrationMsgServer interface {
	// Migrate user position from legacy vault to new share-based vault
	MigratePosition(context.Context, *MsgMigratePosition) (*MsgMigratePositionResponse, error)
	// Emergency withdrawal from legacy vault (when migration is cancelled/failed)
	EmergencyWithdrawLegacy(context.Context, *MsgEmergencyWithdrawLegacy) (*MsgEmergencyWithdrawLegacyResponse, error)
	// Update migration state (authority only)
	UpdateMigrationState(context.Context, *MsgUpdateMigrationState) (*MsgUpdateMigrationStateResponse, error)
}

// UnimplementedMigrationMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMigrationMsgServer struct {
}

func (*UnimplementedMigrationMsgServer) MigratePosition(ctx context.Context, req *MsgMigratePosition) (*MsgMigratePositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigratePosition not implemented")
}
func (*UnimplementedMigrationMsgServer) EmergencyWithdrawLegacy(ctx context.Context, req *MsgEmergencyWithdrawLegacy) (*MsgEmergencyWithdrawLegacyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmergencyWithdrawLegacy not implemented")
}
func (*UnimplementedMigrationMsgServer) UpdateMigrationState(ctx context.Context, req *MsgUpdateMigrationState) (*MsgUpdateMigrationStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMigrationState not implemented")
}

func RegisterMigrationMsgServer(s grpc1.Server, srv MigrationMsgServer) {
	s.RegisterService(&_MigrationMsg_serviceDesc, srv)
}

func _MigrationMsg_MigratePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMigratePosition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MigrationMsgServer).MigratePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v1.MigrationMsg/MigratePosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MigrationMsgServer).MigratePosition(ctx, req.(*MsgMigratePosition))
	}
	return interceptor(ctx, in, info, handler)
}

func _MigrationMsg_EmergencyWithdrawLegacy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgEmergencyWithdrawLegacy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MigrationMsgServer).EmergencyWithdrawLegacy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v1.MigrationMsg/EmergencyWithdrawLegacy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MigrationMsgServer).EmergencyWithdrawLegacy(ctx, req.(*MsgEmergencyWithdrawLegacy))
	}
	return interceptor(ctx, in, info, handler)
}

func _MigrationMsg_UpdateMigrationState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateMigrationState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MigrationMsgServer).UpdateMigrationState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v1.MigrationMsg/UpdateMigrationState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MigrationMsgServer).UpdateMigrationState(ctx, req.(*MsgUpdateMigrationState))
	}
	return interceptor(ctx, in, info, handler)
}

var MigrationMsg_serviceDesc = _MigrationMsg_serviceDesc
var _MigrationMsg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "noble.dollar.vaults.v1.MigrationMsg",
	HandlerType: (*MigrationMsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MigratePosition",
			Handler:    _MigrationMsg_MigratePosition_Handler,
		},
		{
			MethodName: "EmergencyWithdrawLegacy",
			Handler:    _MigrationMsg_EmergencyWithdrawLegacy_Handler,
		},
		{
			MethodName: "UpdateMigrationState",
			Handler:    _MigrationMsg_UpdateMigrationState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "noble/dollar/vaults/v1/migration.proto",
}

// MigrationQueryClient is the client API for MigrationQuery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MigrationQueryClient interface {
	// Get current migration status
	MigrationStatus(ctx context.Context, in *QueryMigrationStatusRequest, opts ...grpc.CallOption) (*QueryMigrationStatusResponse, error)
	// Get user's migration status
	UserMigrationStatus(ctx context.Context, in *QueryUserMigrationStatusRequest, opts ...grpc.CallOption) (*QueryUserMigrationStatusResponse, error)
	// Preview migration outcome for a user
	MigrationPreview(ctx context.Context, in *QueryMigrationPreviewRequest, opts ...grpc.CallOption) (*QueryMigrationPreviewResponse, error)
}

type migrationQueryClient struct {
	cc grpc1.ClientConn
}

func NewMigrationQueryClient(cc grpc1.ClientConn) MigrationQueryClient {
	return &migrationQueryClient{cc}
}

func (c *migrationQueryClient) MigrationStatus(ctx context.Context, in *QueryMigrationStatusRequest, opts ...grpc.CallOption) (*QueryMigrationStatusResponse, error) {
	out := new(QueryMigrationStatusResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v1.MigrationQuery/MigrationStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *migrationQueryClient) UserMigrationStatus(ctx context.Context, in *QueryUserMigrationStatusRequest, opts ...grpc.CallOption) (*QueryUserMigrationStatusResponse, error) {
	out := new(QueryUserMigrationStatusResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v1.MigrationQuery/UserMigrationStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *migrationQueryClient) MigrationPreview(ctx context.Context, in *QueryMigrationPreviewRequest, opts ...grpc.CallOption) (*QueryMigrationPreviewResponse, error) {
	out := new(QueryMigrationPreviewResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v1.MigrationQuery/MigrationPreview", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MigrationQueryServer is the server API for MigrationQuery service.
type MigrationQueryServer interface {
	// Get current migration status
	MigrationStatus(context.Context, *QueryMigrationStatusRequest) (*QueryMigrationStatusResponse, error)
	// Get user's migration status
	UserMigrationStatus(context.Context, *QueryUserMigrationStatusRequest) (*QueryUserMigrationStatusResponse, error)
	// Preview migration outcome for a user
	MigrationPreview(context.Context, *QueryMigrationPreviewRequest) (*QueryMigrationPreviewResponse, error)
}

// UnimplementedMigrationQueryServer can be embedded to have forward compatible implementations.
type UnimplementedMigrationQueryServer struct {
}

func (*UnimplementedMigrationQueryServer) MigrationStatus(ctx context.Context, req *QueryMigrationStatusRequest) (*QueryMigrationStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrationStatus not implemented")
}
func (*UnimplementedMigrationQueryServer) UserMigrationStatus(ctx context.Context, req *QueryUserMigrationStatusRequest) (*QueryUserMigrationStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserMigrationStatus not implemented")
}
func (*UnimplementedMigrationQueryServer) MigrationPreview(ctx context.Context, req *QueryMigrationPreviewRequest) (*QueryMigrationPreviewResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrationPreview not implemented")
}

func RegisterMigrationQueryServer(s grpc1.Server, srv MigrationQueryServer) {
	s.RegisterService(&_MigrationQuery_serviceDesc, srv)
}

func _MigrationQuery_MigrationStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMigrationStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MigrationQueryServer).MigrationStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v1.MigrationQuery/MigrationStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MigrationQueryServer).MigrationStatus(ctx, req.(*QueryMigrationStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MigrationQuery_UserMigrationStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserMigrationStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MigrationQueryServer).UserMigrationStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v1.MigrationQuery/UserMigrationStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MigrationQueryServer).UserMigrationStatus(ctx, req.(*QueryUserMigrationStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MigrationQuery_MigrationPreview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMigrationPreviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MigrationQueryServer).MigrationPreview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v1.MigrationQuery/MigrationPreview",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MigrationQueryServer).MigrationPreview(ctx, req.(*QueryMigrationPreviewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var MigrationQuery_serviceDesc = _MigrationQuery_serviceDesc
var _MigrationQuery_serviceDesc = grpc.ServiceDesc{
	ServiceName: "noble.dollar.vaults.v1.MigrationQuery",
	HandlerType: (*MigrationQueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MigrationStatus",
			Handler:    _MigrationQuery_MigrationStatus_Handler,
		},
		{
			MethodName: "UserMigrationStatus",
			Handler:    _MigrationQuery_UserMigrationStatus_Handler,
		},
		{
			MethodName: "MigrationPreview",
			Handler:    _MigrationQuery_MigrationPreview_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "noble/dollar/vaults/v1/migration.proto",
}

func (m *MsgMigratePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMigratePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMigratePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForgoYield {
		i--
		if m.ForgoYield {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.VaultType != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMigratePositionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMigratePositionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMigratePositionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GasUsed != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x28
	}
	if len(m.MigrationTxHash) > 0 {
		i -= len(m.MigrationTxHash)
		copy(dAtA[i:], m.MigrationTxHash)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.MigrationTxHash)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.RewardsMigrated.Size()
		i -= size
		if _, err := m.RewardsMigrated.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PrincipalMigrated.Size()
		i -= size
		if _, err := m.PrincipalMigrated.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.SharesReceived.Size()
		i -= size
		if _, err := m.SharesReceived.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgEmergencyWithdrawLegacy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEmergencyWithdrawLegacy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEmergencyWithdrawLegacy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PositionIndices) > 0 {
		dAtA2 := make([]byte, len(m.PositionIndices)*10)
		var j1 int
		for _, num1 := range m.PositionIndices {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintMigration(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.VaultType != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEmergencyWithdrawLegacyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEmergencyWithdrawLegacyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEmergencyWithdrawLegacyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionsWithdrawn != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.PositionsWithdrawn))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.AmountWithdrawn.Size()
		i -= size
		if _, err := m.AmountWithdrawn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateMigrationState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateMigrationState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateMigrationState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NewState != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.NewState))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateMigrationStateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateMigrationStateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateMigrationStateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintMigration(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x1a
	if m.NewState != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.NewState))
		i--
		dAtA[i] = 0x10
	}
	if m.PreviousState != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.PreviousState))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MigrationConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrationConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrationConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MigrationEnabled {
		i--
		if m.MigrationEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireFullMigration {
		i--
		if m.RequireFullMigration {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.MinMigrationAmount.Size()
		i -= size
		if _, err := m.MinMigrationAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.MaxMigrationPerBlock != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.MaxMigrationPerBlock))
		i--
		dAtA[i] = 0x20
	}
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.FinalDeadline, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.FinalDeadline):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintMigration(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x1a
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ClosingTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ClosingTime):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintMigration(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x12
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.StartTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.StartTime):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintMigration(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UserMigrationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMigrationRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserMigrationRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.YieldForgone {
		i--
		if m.YieldForgone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.GasUsed != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x40
	}
	if len(m.MigrationTxHash) > 0 {
		i -= len(m.MigrationTxHash)
		copy(dAtA[i:], m.MigrationTxHash)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.MigrationTxHash)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.SharesReceived.Size()
		i -= size
		if _, err := m.SharesReceived.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.RewardsMigrated.Size()
		i -= size
		if _, err := m.RewardsMigrated.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.PrincipalMigrated.Size()
		i -= size
		if _, err := m.PrincipalMigrated.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.LegacyPositionCount != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.LegacyPositionCount))
		i--
		dAtA[i] = 0x18
	}
	if m.FromVaultType != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.FromVaultType))
		i--
		dAtA[i] = 0x10
	}
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.MigratedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.MigratedAt):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintMigration(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MigrationStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrationStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrationStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompletionPercentage != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.CompletionPercentage))
		i--
		dAtA[i] = 0x40
	}
	if m.AverageGasPerMigration != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.AverageGasPerMigration))
		i--
		dAtA[i] = 0x38
	}
	n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastMigrationTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastMigrationTime):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintMigration(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x32
	{
		size := m.TotalSharesIssued.Size()
		i -= size
		if _, err := m.TotalSharesIssued.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.ValueMigrated.Size()
		i -= size
		if _, err := m.ValueMigrated.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalValueLocked.Size()
		i -= size
		if _, err := m.TotalValueLocked.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.UsersMigrated != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.UsersMigrated))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalUsers != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.TotalUsers))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LockedLegacyPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockedLegacyPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockedLegacyPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LockReason) > 0 {
		i -= len(m.LockReason)
		copy(dAtA[i:], m.LockReason)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.LockReason)))
		i--
		dAtA[i] = 0x32
	}
	if m.UnlockEnabled {
		i--
		if m.UnlockEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.MigrationId) > 0 {
		i -= len(m.MigrationId)
		copy(dAtA[i:], m.MigrationId)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.MigrationId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MigratedTo) > 0 {
		i -= len(m.MigratedTo)
		copy(dAtA[i:], m.MigratedTo)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.MigratedTo)))
		i--
		dAtA[i] = 0x1a
	}
	n9, err9 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LockedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LockedAt):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintMigration(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x12
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMigration(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MigrationPreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrationPreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrationPreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionCount != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.PositionCount))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.CurrentNav.Size()
		i -= size
		if _, err := m.CurrentNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.EstimatedShares.Size()
		i -= size
		if _, err := m.EstimatedShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.AccruedRewards.Size()
		i -= size
		if _, err := m.AccruedRewards.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PrincipalAmount.Size()
		i -= size
		if _, err := m.PrincipalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalValue.Size()
		i -= size
		if _, err := m.TotalValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MigrationBlockReason) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrationBlockReason) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrationBlockReason) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiresAt != nil {
		n11, err11 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ExpiresAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ExpiresAt):])
		if err11 != nil {
			return 0, err11
		}
		i -= n11
		i = encodeVarintMigration(dAtA, i, uint64(n11))
		i--
		dAtA[i] = 0x22
	}
	if m.Temporary {
		i--
		if m.Temporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReasonMessage) > 0 {
		i -= len(m.ReasonMessage)
		copy(dAtA[i:], m.ReasonMessage)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.ReasonMessage)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ReasonCode) > 0 {
		i -= len(m.ReasonCode)
		copy(dAtA[i:], m.ReasonCode)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.ReasonCode)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryMigrationStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMigrationStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMigrationStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryMigrationStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMigrationStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMigrationStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UsersRemaining != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.UsersRemaining))
		i--
		dAtA[i] = 0x28
	}
	if m.UsersMigrated != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.UsersMigrated))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.TotalRemaining.Size()
		i -= size
		if _, err := m.TotalRemaining.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalMigrated.Size()
		i -= size
		if _, err := m.TotalMigrated.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.State != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryUserMigrationStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserMigrationStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUserMigrationStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VaultType != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryUserMigrationStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserMigrationStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUserMigrationStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.EstimatedShares.Size()
		i -= size
		if _, err := m.EstimatedShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.MigrationRecord != nil {
		{
			size, err := m.MigrationRecord.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMigration(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.LegacyPositions) > 0 {
		for iNdEx := len(m.LegacyPositions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LegacyPositions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMigration(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.HasMigrated {
		i--
		if m.HasMigrated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryMigrationPreviewRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMigrationPreviewRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMigrationPreviewRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VaultType != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMigration(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryMigrationPreviewResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMigrationPreviewResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMigrationPreviewResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionCount != 0 {
		i = encodeVarintMigration(dAtA, i, uint64(m.PositionCount))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.CurrentNav.Size()
		i -= size
		if _, err := m.CurrentNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.EstimatedShares.Size()
		i -= size
		if _, err := m.EstimatedShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.AccruedRewards.Size()
		i -= size
		if _, err := m.AccruedRewards.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PrincipalAmount.Size()
		i -= size
		if _, err := m.PrincipalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalValue.Size()
		i -= size
		if _, err := m.TotalValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMigration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintMigration(dAtA []byte, offset int, v uint64) int {
	offset -= sovMigration(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgMigratePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	if m.VaultType != 0 {
		n += 1 + sovMigration(uint64(m.VaultType))
	}
	l = m.Amount.Size()
	n += 1 + l + sovMigration(uint64(l))
	if m.ForgoYield {
		n += 2
	}
	return n
}

func (m *MsgMigratePositionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SharesReceived.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.PrincipalMigrated.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.RewardsMigrated.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = len(m.MigrationTxHash)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	if m.GasUsed != 0 {
		n += 1 + sovMigration(uint64(m.GasUsed))
	}
	return n
}

func (m *MsgEmergencyWithdrawLegacy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	if m.VaultType != 0 {
		n += 1 + sovMigration(uint64(m.VaultType))
	}
	if len(m.PositionIndices) > 0 {
		l = 0
		for _, e := range m.PositionIndices {
			l += sovMigration(uint64(e))
		}
		n += 1 + sovMigration(uint64(l)) + l
	}
	return n
}

func (m *MsgEmergencyWithdrawLegacyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AmountWithdrawn.Size()
	n += 1 + l + sovMigration(uint64(l))
	if m.PositionsWithdrawn != 0 {
		n += 1 + sovMigration(uint64(m.PositionsWithdrawn))
	}
	return n
}

func (m *MsgUpdateMigrationState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	if m.NewState != 0 {
		n += 1 + sovMigration(uint64(m.NewState))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	return n
}

func (m *MsgUpdateMigrationStateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreviousState != 0 {
		n += 1 + sovMigration(uint64(m.PreviousState))
	}
	if m.NewState != 0 {
		n += 1 + sovMigration(uint64(m.NewState))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovMigration(uint64(l))
	return n
}

func (m *MigrationConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.StartTime)
	n += 1 + l + sovMigration(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ClosingTime)
	n += 1 + l + sovMigration(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.FinalDeadline)
	n += 1 + l + sovMigration(uint64(l))
	if m.MaxMigrationPerBlock != 0 {
		n += 1 + sovMigration(uint64(m.MaxMigrationPerBlock))
	}
	l = m.MinMigrationAmount.Size()
	n += 1 + l + sovMigration(uint64(l))
	if m.RequireFullMigration {
		n += 2
	}
	if m.MigrationEnabled {
		n += 2
	}
	return n
}

func (m *UserMigrationRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.MigratedAt)
	n += 1 + l + sovMigration(uint64(l))
	if m.FromVaultType != 0 {
		n += 1 + sovMigration(uint64(m.FromVaultType))
	}
	if m.LegacyPositionCount != 0 {
		n += 1 + sovMigration(uint64(m.LegacyPositionCount))
	}
	l = m.PrincipalMigrated.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.RewardsMigrated.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.SharesReceived.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = len(m.MigrationTxHash)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	if m.GasUsed != 0 {
		n += 1 + sovMigration(uint64(m.GasUsed))
	}
	if m.YieldForgone {
		n += 2
	}
	return n
}

func (m *MigrationStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalUsers != 0 {
		n += 1 + sovMigration(uint64(m.TotalUsers))
	}
	if m.UsersMigrated != 0 {
		n += 1 + sovMigration(uint64(m.UsersMigrated))
	}
	l = m.TotalValueLocked.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.ValueMigrated.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.TotalSharesIssued.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastMigrationTime)
	n += 1 + l + sovMigration(uint64(l))
	if m.AverageGasPerMigration != 0 {
		n += 1 + sovMigration(uint64(m.AverageGasPerMigration))
	}
	if m.CompletionPercentage != 0 {
		n += 1 + sovMigration(uint64(m.CompletionPercentage))
	}
	return n
}

func (m *LockedLegacyPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovMigration(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LockedAt)
	n += 1 + l + sovMigration(uint64(l))
	l = len(m.MigratedTo)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	l = len(m.MigrationId)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	if m.UnlockEnabled {
		n += 2
	}
	l = len(m.LockReason)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	return n
}

func (m *MigrationPreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalValue.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.PrincipalAmount.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.AccruedRewards.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.EstimatedShares.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.CurrentNav.Size()
	n += 1 + l + sovMigration(uint64(l))
	if m.PositionCount != 0 {
		n += 1 + sovMigration(uint64(m.PositionCount))
	}
	return n
}

func (m *MigrationBlockReason) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReasonCode)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	l = len(m.ReasonMessage)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	if m.Temporary {
		n += 2
	}
	if m.ExpiresAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ExpiresAt)
		n += 1 + l + sovMigration(uint64(l))
	}
	return n
}

func (m *QueryMigrationStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryMigrationStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovMigration(uint64(m.State))
	}
	l = m.TotalMigrated.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.TotalRemaining.Size()
	n += 1 + l + sovMigration(uint64(l))
	if m.UsersMigrated != 0 {
		n += 1 + sovMigration(uint64(m.UsersMigrated))
	}
	if m.UsersRemaining != 0 {
		n += 1 + sovMigration(uint64(m.UsersRemaining))
	}
	return n
}

func (m *QueryUserMigrationStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	if m.VaultType != 0 {
		n += 1 + sovMigration(uint64(m.VaultType))
	}
	return n
}

func (m *QueryUserMigrationStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HasMigrated {
		n += 2
	}
	if len(m.LegacyPositions) > 0 {
		for _, e := range m.LegacyPositions {
			l = e.Size()
			n += 1 + l + sovMigration(uint64(l))
		}
	}
	if m.MigrationRecord != nil {
		l = m.MigrationRecord.Size()
		n += 1 + l + sovMigration(uint64(l))
	}
	l = m.EstimatedShares.Size()
	n += 1 + l + sovMigration(uint64(l))
	return n
}

func (m *QueryMigrationPreviewRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMigration(uint64(l))
	}
	if m.VaultType != 0 {
		n += 1 + sovMigration(uint64(m.VaultType))
	}
	return n
}

func (m *QueryMigrationPreviewResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalValue.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.PrincipalAmount.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.AccruedRewards.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.EstimatedShares.Size()
	n += 1 + l + sovMigration(uint64(l))
	l = m.CurrentNav.Size()
	n += 1 + l + sovMigration(uint64(l))
	if m.PositionCount != 0 {
		n += 1 + sovMigration(uint64(m.PositionCount))
	}
	return n
}

func sovMigration(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMigration(x uint64) (n int) {
	return sovMigration(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgMigratePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMigratePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMigratePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForgoYield", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForgoYield = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMigratePositionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMigratePositionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMigratePositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesReceived.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrincipalMigrated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrincipalMigrated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardsMigrated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewardsMigrated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MigrationTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEmergencyWithdrawLegacy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEmergencyWithdrawLegacy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEmergencyWithdrawLegacy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMigration
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PositionIndices = append(m.PositionIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMigration
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMigration
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMigration
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PositionIndices) == 0 {
					m.PositionIndices = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMigration
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PositionIndices = append(m.PositionIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionIndices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEmergencyWithdrawLegacyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEmergencyWithdrawLegacyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEmergencyWithdrawLegacyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionsWithdrawn", wireType)
			}
			m.PositionsWithdrawn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionsWithdrawn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateMigrationState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateMigrationState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateMigrationState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewState", wireType)
			}
			m.NewState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewState |= MigrationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateMigrationStateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateMigrationStateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateMigrationStateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousState", wireType)
			}
			m.PreviousState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreviousState |= MigrationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewState", wireType)
			}
			m.NewState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewState |= MigrationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrationConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrationConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrationConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.StartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosingTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ClosingTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalDeadline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.FinalDeadline, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMigrationPerBlock", wireType)
			}
			m.MaxMigrationPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMigrationPerBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinMigrationAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinMigrationAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFullMigration", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFullMigration = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MigrationEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMigrationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMigrationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMigrationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigratedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.MigratedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromVaultType", wireType)
			}
			m.FromVaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromVaultType |= VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyPositionCount", wireType)
			}
			m.LegacyPositionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LegacyPositionCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrincipalMigrated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrincipalMigrated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardsMigrated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewardsMigrated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesReceived.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MigrationTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldForgone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.YieldForgone = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrationStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrationStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrationStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsers", wireType)
			}
			m.TotalUsers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUsers |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsersMigrated", wireType)
			}
			m.UsersMigrated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsersMigrated |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValueLocked", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalValueLocked.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueMigrated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValueMigrated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSharesIssued", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSharesIssued.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMigrationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastMigrationTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageGasPerMigration", wireType)
			}
			m.AverageGasPerMigration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AverageGasPerMigration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionPercentage", wireType)
			}
			m.CompletionPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionPercentage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockedLegacyPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockedLegacyPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockedLegacyPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LockedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigratedTo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MigratedTo = append(m.MigratedTo[:0], dAtA[iNdEx:postIndex]...)
			if m.MigratedTo == nil {
				m.MigratedTo = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MigrationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnlockEnabled = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrationPreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrationPreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrationPreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrincipalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrincipalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccruedRewards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AccruedRewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EstimatedShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionCount", wireType)
			}
			m.PositionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrationBlockReason) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrationBlockReason: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrationBlockReason: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Temporary = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiresAt == nil {
				m.ExpiresAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ExpiresAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMigrationStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMigrationStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMigrationStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMigrationStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMigrationStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMigrationStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= MigrationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMigrated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalMigrated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRemaining", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRemaining.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsersMigrated", wireType)
			}
			m.UsersMigrated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsersMigrated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsersRemaining", wireType)
			}
			m.UsersRemaining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsersRemaining |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserMigrationStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserMigrationStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserMigrationStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserMigrationStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserMigrationStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserMigrationStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMigrated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMigrated = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyPositions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LegacyPositions = append(m.LegacyPositions, &Position{})
			if err := m.LegacyPositions[len(m.LegacyPositions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MigrationRecord == nil {
				m.MigrationRecord = &UserMigrationRecord{}
			}
			if err := m.MigrationRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EstimatedShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMigrationPreviewRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMigrationPreviewRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMigrationPreviewRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMigrationPreviewResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMigrationPreviewResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMigrationPreviewResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrincipalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrincipalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccruedRewards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AccruedRewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EstimatedShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMigration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMigration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionCount", wireType)
			}
			m.PositionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMigration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMigration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMigration(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMigration
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMigration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMigration
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMigration
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMigration
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMigration        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMigration          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMigration = fmt.Errorf("proto: unexpected end of group")
)
