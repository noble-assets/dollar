// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/vaults.proto

package v2

import (
	cosmossdk_io_math "cosmossdk.io/math"
	vaults "dollar.noble.xyz/v2/types/vaults"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ExitRequestStatus represents the status of an exit request
type ExitRequestStatus int32

const (
	// Request is pending (waiting for unlock time)
	EXIT_REQUEST_STATUS_PENDING ExitRequestStatus = 0
	// Request is ready to be processed
	EXIT_REQUEST_STATUS_READY ExitRequestStatus = 1
	// Request has been processed
	EXIT_REQUEST_STATUS_PROCESSED ExitRequestStatus = 2
	// Request was cancelled by user
	EXIT_REQUEST_STATUS_CANCELLED ExitRequestStatus = 3
	// Request expired without processing
	EXIT_REQUEST_STATUS_EXPIRED ExitRequestStatus = 4
)

var ExitRequestStatus_name = map[int32]string{
	0: "EXIT_REQUEST_STATUS_PENDING",
	1: "EXIT_REQUEST_STATUS_READY",
	2: "EXIT_REQUEST_STATUS_PROCESSED",
	3: "EXIT_REQUEST_STATUS_CANCELLED",
	4: "EXIT_REQUEST_STATUS_EXPIRED",
}

var ExitRequestStatus_value = map[string]int32{
	"EXIT_REQUEST_STATUS_PENDING":   0,
	"EXIT_REQUEST_STATUS_READY":     1,
	"EXIT_REQUEST_STATUS_PROCESSED": 2,
	"EXIT_REQUEST_STATUS_CANCELLED": 3,
	"EXIT_REQUEST_STATUS_EXPIRED":   4,
}

func (x ExitRequestStatus) String() string {
	return proto.EnumName(ExitRequestStatus_name, int32(x))
}

func (ExitRequestStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{0}
}

// UserPosition represents a user's position in the V2 share-based vault system
type UserPosition struct {
	// Total shares owned by the user
	Shares cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=shares,proto3,customtype=cosmossdk.io/math.Int" json:"shares"`
	// Original deposit amount (for tracking purposes)
	OriginalDeposit cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=original_deposit,json=originalDeposit,proto3,customtype=cosmossdk.io/math.Int" json:"original_deposit"`
	// Timestamp of first deposit
	FirstDepositTime time.Time `protobuf:"bytes,3,opt,name=first_deposit_time,json=firstDepositTime,proto3,stdtime" json:"first_deposit_time"`
	// Timestamp of last deposit/withdrawal
	LastActivityTime time.Time `protobuf:"bytes,4,opt,name=last_activity_time,json=lastActivityTime,proto3,stdtime" json:"last_activity_time"`
	// Whether user wants to receive yield (vs contributing to fee pool)
	ReceiveYield bool `protobuf:"varint,5,opt,name=receive_yield,json=receiveYield,proto3" json:"receive_yield,omitempty"`
	// Shares pending exit (for staked vaults)
	SharesPendingExit cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=shares_pending_exit,json=sharesPendingExit,proto3,customtype=cosmossdk.io/math.Int" json:"shares_pending_exit"`
	// Number of active exit requests
	ActiveExitRequests int32 `protobuf:"varint,7,opt,name=active_exit_requests,json=activeExitRequests,proto3" json:"active_exit_requests,omitempty"`
}

func (m *UserPosition) Reset()         { *m = UserPosition{} }
func (m *UserPosition) String() string { return proto.CompactTextString(m) }
func (*UserPosition) ProtoMessage()    {}
func (*UserPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{0}
}
func (m *UserPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPosition.Merge(m, src)
}
func (m *UserPosition) XXX_Size() int {
	return m.Size()
}
func (m *UserPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPosition.DiscardUnknown(m)
}

var xxx_messageInfo_UserPosition proto.InternalMessageInfo

func (m *UserPosition) GetFirstDepositTime() time.Time {
	if m != nil {
		return m.FirstDepositTime
	}
	return time.Time{}
}

func (m *UserPosition) GetLastActivityTime() time.Time {
	if m != nil {
		return m.LastActivityTime
	}
	return time.Time{}
}

func (m *UserPosition) GetReceiveYield() bool {
	if m != nil {
		return m.ReceiveYield
	}
	return false
}

func (m *UserPosition) GetActiveExitRequests() int32 {
	if m != nil {
		return m.ActiveExitRequests
	}
	return 0
}

// ExitRequest represents a pending exit from a staked vault
type ExitRequest struct {
	// Unique request ID
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Shares to be exited
	Shares cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=shares,proto3,customtype=cosmossdk.io/math.Int" json:"shares"`
	// When the exit was requested
	RequestTime time.Time `protobuf:"bytes,3,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time"`
	// When the exit can be processed (after unbonding period)
	UnlockTime time.Time `protobuf:"bytes,4,opt,name=unlock_time,json=unlockTime,proto3,stdtime" json:"unlock_time"`
	// Current status of the exit request
	Status ExitRequestStatus `protobuf:"varint,5,opt,name=status,proto3,enum=noble.dollar.vaults.v2.ExitRequestStatus" json:"status,omitempty"`
	// Estimated amount to receive (calculated at request time)
	EstimatedAmount cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=estimated_amount,json=estimatedAmount,proto3,customtype=cosmossdk.io/math.Int" json:"estimated_amount"`
	// Block height when request was made
	RequestBlockHeight int64 `protobuf:"varint,7,opt,name=request_block_height,json=requestBlockHeight,proto3" json:"request_block_height,omitempty"`
}

func (m *ExitRequest) Reset()         { *m = ExitRequest{} }
func (m *ExitRequest) String() string { return proto.CompactTextString(m) }
func (*ExitRequest) ProtoMessage()    {}
func (*ExitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{1}
}
func (m *ExitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExitRequest.Merge(m, src)
}
func (m *ExitRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExitRequest proto.InternalMessageInfo

func (m *ExitRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *ExitRequest) GetRequestTime() time.Time {
	if m != nil {
		return m.RequestTime
	}
	return time.Time{}
}

func (m *ExitRequest) GetUnlockTime() time.Time {
	if m != nil {
		return m.UnlockTime
	}
	return time.Time{}
}

func (m *ExitRequest) GetStatus() ExitRequestStatus {
	if m != nil {
		return m.Status
	}
	return EXIT_REQUEST_STATUS_PENDING
}

func (m *ExitRequest) GetRequestBlockHeight() int64 {
	if m != nil {
		return m.RequestBlockHeight
	}
	return 0
}

// VaultState represents the current state of a V2 vault
type VaultState struct {
	// Vault type
	VaultType vaults.VaultType `protobuf:"varint,1,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// Total shares issued
	TotalShares cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_shares,json=totalShares,proto3,customtype=cosmossdk.io/math.Int" json:"total_shares"`
	// Total Net Asset Value
	TotalNav cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_nav,json=totalNav,proto3,customtype=cosmossdk.io/math.Int" json:"total_nav"`
	// Current share price (NAV per share)
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
	// Total number of users with positions
	TotalUsers uint64 `protobuf:"varint,5,opt,name=total_users,json=totalUsers,proto3" json:"total_users,omitempty"`
	// Whether deposits are currently enabled
	DepositsEnabled bool `protobuf:"varint,6,opt,name=deposits_enabled,json=depositsEnabled,proto3" json:"deposits_enabled,omitempty"`
	// Whether withdrawals are currently enabled
	WithdrawalsEnabled bool `protobuf:"varint,7,opt,name=withdrawals_enabled,json=withdrawalsEnabled,proto3" json:"withdrawals_enabled,omitempty"`
	// Last NAV update timestamp
	LastNavUpdate time.Time `protobuf:"bytes,8,opt,name=last_nav_update,json=lastNavUpdate,proto3,stdtime" json:"last_nav_update"`
	// Total shares pending exit
	TotalSharesPendingExit cosmossdk_io_math.Int `protobuf:"bytes,9,opt,name=total_shares_pending_exit,json=totalSharesPendingExit,proto3,customtype=cosmossdk.io/math.Int" json:"total_shares_pending_exit"`
	// Number of pending exit requests
	PendingExitRequests int32 `protobuf:"varint,10,opt,name=pending_exit_requests,json=pendingExitRequests,proto3" json:"pending_exit_requests,omitempty"`
}

func (m *VaultState) Reset()         { *m = VaultState{} }
func (m *VaultState) String() string { return proto.CompactTextString(m) }
func (*VaultState) ProtoMessage()    {}
func (*VaultState) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{2}
}
func (m *VaultState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VaultState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VaultState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultState.Merge(m, src)
}
func (m *VaultState) XXX_Size() int {
	return m.Size()
}
func (m *VaultState) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultState.DiscardUnknown(m)
}

var xxx_messageInfo_VaultState proto.InternalMessageInfo

func (m *VaultState) GetVaultType() vaults.VaultType {
	if m != nil {
		return m.VaultType
	}
	return vaults.UNSPECIFIED
}

func (m *VaultState) GetTotalUsers() uint64 {
	if m != nil {
		return m.TotalUsers
	}
	return 0
}

func (m *VaultState) GetDepositsEnabled() bool {
	if m != nil {
		return m.DepositsEnabled
	}
	return false
}

func (m *VaultState) GetWithdrawalsEnabled() bool {
	if m != nil {
		return m.WithdrawalsEnabled
	}
	return false
}

func (m *VaultState) GetLastNavUpdate() time.Time {
	if m != nil {
		return m.LastNavUpdate
	}
	return time.Time{}
}

func (m *VaultState) GetPendingExitRequests() int32 {
	if m != nil {
		return m.PendingExitRequests
	}
	return 0
}

// ShareCalculation contains details about share price calculations
type ShareCalculation struct {
	// Total NAV used in calculation
	TotalNav cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_nav,json=totalNav,proto3,customtype=cosmossdk.io/math.Int" json:"total_nav"`
	// Total shares used in calculation
	TotalShares cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_shares,json=totalShares,proto3,customtype=cosmossdk.io/math.Int" json:"total_shares"`
	// Resulting share price
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
	// Calculation timestamp
	CalculationTime time.Time `protobuf:"bytes,4,opt,name=calculation_time,json=calculationTime,proto3,stdtime" json:"calculation_time"`
}

func (m *ShareCalculation) Reset()         { *m = ShareCalculation{} }
func (m *ShareCalculation) String() string { return proto.CompactTextString(m) }
func (*ShareCalculation) ProtoMessage()    {}
func (*ShareCalculation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{3}
}
func (m *ShareCalculation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShareCalculation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShareCalculation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShareCalculation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShareCalculation.Merge(m, src)
}
func (m *ShareCalculation) XXX_Size() int {
	return m.Size()
}
func (m *ShareCalculation) XXX_DiscardUnknown() {
	xxx_messageInfo_ShareCalculation.DiscardUnknown(m)
}

var xxx_messageInfo_ShareCalculation proto.InternalMessageInfo

func (m *ShareCalculation) GetCalculationTime() time.Time {
	if m != nil {
		return m.CalculationTime
	}
	return time.Time{}
}

// DepositResult contains the outcome of a deposit operation
type DepositResult struct {
	// Amount deposited (after fees)
	AmountDeposited cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=amount_deposited,json=amountDeposited,proto3,customtype=cosmossdk.io/math.Int" json:"amount_deposited"`
	// Shares received
	SharesReceived cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=shares_received,json=sharesReceived,proto3,customtype=cosmossdk.io/math.Int" json:"shares_received"`
	// Fees paid
	FeesPaid cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=fees_paid,json=feesPaid,proto3,customtype=cosmossdk.io/math.Int" json:"fees_paid"`
	// Share price at time of deposit
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
}

func (m *DepositResult) Reset()         { *m = DepositResult{} }
func (m *DepositResult) String() string { return proto.CompactTextString(m) }
func (*DepositResult) ProtoMessage()    {}
func (*DepositResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{4}
}
func (m *DepositResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositResult.Merge(m, src)
}
func (m *DepositResult) XXX_Size() int {
	return m.Size()
}
func (m *DepositResult) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositResult.DiscardUnknown(m)
}

var xxx_messageInfo_DepositResult proto.InternalMessageInfo

// WithdrawalResult contains the outcome of a withdrawal operation
type WithdrawalResult struct {
	// Shares redeemed
	SharesRedeemed cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=shares_redeemed,json=sharesRedeemed,proto3,customtype=cosmossdk.io/math.Int" json:"shares_redeemed"`
	// Amount withdrawn (after fees)
	AmountWithdrawn cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount_withdrawn,json=amountWithdrawn,proto3,customtype=cosmossdk.io/math.Int" json:"amount_withdrawn"`
	// Fees paid
	FeesPaid cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=fees_paid,json=feesPaid,proto3,customtype=cosmossdk.io/math.Int" json:"fees_paid"`
	// Share price at time of withdrawal
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
}

func (m *WithdrawalResult) Reset()         { *m = WithdrawalResult{} }
func (m *WithdrawalResult) String() string { return proto.CompactTextString(m) }
func (*WithdrawalResult) ProtoMessage()    {}
func (*WithdrawalResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{5}
}
func (m *WithdrawalResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawalResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawalResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawalResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawalResult.Merge(m, src)
}
func (m *WithdrawalResult) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawalResult) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawalResult.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawalResult proto.InternalMessageInfo

// YieldDistribution represents yield distribution to shareholders
type YieldDistribution struct {
	// Total yield amount distributed
	TotalYield cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_yield,json=totalYield,proto3,customtype=cosmossdk.io/math.Int" json:"total_yield"`
	// Yield per share
	YieldPerShare cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=yield_per_share,json=yieldPerShare,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"yield_per_share"`
	// Distribution timestamp
	DistributionTime time.Time `protobuf:"bytes,3,opt,name=distribution_time,json=distributionTime,proto3,stdtime" json:"distribution_time"`
	// Number of eligible shareholders
	EligibleShareholders uint64 `protobuf:"varint,4,opt,name=eligible_shareholders,json=eligibleShareholders,proto3" json:"eligible_shareholders,omitempty"`
	// Source of the yield (e.g., "staking_rewards", "trading_fees")
	YieldSource string `protobuf:"bytes,5,opt,name=yield_source,json=yieldSource,proto3" json:"yield_source,omitempty"`
}

func (m *YieldDistribution) Reset()         { *m = YieldDistribution{} }
func (m *YieldDistribution) String() string { return proto.CompactTextString(m) }
func (*YieldDistribution) ProtoMessage()    {}
func (*YieldDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{6}
}
func (m *YieldDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *YieldDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_YieldDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *YieldDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_YieldDistribution.Merge(m, src)
}
func (m *YieldDistribution) XXX_Size() int {
	return m.Size()
}
func (m *YieldDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_YieldDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_YieldDistribution proto.InternalMessageInfo

func (m *YieldDistribution) GetDistributionTime() time.Time {
	if m != nil {
		return m.DistributionTime
	}
	return time.Time{}
}

func (m *YieldDistribution) GetEligibleShareholders() uint64 {
	if m != nil {
		return m.EligibleShareholders
	}
	return 0
}

func (m *YieldDistribution) GetYieldSource() string {
	if m != nil {
		return m.YieldSource
	}
	return ""
}

func init() {
	proto.RegisterEnum("noble.dollar.vaults.v2.ExitRequestStatus", ExitRequestStatus_name, ExitRequestStatus_value)
	proto.RegisterType((*UserPosition)(nil), "noble.dollar.vaults.v2.UserPosition")
	proto.RegisterType((*ExitRequest)(nil), "noble.dollar.vaults.v2.ExitRequest")
	proto.RegisterType((*VaultState)(nil), "noble.dollar.vaults.v2.VaultState")
	proto.RegisterType((*ShareCalculation)(nil), "noble.dollar.vaults.v2.ShareCalculation")
	proto.RegisterType((*DepositResult)(nil), "noble.dollar.vaults.v2.DepositResult")
	proto.RegisterType((*WithdrawalResult)(nil), "noble.dollar.vaults.v2.WithdrawalResult")
	proto.RegisterType((*YieldDistribution)(nil), "noble.dollar.vaults.v2.YieldDistribution")
}

func init() {
	proto.RegisterFile("noble/dollar/vaults/v2/vaults.proto", fileDescriptor_a9e05010b6747034)
}

var fileDescriptor_a9e05010b6747034 = []byte{
	// 1164 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0x3d, 0x6f, 0xdb, 0x56,
	0x17, 0x16, 0x65, 0xc5, 0xb1, 0x8e, 0xec, 0x48, 0xbe, 0x89, 0x03, 0xd9, 0x81, 0x25, 0x7f, 0x2c,
	0x4e, 0x80, 0x57, 0x4a, 0x14, 0xe0, 0xdd, 0x0a, 0x54, 0xb6, 0x88, 0x44, 0x80, 0xeb, 0xc8, 0x94,
	0xdc, 0xc4, 0x2d, 0x50, 0xf6, 0x4a, 0xbc, 0x96, 0x2e, 0x4c, 0x91, 0x2a, 0xef, 0xa5, 0x62, 0xf5,
	0x17, 0x74, 0xcc, 0xd4, 0x3f, 0xd0, 0xa5, 0x63, 0x87, 0x02, 0x5d, 0x3b, 0x66, 0x0c, 0x3a, 0x05,
	0x1d, 0xd2, 0xc0, 0x1e, 0x3a, 0x16, 0xed, 0x2f, 0x28, 0xee, 0x07, 0x6d, 0xba, 0x71, 0x06, 0xd3,
	0xcd, 0xd0, 0xc5, 0x10, 0xcf, 0xc7, 0xc3, 0x73, 0x9f, 0x73, 0xf8, 0xdc, 0x63, 0x58, 0xf7, 0xfc,
	0xae, 0x4b, 0xaa, 0x8e, 0xef, 0xba, 0x38, 0xa8, 0x8e, 0x71, 0xe8, 0x72, 0x56, 0x1d, 0xd7, 0xf4,
	0xaf, 0xca, 0x28, 0xf0, 0xb9, 0x8f, 0x6e, 0xcb, 0xa0, 0x8a, 0x0a, 0xaa, 0x68, 0xd7, 0xb8, 0xb6,
	0x34, 0x8f, 0x87, 0xd4, 0xf3, 0xab, 0xf2, 0xaf, 0x0a, 0x5d, 0x5a, 0xec, 0xf9, 0x6c, 0xe8, 0x33,
	0x5b, 0x3e, 0x55, 0xd5, 0x83, 0x76, 0xdd, 0xea, 0xfb, 0x7d, 0x5f, 0xd9, 0xc5, 0x2f, 0x6d, 0x2d,
	0xf7, 0x7d, 0xbf, 0xef, 0x92, 0xaa, 0x7c, 0xea, 0x86, 0x07, 0x55, 0x4e, 0x87, 0x84, 0x71, 0x3c,
	0x1c, 0xe9, 0x80, 0x8b, 0x2b, 0x7c, 0x70, 0xae, 0xc2, 0xb5, 0x6f, 0x33, 0x30, 0xbb, 0xc7, 0x48,
	0xd0, 0xf2, 0x19, 0xe5, 0xd4, 0xf7, 0xd0, 0x63, 0x98, 0x66, 0x03, 0x1c, 0x10, 0x56, 0x34, 0x56,
	0x8c, 0x8d, 0xec, 0xe6, 0xfd, 0x97, 0x6f, 0xca, 0xa9, 0x5f, 0xdf, 0x94, 0x17, 0x54, 0x49, 0xcc,
	0x39, 0xac, 0x50, 0xbf, 0x3a, 0xc4, 0x7c, 0x50, 0x69, 0x7a, 0xfc, 0x97, 0x1f, 0xff, 0x07, 0xba,
	0xd6, 0xa6, 0xc7, 0xbf, 0xff, 0xfd, 0x87, 0x7b, 0x86, 0xa5, 0xf3, 0xd1, 0xe7, 0x50, 0xf0, 0x03,
	0xda, 0xa7, 0x1e, 0x76, 0x6d, 0x87, 0x8c, 0xc4, 0x0b, 0x8a, 0xe9, 0x84, 0x98, 0xf9, 0x08, 0xa9,
	0xa1, 0x80, 0x90, 0x05, 0xe8, 0x80, 0x06, 0x8c, 0x47, 0xc8, 0xb6, 0x38, 0x7d, 0x71, 0x6a, 0xc5,
	0xd8, 0xc8, 0xd5, 0x96, 0x2a, 0x8a, 0x9a, 0x4a, 0x44, 0x4d, 0xa5, 0x13, 0x51, 0xb3, 0x39, 0x23,
	0x5e, 0xfd, 0xe2, 0xb7, 0xb2, 0x61, 0x15, 0x64, 0xbe, 0xc6, 0x13, 0x01, 0x02, 0xd3, 0xc5, 0x8c,
	0xdb, 0xb8, 0xc7, 0xe9, 0x98, 0xf2, 0x89, 0xc2, 0xcc, 0x5c, 0x06, 0x53, 0xe4, 0xd7, 0x75, 0xba,
	0xc4, 0x5c, 0x87, 0xb9, 0x80, 0xf4, 0x08, 0x1d, 0x13, 0x7b, 0x42, 0x89, 0xeb, 0x14, 0xaf, 0xad,
	0x18, 0x1b, 0x33, 0xd6, 0xac, 0x36, 0xee, 0x0b, 0x1b, 0xfa, 0x12, 0x6e, 0x2a, 0xce, 0xec, 0x11,
	0xf1, 0x1c, 0xea, 0xf5, 0x6d, 0x72, 0x44, 0x79, 0x71, 0x3a, 0x21, 0x59, 0xf3, 0x0a, 0xac, 0xa5,
	0xb0, 0xcc, 0x23, 0xca, 0xd1, 0x7d, 0xb8, 0x25, 0x4f, 0x45, 0x24, 0xb2, 0x1d, 0x90, 0xaf, 0x42,
	0xc2, 0x38, 0x2b, 0x5e, 0x5f, 0x31, 0x36, 0xae, 0x59, 0x48, 0xf9, 0x44, 0xa4, 0xa5, 0x3d, 0x6b,
	0xaf, 0xa7, 0x20, 0x17, 0x33, 0xa0, 0x65, 0x00, 0x9d, 0x65, 0x53, 0x47, 0xcd, 0x86, 0x95, 0xd5,
	0x96, 0xa6, 0x13, 0x1b, 0x9b, 0xf4, 0x15, 0xc7, 0xe6, 0x11, 0xcc, 0x46, 0x2f, 0xba, 0x74, 0x4f,
	0x73, 0x3a, 0x53, 0x52, 0x6f, 0x42, 0x2e, 0xf4, 0x5c, 0xbf, 0x77, 0x78, 0xf9, 0x3e, 0x82, 0x4a,
	0x94, 0x30, 0x75, 0x98, 0x66, 0x1c, 0xf3, 0x90, 0xc9, 0xd6, 0xdd, 0xa8, 0xdd, 0xad, 0x5c, 0xfc,
	0x51, 0x57, 0x62, 0x6c, 0xb5, 0x65, 0x82, 0xa5, 0x13, 0xc5, 0x97, 0x40, 0x18, 0xa7, 0x43, 0xcc,
	0x89, 0x63, 0xe3, 0xa1, 0x1f, 0x7a, 0xc9, 0x9b, 0x9b, 0x3f, 0x45, 0xaa, 0x4b, 0x20, 0xd1, 0xda,
	0x88, 0xaf, 0xae, 0x3c, 0xed, 0x80, 0xd0, 0xfe, 0x80, 0xcb, 0xd6, 0x4e, 0x59, 0x48, 0xfb, 0x36,
	0x85, 0xeb, 0xb1, 0xf4, 0xac, 0xfd, 0x74, 0x0d, 0xe0, 0x53, 0x51, 0xb6, 0x28, 0x93, 0xa0, 0x8f,
	0x01, 0xe4, 0x21, 0x6c, 0x3e, 0x19, 0x11, 0xd9, 0xd9, 0x1b, 0xb5, 0xd5, 0x8b, 0x0f, 0xf9, 0xa0,
	0x22, 0xf3, 0x3a, 0x93, 0x11, 0xb1, 0xb2, 0xe3, 0xe8, 0x27, 0x6a, 0xc3, 0x2c, 0xf7, 0x39, 0x76,
	0xed, 0x2b, 0x8e, 0x40, 0x4e, 0xa2, 0xb4, 0xd5, 0x1c, 0x7c, 0x02, 0x59, 0x05, 0xea, 0xe1, 0xb1,
	0x1c, 0x82, 0x24, 0x88, 0x33, 0x12, 0x62, 0x07, 0x8f, 0xd1, 0x53, 0xc8, 0xc9, 0xea, 0xec, 0x51,
	0x40, 0x7b, 0x6a, 0x1a, 0xb2, 0x9b, 0xff, 0xd7, 0x80, 0x77, 0xde, 0x05, 0xdc, 0x26, 0x7d, 0xdc,
	0x9b, 0x34, 0x48, 0x2f, 0x06, 0xdb, 0x20, 0x3d, 0x05, 0x0b, 0x12, 0xaa, 0x25, 0x90, 0x50, 0x19,
	0x54, 0xd9, 0x76, 0xc8, 0x48, 0xa0, 0x86, 0x24, 0x63, 0x81, 0x34, 0x09, 0x61, 0x65, 0xe8, 0x2e,
	0x14, 0xb4, 0x48, 0x31, 0x9b, 0x78, 0xb8, 0xeb, 0x12, 0x47, 0x76, 0x7f, 0xc6, 0xca, 0x47, 0x76,
	0x53, 0x99, 0x51, 0x15, 0x6e, 0x3e, 0xa7, 0x7c, 0xe0, 0x04, 0xf8, 0x39, 0x76, 0xcf, 0xa2, 0xaf,
	0xcb, 0x68, 0x14, 0x73, 0x45, 0x09, 0xdb, 0x90, 0x97, 0x92, 0xe5, 0xe1, 0xb1, 0x1d, 0x8e, 0x1c,
	0xcc, 0x49, 0x71, 0xe6, 0x12, 0x73, 0x3e, 0x27, 0x92, 0x77, 0xf0, 0x78, 0x4f, 0xa6, 0xa2, 0x43,
	0x58, 0x8c, 0xf7, 0xf1, 0xbc, 0x1a, 0x65, 0x13, 0xb6, 0xe0, 0x76, 0xac, 0xa9, 0x71, 0x49, 0xaa,
	0xc1, 0x42, 0x1c, 0xff, 0x4c, 0x93, 0x40, 0x6a, 0xd2, 0xcd, 0xd1, 0x59, 0xec, 0xa9, 0x28, 0xbd,
	0x4d, 0x43, 0x41, 0x22, 0x6d, 0x61, 0xb7, 0x17, 0xba, 0x58, 0xde, 0x58, 0xe7, 0x06, 0xc5, 0xb8,
	0xf2, 0xa0, 0x7c, 0x90, 0x61, 0xfe, 0xc7, 0xf4, 0x4d, 0xfd, 0x6b, 0xd3, 0xf7, 0x04, 0x0a, 0xbd,
	0x33, 0x2e, 0x2e, 0xaf, 0x74, 0xf9, 0x58, 0xb6, 0xf0, 0xaf, 0xfd, 0x91, 0x86, 0x39, 0x7d, 0x29,
	0x5a, 0x84, 0x85, 0x2e, 0x17, 0xea, 0xa5, 0x34, 0x2b, 0xba, 0x6b, 0x89, 0x93, 0x98, 0xe6, 0xbc,
	0x42, 0x6a, 0x44, 0x40, 0x68, 0x1f, 0xf2, 0x7a, 0xd8, 0xf4, 0x8d, 0xe8, 0x24, 0x26, 0xfc, 0x86,
	0x02, 0xb2, 0x34, 0x8e, 0x98, 0x8b, 0x03, 0x22, 0xa6, 0x18, 0x53, 0x27, 0xb9, 0x80, 0x08, 0x88,
	0x16, 0xa6, 0xce, 0x07, 0x13, 0x90, 0xb5, 0xbf, 0xd2, 0x50, 0x78, 0x7a, 0xfa, 0x69, 0x6b, 0xd2,
	0xe3, 0xbc, 0x38, 0x84, 0x0c, 0xaf, 0xc0, 0xf9, 0x29, 0x2f, 0x0a, 0x27, 0xd6, 0xcf, 0x48, 0x50,
	0xbc, 0xe4, 0x7b, 0x99, 0x42, 0x8a, 0xca, 0xf7, 0xfe, 0x33, 0xa4, 0xff, 0x99, 0x86, 0x79, 0xb9,
	0x7c, 0x35, 0x28, 0xe3, 0x01, 0xed, 0x86, 0x52, 0x4a, 0x76, 0x23, 0x2d, 0x57, 0xbb, 0x5a, 0x52,
	0xc6, 0x95, 0xfa, 0xab, 0xdd, 0xee, 0x0b, 0xc8, 0x4b, 0x30, 0x7b, 0x44, 0x02, 0x25, 0x29, 0x9a,
	0xec, 0xa4, 0xa7, 0x98, 0x93, 0x70, 0x2d, 0x12, 0x48, 0x69, 0x41, 0xbb, 0x30, 0xef, 0xc4, 0x8e,
	0x90, 0x60, 0x0f, 0x8e, 0xa7, 0xcb, 0x8d, 0xe7, 0x21, 0x2c, 0x10, 0x97, 0xf6, 0x69, 0xd7, 0x25,
	0xaa, 0xe2, 0x81, 0xef, 0x3a, 0xe2, 0x6e, 0xcb, 0xc8, 0xbb, 0xed, 0x56, 0xe4, 0x6c, 0xc7, 0x7c,
	0x68, 0x15, 0x66, 0xd5, 0x39, 0x99, 0x1f, 0x06, 0x3d, 0x22, 0xef, 0xc1, 0xac, 0x95, 0x93, 0xb6,
	0xb6, 0x34, 0xdd, 0xfb, 0xd9, 0x80, 0xf9, 0x77, 0x96, 0x24, 0x54, 0x86, 0x3b, 0xe6, 0xb3, 0x66,
	0xc7, 0xb6, 0xcc, 0xdd, 0x3d, 0xb3, 0xdd, 0xb1, 0xdb, 0x9d, 0x7a, 0x67, 0xaf, 0x6d, 0xb7, 0xcc,
	0x9d, 0x46, 0x73, 0xe7, 0x51, 0x21, 0x85, 0x96, 0x61, 0xf1, 0xa2, 0x00, 0xcb, 0xac, 0x37, 0xf6,
	0x0b, 0x06, 0x5a, 0x85, 0xe5, 0x0b, 0xf3, 0xad, 0x27, 0x5b, 0x66, 0xbb, 0x6d, 0x36, 0x0a, 0xe9,
	0xf7, 0x85, 0x6c, 0xd5, 0x77, 0xb6, 0xcc, 0xed, 0x6d, 0xb3, 0x51, 0x98, 0x7a, 0x5f, 0x15, 0xe6,
	0xb3, 0x56, 0xd3, 0x32, 0x1b, 0x85, 0xcc, 0x52, 0xe6, 0x9b, 0xef, 0x4a, 0xa9, 0xcd, 0x8f, 0x5e,
	0x1e, 0x97, 0x8c, 0x57, 0xc7, 0x25, 0xe3, 0xed, 0x71, 0xc9, 0x78, 0x71, 0x52, 0x4a, 0xbd, 0x3a,
	0x29, 0xa5, 0x5e, 0x9f, 0x94, 0x52, 0x9f, 0xad, 0xeb, 0x55, 0x49, 0xed, 0x4d, 0x47, 0x93, 0xaf,
	0xc5, 0x3f, 0x83, 0x62, 0xa3, 0x62, 0x67, 0xff, 0x1c, 0x76, 0xa7, 0x65, 0x27, 0x1e, 0xfe, 0x1d,
	0x00, 0x00, 0xff, 0xff, 0xa0, 0x97, 0x87, 0xa7, 0x3d, 0x0e, 0x00, 0x00,
}

func (m *UserPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActiveExitRequests != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.ActiveExitRequests))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.SharesPendingExit.Size()
		i -= size
		if _, err := m.SharesPendingExit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.ReceiveYield {
		i--
		if m.ReceiveYield {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastActivityTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastActivityTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintVaults(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x22
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.FirstDepositTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.FirstDepositTime):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintVaults(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x1a
	{
		size := m.OriginalDeposit.Size()
		i -= size
		if _, err := m.OriginalDeposit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ExitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestBlockHeight != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.RequestBlockHeight))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.EstimatedAmount.Size()
		i -= size
		if _, err := m.EstimatedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.Status != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UnlockTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UnlockTime):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintVaults(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x22
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.RequestTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RequestTime):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintVaults(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x1a
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintVaults(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PendingExitRequests != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.PendingExitRequests))
		i--
		dAtA[i] = 0x50
	}
	{
		size := m.TotalSharesPendingExit.Size()
		i -= size
		if _, err := m.TotalSharesPendingExit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastNavUpdate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastNavUpdate):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintVaults(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x42
	if m.WithdrawalsEnabled {
		i--
		if m.WithdrawalsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.DepositsEnabled {
		i--
		if m.DepositsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.TotalUsers != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.TotalUsers))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalNav.Size()
		i -= size
		if _, err := m.TotalNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalShares.Size()
		i -= size
		if _, err := m.TotalShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.VaultType != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShareCalculation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShareCalculation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShareCalculation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CalculationTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CalculationTime):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintVaults(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x22
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalShares.Size()
		i -= size
		if _, err := m.TotalShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalNav.Size()
		i -= size
		if _, err := m.TotalNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DepositResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.FeesPaid.Size()
		i -= size
		if _, err := m.FeesPaid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SharesReceived.Size()
		i -= size
		if _, err := m.SharesReceived.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.AmountDeposited.Size()
		i -= size
		if _, err := m.AmountDeposited.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WithdrawalResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawalResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawalResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.FeesPaid.Size()
		i -= size
		if _, err := m.FeesPaid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.AmountWithdrawn.Size()
		i -= size
		if _, err := m.AmountWithdrawn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.SharesRedeemed.Size()
		i -= size
		if _, err := m.SharesRedeemed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *YieldDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *YieldDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *YieldDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.YieldSource) > 0 {
		i -= len(m.YieldSource)
		copy(dAtA[i:], m.YieldSource)
		i = encodeVarintVaults(dAtA, i, uint64(len(m.YieldSource)))
		i--
		dAtA[i] = 0x2a
	}
	if m.EligibleShareholders != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.EligibleShareholders))
		i--
		dAtA[i] = 0x20
	}
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.DistributionTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DistributionTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintVaults(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x1a
	{
		size := m.YieldPerShare.Size()
		i -= size
		if _, err := m.YieldPerShare.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalYield.Size()
		i -= size
		if _, err := m.TotalYield.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintVaults(dAtA []byte, offset int, v uint64) int {
	offset -= sovVaults(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shares.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.OriginalDeposit.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.FirstDepositTime)
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastActivityTime)
	n += 1 + l + sovVaults(uint64(l))
	if m.ReceiveYield {
		n += 2
	}
	l = m.SharesPendingExit.Size()
	n += 1 + l + sovVaults(uint64(l))
	if m.ActiveExitRequests != 0 {
		n += 1 + sovVaults(uint64(m.ActiveExitRequests))
	}
	return n
}

func (m *ExitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovVaults(uint64(l))
	}
	l = m.Shares.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RequestTime)
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UnlockTime)
	n += 1 + l + sovVaults(uint64(l))
	if m.Status != 0 {
		n += 1 + sovVaults(uint64(m.Status))
	}
	l = m.EstimatedAmount.Size()
	n += 1 + l + sovVaults(uint64(l))
	if m.RequestBlockHeight != 0 {
		n += 1 + sovVaults(uint64(m.RequestBlockHeight))
	}
	return n
}

func (m *VaultState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VaultType != 0 {
		n += 1 + sovVaults(uint64(m.VaultType))
	}
	l = m.TotalShares.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.TotalNav.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.SharePrice.Size()
	n += 1 + l + sovVaults(uint64(l))
	if m.TotalUsers != 0 {
		n += 1 + sovVaults(uint64(m.TotalUsers))
	}
	if m.DepositsEnabled {
		n += 2
	}
	if m.WithdrawalsEnabled {
		n += 2
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastNavUpdate)
	n += 1 + l + sovVaults(uint64(l))
	l = m.TotalSharesPendingExit.Size()
	n += 1 + l + sovVaults(uint64(l))
	if m.PendingExitRequests != 0 {
		n += 1 + sovVaults(uint64(m.PendingExitRequests))
	}
	return n
}

func (m *ShareCalculation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalNav.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.TotalShares.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.SharePrice.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CalculationTime)
	n += 1 + l + sovVaults(uint64(l))
	return n
}

func (m *DepositResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AmountDeposited.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.SharesReceived.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.FeesPaid.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.SharePrice.Size()
	n += 1 + l + sovVaults(uint64(l))
	return n
}

func (m *WithdrawalResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SharesRedeemed.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.AmountWithdrawn.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.FeesPaid.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.SharePrice.Size()
	n += 1 + l + sovVaults(uint64(l))
	return n
}

func (m *YieldDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalYield.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.YieldPerShare.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DistributionTime)
	n += 1 + l + sovVaults(uint64(l))
	if m.EligibleShareholders != 0 {
		n += 1 + sovVaults(uint64(m.EligibleShareholders))
	}
	l = len(m.YieldSource)
	if l > 0 {
		n += 1 + l + sovVaults(uint64(l))
	}
	return n
}

func sovVaults(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVaults(x uint64) (n int) {
	return sovVaults(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalDeposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OriginalDeposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstDepositTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.FirstDepositTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActivityTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastActivityTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveYield", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReceiveYield = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesPendingExit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesPendingExit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveExitRequests", wireType)
			}
			m.ActiveExitRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveExitRequests |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UnlockTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ExitRequestStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EstimatedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestBlockHeight", wireType)
			}
			m.RequestBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= vaults.VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsers", wireType)
			}
			m.TotalUsers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUsers |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DepositsEnabled = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawalsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithdrawalsEnabled = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastNavUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastNavUpdate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSharesPendingExit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSharesPendingExit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingExitRequests", wireType)
			}
			m.PendingExitRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingExitRequests |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShareCalculation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShareCalculation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShareCalculation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalculationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CalculationTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountDeposited", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountDeposited.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesReceived.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeesPaid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeesPaid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawalResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawalResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawalResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesRedeemed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesRedeemed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeesPaid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeesPaid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *YieldDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: YieldDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: YieldDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalYield", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalYield.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldPerShare", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YieldPerShare.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.DistributionTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EligibleShareholders", wireType)
			}
			m.EligibleShareholders = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EligibleShareholders |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YieldSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVaults(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVaults
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupVaults
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthVaults
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthVaults        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVaults          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupVaults = fmt.Errorf("proto: unexpected end of group")
)
