// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/cross_chain.proto

package v2

import (
	cosmossdk_io_math "cosmossdk.io/math"
	v2 "dollar.noble.xyz/v2/types/v2"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RemotePositionStatus represents the status of a remote position
type RemotePositionStatus int32

const (
	// Position is active and being tracked
	REMOTE_POSITION_ACTIVE RemotePositionStatus = 0
	// Position update is pending
	REMOTE_POSITION_PENDING_UPDATE RemotePositionStatus = 1
	// Position has exceeded drift limits
	REMOTE_POSITION_DRIFT_EXCEEDED RemotePositionStatus = 2
	// Position is being liquidated
	REMOTE_POSITION_LIQUIDATING RemotePositionStatus = 3
	// Position has been closed
	REMOTE_POSITION_CLOSED RemotePositionStatus = 4
	// Position is in error state
	REMOTE_POSITION_ERROR RemotePositionStatus = 5
)

var RemotePositionStatus_name = map[int32]string{
	0: "REMOTE_POSITION_ACTIVE",
	1: "REMOTE_POSITION_PENDING_UPDATE",
	2: "REMOTE_POSITION_DRIFT_EXCEEDED",
	3: "REMOTE_POSITION_LIQUIDATING",
	4: "REMOTE_POSITION_CLOSED",
	5: "REMOTE_POSITION_ERROR",
}

var RemotePositionStatus_value = map[string]int32{
	"REMOTE_POSITION_ACTIVE":         0,
	"REMOTE_POSITION_PENDING_UPDATE": 1,
	"REMOTE_POSITION_DRIFT_EXCEEDED": 2,
	"REMOTE_POSITION_LIQUIDATING":    3,
	"REMOTE_POSITION_CLOSED":         4,
	"REMOTE_POSITION_ERROR":          5,
}

func (x RemotePositionStatus) String() string {
	return proto.EnumName(RemotePositionStatus_name, int32(x))
}

func (RemotePositionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{0}
}

// InFlightOperationType defines the type of cross-chain operation
type InFlightOperationType int32

const (
	// Position deposit to remote chain
	OPERATION_REMOTE_DEPOSIT InFlightOperationType = 0
	// Position withdrawal from remote chain
	OPERATION_REMOTE_WITHDRAW InFlightOperationType = 1
	// Position rebalancing
	OPERATION_REBALANCE InFlightOperationType = 2
	// Position liquidation
	OPERATION_LIQUIDATE InFlightOperationType = 3
)

var InFlightOperationType_name = map[int32]string{
	0: "OPERATION_REMOTE_DEPOSIT",
	1: "OPERATION_REMOTE_WITHDRAW",
	2: "OPERATION_REBALANCE",
	3: "OPERATION_LIQUIDATE",
}

var InFlightOperationType_value = map[string]int32{
	"OPERATION_REMOTE_DEPOSIT":  0,
	"OPERATION_REMOTE_WITHDRAW": 1,
	"OPERATION_REBALANCE":       2,
	"OPERATION_LIQUIDATE":       3,
}

func (x InFlightOperationType) String() string {
	return proto.EnumName(InFlightOperationType_name, int32(x))
}

func (InFlightOperationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{1}
}

// InFlightStatus represents the status of an in-flight operation
type InFlightStatus int32

const (
	// Operation is pending
	INFLIGHT_PENDING InFlightStatus = 0
	// Operation is being processed
	INFLIGHT_PROCESSING InFlightStatus = 1
	// Operation completed successfully
	INFLIGHT_COMPLETED InFlightStatus = 2
	// Operation failed
	INFLIGHT_FAILED InFlightStatus = 3
	// Operation timed out
	INFLIGHT_TIMEOUT InFlightStatus = 4
	// Operation was cancelled
	INFLIGHT_CANCELLED InFlightStatus = 5
)

var InFlightStatus_name = map[int32]string{
	0: "INFLIGHT_PENDING",
	1: "INFLIGHT_PROCESSING",
	2: "INFLIGHT_COMPLETED",
	3: "INFLIGHT_FAILED",
	4: "INFLIGHT_TIMEOUT",
	5: "INFLIGHT_CANCELLED",
}

var InFlightStatus_value = map[string]int32{
	"INFLIGHT_PENDING":    0,
	"INFLIGHT_PROCESSING": 1,
	"INFLIGHT_COMPLETED":  2,
	"INFLIGHT_FAILED":     3,
	"INFLIGHT_TIMEOUT":    4,
	"INFLIGHT_CANCELLED":  5,
}

func (x InFlightStatus) String() string {
	return proto.EnumName(InFlightStatus_name, int32(x))
}

func (InFlightStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{2}
}

// CrossChainRoute defines a route for cross-chain operations
type CrossChainRoute struct {
	// Unique identifier for the route
	RouteId string `protobuf:"bytes,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Source chain identifier
	SourceChain string `protobuf:"bytes,2,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// Destination chain identifier
	DestinationChain string `protobuf:"bytes,3,opt,name=destination_chain,json=destinationChain,proto3" json:"destination_chain,omitempty"`
	// Provider type (IBC or HYPERLANE)
	Provider v2.Provider `protobuf:"varint,4,opt,name=provider,proto3,enum=noble.dollar.v2.Provider" json:"provider,omitempty"`
	// Provider-specific configuration
	ProviderConfig *CrossChainProviderConfig `protobuf:"bytes,5,opt,name=provider_config,json=providerConfig,proto3" json:"provider_config,omitempty"`
	// Whether this route is active
	Active bool `protobuf:"varint,6,opt,name=active,proto3" json:"active,omitempty"`
	// Maximum position value allowed for this route
	MaxPositionValue cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=max_position_value,json=maxPositionValue,proto3,customtype=cosmossdk.io/math.Int" json:"max_position_value"`
	// Risk parameters for this route
	RiskParams *CrossChainRiskParams `protobuf:"bytes,8,opt,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *CrossChainRoute) Reset()         { *m = CrossChainRoute{} }
func (m *CrossChainRoute) String() string { return proto.CompactTextString(m) }
func (*CrossChainRoute) ProtoMessage()    {}
func (*CrossChainRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{0}
}
func (m *CrossChainRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainRoute.Merge(m, src)
}
func (m *CrossChainRoute) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainRoute.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainRoute proto.InternalMessageInfo

func (m *CrossChainRoute) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *CrossChainRoute) GetSourceChain() string {
	if m != nil {
		return m.SourceChain
	}
	return ""
}

func (m *CrossChainRoute) GetDestinationChain() string {
	if m != nil {
		return m.DestinationChain
	}
	return ""
}

func (m *CrossChainRoute) GetProvider() v2.Provider {
	if m != nil {
		return m.Provider
	}
	return v2.Provider_IBC
}

func (m *CrossChainRoute) GetProviderConfig() *CrossChainProviderConfig {
	if m != nil {
		return m.ProviderConfig
	}
	return nil
}

func (m *CrossChainRoute) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *CrossChainRoute) GetRiskParams() *CrossChainRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// CrossChainProviderConfig defines provider-specific configuration
type CrossChainProviderConfig struct {
	// Types that are valid to be assigned to Config:
	//
	//	*CrossChainProviderConfig_IbcConfig
	//	*CrossChainProviderConfig_HyperlaneConfig
	Config isCrossChainProviderConfig_Config `protobuf_oneof:"config"`
}

func (m *CrossChainProviderConfig) Reset()         { *m = CrossChainProviderConfig{} }
func (m *CrossChainProviderConfig) String() string { return proto.CompactTextString(m) }
func (*CrossChainProviderConfig) ProtoMessage()    {}
func (*CrossChainProviderConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{1}
}
func (m *CrossChainProviderConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainProviderConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainProviderConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainProviderConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainProviderConfig.Merge(m, src)
}
func (m *CrossChainProviderConfig) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainProviderConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainProviderConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainProviderConfig proto.InternalMessageInfo

type isCrossChainProviderConfig_Config interface {
	isCrossChainProviderConfig_Config()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CrossChainProviderConfig_IbcConfig struct {
	IbcConfig *IBCConfig `protobuf:"bytes,1,opt,name=ibc_config,json=ibcConfig,proto3,oneof" json:"ibc_config,omitempty"`
}
type CrossChainProviderConfig_HyperlaneConfig struct {
	HyperlaneConfig *HyperlaneConfig `protobuf:"bytes,2,opt,name=hyperlane_config,json=hyperlaneConfig,proto3,oneof" json:"hyperlane_config,omitempty"`
}

func (*CrossChainProviderConfig_IbcConfig) isCrossChainProviderConfig_Config()       {}
func (*CrossChainProviderConfig_HyperlaneConfig) isCrossChainProviderConfig_Config() {}

func (m *CrossChainProviderConfig) GetConfig() isCrossChainProviderConfig_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *CrossChainProviderConfig) GetIbcConfig() *IBCConfig {
	if x, ok := m.GetConfig().(*CrossChainProviderConfig_IbcConfig); ok {
		return x.IbcConfig
	}
	return nil
}

func (m *CrossChainProviderConfig) GetHyperlaneConfig() *HyperlaneConfig {
	if x, ok := m.GetConfig().(*CrossChainProviderConfig_HyperlaneConfig); ok {
		return x.HyperlaneConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CrossChainProviderConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CrossChainProviderConfig_IbcConfig)(nil),
		(*CrossChainProviderConfig_HyperlaneConfig)(nil),
	}
}

// IBCConfig defines IBC-specific configuration
type IBCConfig struct {
	// IBC channel for communication
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	// IBC port (default: "transfer")
	PortId string `protobuf:"bytes,2,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	// Connection timeout in seconds
	TimeoutTimestamp uint64 `protobuf:"varint,3,opt,name=timeout_timestamp,json=timeoutTimestamp,proto3" json:"timeout_timestamp,omitempty"`
	// Packet timeout height
	TimeoutHeight uint64 `protobuf:"varint,4,opt,name=timeout_height,json=timeoutHeight,proto3" json:"timeout_height,omitempty"`
}

func (m *IBCConfig) Reset()         { *m = IBCConfig{} }
func (m *IBCConfig) String() string { return proto.CompactTextString(m) }
func (*IBCConfig) ProtoMessage()    {}
func (*IBCConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{2}
}
func (m *IBCConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IBCConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IBCConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IBCConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IBCConfig.Merge(m, src)
}
func (m *IBCConfig) XXX_Size() int {
	return m.Size()
}
func (m *IBCConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IBCConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IBCConfig proto.InternalMessageInfo

func (m *IBCConfig) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *IBCConfig) GetPortId() string {
	if m != nil {
		return m.PortId
	}
	return ""
}

func (m *IBCConfig) GetTimeoutTimestamp() uint64 {
	if m != nil {
		return m.TimeoutTimestamp
	}
	return 0
}

func (m *IBCConfig) GetTimeoutHeight() uint64 {
	if m != nil {
		return m.TimeoutHeight
	}
	return 0
}

// HyperlaneConfig defines Hyperlane-specific configuration
type HyperlaneConfig struct {
	// Hyperlane domain identifier
	DomainId uint32 `protobuf:"varint,1,opt,name=domain_id,json=domainId,proto3" json:"domain_id,omitempty"`
	// Mailbox contract address on remote chain
	MailboxAddress string `protobuf:"bytes,2,opt,name=mailbox_address,json=mailboxAddress,proto3" json:"mailbox_address,omitempty"`
	// Interchain gas paymaster address
	GasPaymasterAddress string `protobuf:"bytes,3,opt,name=gas_paymaster_address,json=gasPaymasterAddress,proto3" json:"gas_paymaster_address,omitempty"`
	// Hook contract address (optional)
	HookAddress string `protobuf:"bytes,4,opt,name=hook_address,json=hookAddress,proto3" json:"hook_address,omitempty"`
	// Gas limit for remote execution
	GasLimit uint64 `protobuf:"varint,5,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	// Gas price for remote execution
	GasPrice cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=gas_price,json=gasPrice,proto3,customtype=cosmossdk.io/math.Int" json:"gas_price"`
}

func (m *HyperlaneConfig) Reset()         { *m = HyperlaneConfig{} }
func (m *HyperlaneConfig) String() string { return proto.CompactTextString(m) }
func (*HyperlaneConfig) ProtoMessage()    {}
func (*HyperlaneConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{3}
}
func (m *HyperlaneConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HyperlaneConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HyperlaneConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HyperlaneConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HyperlaneConfig.Merge(m, src)
}
func (m *HyperlaneConfig) XXX_Size() int {
	return m.Size()
}
func (m *HyperlaneConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HyperlaneConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HyperlaneConfig proto.InternalMessageInfo

func (m *HyperlaneConfig) GetDomainId() uint32 {
	if m != nil {
		return m.DomainId
	}
	return 0
}

func (m *HyperlaneConfig) GetMailboxAddress() string {
	if m != nil {
		return m.MailboxAddress
	}
	return ""
}

func (m *HyperlaneConfig) GetGasPaymasterAddress() string {
	if m != nil {
		return m.GasPaymasterAddress
	}
	return ""
}

func (m *HyperlaneConfig) GetHookAddress() string {
	if m != nil {
		return m.HookAddress
	}
	return ""
}

func (m *HyperlaneConfig) GetGasLimit() uint64 {
	if m != nil {
		return m.GasLimit
	}
	return 0
}

// CrossChainRiskParams defines risk management parameters for cross-chain operations
type CrossChainRiskParams struct {
	// Haircut percentage applied to remote positions (basis points)
	PositionHaircut int32 `protobuf:"varint,1,opt,name=position_haircut,json=positionHaircut,proto3" json:"position_haircut,omitempty"`
	// Maximum drift allowed before position revaluation (basis points)
	MaxDriftThreshold int32 `protobuf:"varint,2,opt,name=max_drift_threshold,json=maxDriftThreshold,proto3" json:"max_drift_threshold,omitempty"`
	// Timeout for cross-chain operations (seconds)
	OperationTimeout int64 `protobuf:"varint,3,opt,name=operation_timeout,json=operationTimeout,proto3" json:"operation_timeout,omitempty"`
	// Maximum number of retries for failed operations
	MaxRetries int32 `protobuf:"varint,4,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
	// Conservative valuation discount (basis points)
	ConservativeDiscount int32 `protobuf:"varint,5,opt,name=conservative_discount,json=conservativeDiscount,proto3" json:"conservative_discount,omitempty"`
}

func (m *CrossChainRiskParams) Reset()         { *m = CrossChainRiskParams{} }
func (m *CrossChainRiskParams) String() string { return proto.CompactTextString(m) }
func (*CrossChainRiskParams) ProtoMessage()    {}
func (*CrossChainRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{4}
}
func (m *CrossChainRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainRiskParams.Merge(m, src)
}
func (m *CrossChainRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainRiskParams proto.InternalMessageInfo

func (m *CrossChainRiskParams) GetPositionHaircut() int32 {
	if m != nil {
		return m.PositionHaircut
	}
	return 0
}

func (m *CrossChainRiskParams) GetMaxDriftThreshold() int32 {
	if m != nil {
		return m.MaxDriftThreshold
	}
	return 0
}

func (m *CrossChainRiskParams) GetOperationTimeout() int64 {
	if m != nil {
		return m.OperationTimeout
	}
	return 0
}

func (m *CrossChainRiskParams) GetMaxRetries() int32 {
	if m != nil {
		return m.MaxRetries
	}
	return 0
}

func (m *CrossChainRiskParams) GetConservativeDiscount() int32 {
	if m != nil {
		return m.ConservativeDiscount
	}
	return 0
}

// RemotePosition represents a position on another chain
type RemotePosition struct {
	// Route used for this position
	RouteId string `protobuf:"bytes,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// User address on the remote chain
	RemoteAddress string `protobuf:"bytes,2,opt,name=remote_address,json=remoteAddress,proto3" json:"remote_address,omitempty"`
	// Local user address (Noble chain)
	LocalAddress []byte `protobuf:"bytes,3,opt,name=local_address,json=localAddress,proto3" json:"local_address,omitempty"`
	// Position value on remote chain
	RemoteValue cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=remote_value,json=remoteValue,proto3,customtype=cosmossdk.io/math.Int" json:"remote_value"`
	// Conservative valuation (with haircut applied)
	ConservativeValue cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=conservative_value,json=conservativeValue,proto3,customtype=cosmossdk.io/math.Int" json:"conservative_value"`
	// Last update timestamp
	LastUpdate time.Time `protobuf:"bytes,6,opt,name=last_update,json=lastUpdate,proto3,stdtime" json:"last_update"`
	// Current drift from expected value (basis points)
	CurrentDrift int32 `protobuf:"varint,7,opt,name=current_drift,json=currentDrift,proto3" json:"current_drift,omitempty"`
	// Position status
	Status RemotePositionStatus `protobuf:"varint,8,opt,name=status,proto3,enum=noble.dollar.vaults.v2.RemotePositionStatus" json:"status,omitempty"`
	// Shares allocated for this remote position
	AllocatedShares cosmossdk_io_math.Int `protobuf:"bytes,9,opt,name=allocated_shares,json=allocatedShares,proto3,customtype=cosmossdk.io/math.Int" json:"allocated_shares"`
	// Provider type for this position
	Provider v2.Provider `protobuf:"varint,10,opt,name=provider,proto3,enum=noble.dollar.v2.Provider" json:"provider,omitempty"`
	// Provider-specific tracking information
	ProviderTracking *ProviderTrackingInfo `protobuf:"bytes,11,opt,name=provider_tracking,json=providerTracking,proto3" json:"provider_tracking,omitempty"`
	// Number of confirmations received
	Confirmations uint64 `protobuf:"varint,12,opt,name=confirmations,proto3" json:"confirmations,omitempty"`
	// Required confirmations for finality
	RequiredConfirmations uint64 `protobuf:"varint,13,opt,name=required_confirmations,json=requiredConfirmations,proto3" json:"required_confirmations,omitempty"`
}

func (m *RemotePosition) Reset()         { *m = RemotePosition{} }
func (m *RemotePosition) String() string { return proto.CompactTextString(m) }
func (*RemotePosition) ProtoMessage()    {}
func (*RemotePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{5}
}
func (m *RemotePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemotePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemotePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemotePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemotePosition.Merge(m, src)
}
func (m *RemotePosition) XXX_Size() int {
	return m.Size()
}
func (m *RemotePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_RemotePosition.DiscardUnknown(m)
}

var xxx_messageInfo_RemotePosition proto.InternalMessageInfo

func (m *RemotePosition) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *RemotePosition) GetRemoteAddress() string {
	if m != nil {
		return m.RemoteAddress
	}
	return ""
}

func (m *RemotePosition) GetLocalAddress() []byte {
	if m != nil {
		return m.LocalAddress
	}
	return nil
}

func (m *RemotePosition) GetLastUpdate() time.Time {
	if m != nil {
		return m.LastUpdate
	}
	return time.Time{}
}

func (m *RemotePosition) GetCurrentDrift() int32 {
	if m != nil {
		return m.CurrentDrift
	}
	return 0
}

func (m *RemotePosition) GetStatus() RemotePositionStatus {
	if m != nil {
		return m.Status
	}
	return REMOTE_POSITION_ACTIVE
}

func (m *RemotePosition) GetProvider() v2.Provider {
	if m != nil {
		return m.Provider
	}
	return v2.Provider_IBC
}

func (m *RemotePosition) GetProviderTracking() *ProviderTrackingInfo {
	if m != nil {
		return m.ProviderTracking
	}
	return nil
}

func (m *RemotePosition) GetConfirmations() uint64 {
	if m != nil {
		return m.Confirmations
	}
	return 0
}

func (m *RemotePosition) GetRequiredConfirmations() uint64 {
	if m != nil {
		return m.RequiredConfirmations
	}
	return 0
}

// ProviderTrackingInfo contains provider-specific tracking data
type ProviderTrackingInfo struct {
	// Types that are valid to be assigned to TrackingInfo:
	//
	//	*ProviderTrackingInfo_IbcTracking
	//	*ProviderTrackingInfo_HyperlaneTracking
	TrackingInfo isProviderTrackingInfo_TrackingInfo `protobuf_oneof:"tracking_info"`
}

func (m *ProviderTrackingInfo) Reset()         { *m = ProviderTrackingInfo{} }
func (m *ProviderTrackingInfo) String() string { return proto.CompactTextString(m) }
func (*ProviderTrackingInfo) ProtoMessage()    {}
func (*ProviderTrackingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{6}
}
func (m *ProviderTrackingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderTrackingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderTrackingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderTrackingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderTrackingInfo.Merge(m, src)
}
func (m *ProviderTrackingInfo) XXX_Size() int {
	return m.Size()
}
func (m *ProviderTrackingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderTrackingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderTrackingInfo proto.InternalMessageInfo

type isProviderTrackingInfo_TrackingInfo interface {
	isProviderTrackingInfo_TrackingInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProviderTrackingInfo_IbcTracking struct {
	IbcTracking *IBCTrackingInfo `protobuf:"bytes,1,opt,name=ibc_tracking,json=ibcTracking,proto3,oneof" json:"ibc_tracking,omitempty"`
}
type ProviderTrackingInfo_HyperlaneTracking struct {
	HyperlaneTracking *HyperlaneTrackingInfo `protobuf:"bytes,2,opt,name=hyperlane_tracking,json=hyperlaneTracking,proto3,oneof" json:"hyperlane_tracking,omitempty"`
}

func (*ProviderTrackingInfo_IbcTracking) isProviderTrackingInfo_TrackingInfo()       {}
func (*ProviderTrackingInfo_HyperlaneTracking) isProviderTrackingInfo_TrackingInfo() {}

func (m *ProviderTrackingInfo) GetTrackingInfo() isProviderTrackingInfo_TrackingInfo {
	if m != nil {
		return m.TrackingInfo
	}
	return nil
}

func (m *ProviderTrackingInfo) GetIbcTracking() *IBCTrackingInfo {
	if x, ok := m.GetTrackingInfo().(*ProviderTrackingInfo_IbcTracking); ok {
		return x.IbcTracking
	}
	return nil
}

func (m *ProviderTrackingInfo) GetHyperlaneTracking() *HyperlaneTrackingInfo {
	if x, ok := m.GetTrackingInfo().(*ProviderTrackingInfo_HyperlaneTracking); ok {
		return x.HyperlaneTracking
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProviderTrackingInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProviderTrackingInfo_IbcTracking)(nil),
		(*ProviderTrackingInfo_HyperlaneTracking)(nil),
	}
}

// IBCTrackingInfo contains IBC-specific tracking data
type IBCTrackingInfo struct {
	// IBC packet sequence number
	Sequence uint64 `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// Source channel ID
	SourceChannel string `protobuf:"bytes,2,opt,name=source_channel,json=sourceChannel,proto3" json:"source_channel,omitempty"`
	// Source port ID
	SourcePort string `protobuf:"bytes,3,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	// Destination channel ID
	DestinationChannel string `protobuf:"bytes,4,opt,name=destination_channel,json=destinationChannel,proto3" json:"destination_channel,omitempty"`
	// Destination port ID
	DestinationPort string `protobuf:"bytes,5,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
	// Packet timeout timestamp
	TimeoutTimestamp uint64 `protobuf:"varint,6,opt,name=timeout_timestamp,json=timeoutTimestamp,proto3" json:"timeout_timestamp,omitempty"`
	// Packet timeout height
	TimeoutHeight uint64 `protobuf:"varint,7,opt,name=timeout_height,json=timeoutHeight,proto3" json:"timeout_height,omitempty"`
	// Acknowledgment received
	AckReceived bool `protobuf:"varint,8,opt,name=ack_received,json=ackReceived,proto3" json:"ack_received,omitempty"`
	// Acknowledgment data
	AckData []byte `protobuf:"bytes,9,opt,name=ack_data,json=ackData,proto3" json:"ack_data,omitempty"`
}

func (m *IBCTrackingInfo) Reset()         { *m = IBCTrackingInfo{} }
func (m *IBCTrackingInfo) String() string { return proto.CompactTextString(m) }
func (*IBCTrackingInfo) ProtoMessage()    {}
func (*IBCTrackingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{7}
}
func (m *IBCTrackingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IBCTrackingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IBCTrackingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IBCTrackingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IBCTrackingInfo.Merge(m, src)
}
func (m *IBCTrackingInfo) XXX_Size() int {
	return m.Size()
}
func (m *IBCTrackingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IBCTrackingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IBCTrackingInfo proto.InternalMessageInfo

func (m *IBCTrackingInfo) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *IBCTrackingInfo) GetSourceChannel() string {
	if m != nil {
		return m.SourceChannel
	}
	return ""
}

func (m *IBCTrackingInfo) GetSourcePort() string {
	if m != nil {
		return m.SourcePort
	}
	return ""
}

func (m *IBCTrackingInfo) GetDestinationChannel() string {
	if m != nil {
		return m.DestinationChannel
	}
	return ""
}

func (m *IBCTrackingInfo) GetDestinationPort() string {
	if m != nil {
		return m.DestinationPort
	}
	return ""
}

func (m *IBCTrackingInfo) GetTimeoutTimestamp() uint64 {
	if m != nil {
		return m.TimeoutTimestamp
	}
	return 0
}

func (m *IBCTrackingInfo) GetTimeoutHeight() uint64 {
	if m != nil {
		return m.TimeoutHeight
	}
	return 0
}

func (m *IBCTrackingInfo) GetAckReceived() bool {
	if m != nil {
		return m.AckReceived
	}
	return false
}

func (m *IBCTrackingInfo) GetAckData() []byte {
	if m != nil {
		return m.AckData
	}
	return nil
}

// HyperlaneTrackingInfo contains Hyperlane-specific tracking data
type HyperlaneTrackingInfo struct {
	// Hyperlane message ID
	MessageId []byte `protobuf:"bytes,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Origin domain
	OriginDomain uint32 `protobuf:"varint,2,opt,name=origin_domain,json=originDomain,proto3" json:"origin_domain,omitempty"`
	// Destination domain
	DestinationDomain uint32 `protobuf:"varint,3,opt,name=destination_domain,json=destinationDomain,proto3" json:"destination_domain,omitempty"`
	// Message nonce
	Nonce uint64 `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Transaction hash on origin chain
	OriginTxHash string `protobuf:"bytes,5,opt,name=origin_tx_hash,json=originTxHash,proto3" json:"origin_tx_hash,omitempty"`
	// Transaction hash on destination chain
	DestinationTxHash string `protobuf:"bytes,6,opt,name=destination_tx_hash,json=destinationTxHash,proto3" json:"destination_tx_hash,omitempty"`
	// Block number on origin chain
	OriginBlockNumber uint64 `protobuf:"varint,7,opt,name=origin_block_number,json=originBlockNumber,proto3" json:"origin_block_number,omitempty"`
	// Block number on destination chain
	DestinationBlockNumber uint64 `protobuf:"varint,8,opt,name=destination_block_number,json=destinationBlockNumber,proto3" json:"destination_block_number,omitempty"`
	// Whether message has been processed
	Processed bool `protobuf:"varint,9,opt,name=processed,proto3" json:"processed,omitempty"`
	// Gas used for execution
	GasUsed uint64 `protobuf:"varint,10,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
}

func (m *HyperlaneTrackingInfo) Reset()         { *m = HyperlaneTrackingInfo{} }
func (m *HyperlaneTrackingInfo) String() string { return proto.CompactTextString(m) }
func (*HyperlaneTrackingInfo) ProtoMessage()    {}
func (*HyperlaneTrackingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{8}
}
func (m *HyperlaneTrackingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HyperlaneTrackingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HyperlaneTrackingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HyperlaneTrackingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HyperlaneTrackingInfo.Merge(m, src)
}
func (m *HyperlaneTrackingInfo) XXX_Size() int {
	return m.Size()
}
func (m *HyperlaneTrackingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HyperlaneTrackingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HyperlaneTrackingInfo proto.InternalMessageInfo

func (m *HyperlaneTrackingInfo) GetMessageId() []byte {
	if m != nil {
		return m.MessageId
	}
	return nil
}

func (m *HyperlaneTrackingInfo) GetOriginDomain() uint32 {
	if m != nil {
		return m.OriginDomain
	}
	return 0
}

func (m *HyperlaneTrackingInfo) GetDestinationDomain() uint32 {
	if m != nil {
		return m.DestinationDomain
	}
	return 0
}

func (m *HyperlaneTrackingInfo) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *HyperlaneTrackingInfo) GetOriginTxHash() string {
	if m != nil {
		return m.OriginTxHash
	}
	return ""
}

func (m *HyperlaneTrackingInfo) GetDestinationTxHash() string {
	if m != nil {
		return m.DestinationTxHash
	}
	return ""
}

func (m *HyperlaneTrackingInfo) GetOriginBlockNumber() uint64 {
	if m != nil {
		return m.OriginBlockNumber
	}
	return 0
}

func (m *HyperlaneTrackingInfo) GetDestinationBlockNumber() uint64 {
	if m != nil {
		return m.DestinationBlockNumber
	}
	return 0
}

func (m *HyperlaneTrackingInfo) GetProcessed() bool {
	if m != nil {
		return m.Processed
	}
	return false
}

func (m *HyperlaneTrackingInfo) GetGasUsed() uint64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

// InFlightPosition represents a position operation in progress
type InFlightPosition struct {
	// Unique nonce for this operation
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Route being used
	RouteId string `protobuf:"bytes,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Local user address
	UserAddress []byte `protobuf:"bytes,3,opt,name=user_address,json=userAddress,proto3" json:"user_address,omitempty"`
	// Operation type
	OperationType InFlightOperationType `protobuf:"varint,4,opt,name=operation_type,json=operationType,proto3,enum=noble.dollar.vaults.v2.InFlightOperationType" json:"operation_type,omitempty"`
	// Amount involved in the operation
	Amount cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// Shares involved (for withdrawals)
	Shares cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=shares,proto3,customtype=cosmossdk.io/math.Int" json:"shares"`
	// Operation initiated timestamp
	InitiatedAt time.Time `protobuf:"bytes,7,opt,name=initiated_at,json=initiatedAt,proto3,stdtime" json:"initiated_at"`
	// Expected completion timestamp
	ExpectedCompletion time.Time `protobuf:"bytes,8,opt,name=expected_completion,json=expectedCompletion,proto3,stdtime" json:"expected_completion"`
	// Current retry count
	RetryCount int32 `protobuf:"varint,9,opt,name=retry_count,json=retryCount,proto3" json:"retry_count,omitempty"`
	// Operation status
	Status InFlightStatus `protobuf:"varint,10,opt,name=status,proto3,enum=noble.dollar.vaults.v2.InFlightStatus" json:"status,omitempty"`
	// Error message if operation failed
	ErrorMessage string `protobuf:"bytes,11,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Provider type for this operation
	Provider v2.Provider `protobuf:"varint,12,opt,name=provider,proto3,enum=noble.dollar.v2.Provider" json:"provider,omitempty"`
	// Provider-specific tracking information
	ProviderTracking *ProviderTrackingInfo `protobuf:"bytes,13,opt,name=provider_tracking,json=providerTracking,proto3" json:"provider_tracking,omitempty"`
	// Number of confirmations received
	Confirmations uint64 `protobuf:"varint,14,opt,name=confirmations,proto3" json:"confirmations,omitempty"`
	// Required confirmations for completion
	RequiredConfirmations uint64 `protobuf:"varint,15,opt,name=required_confirmations,json=requiredConfirmations,proto3" json:"required_confirmations,omitempty"`
}

func (m *InFlightPosition) Reset()         { *m = InFlightPosition{} }
func (m *InFlightPosition) String() string { return proto.CompactTextString(m) }
func (*InFlightPosition) ProtoMessage()    {}
func (*InFlightPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{9}
}
func (m *InFlightPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InFlightPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InFlightPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InFlightPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InFlightPosition.Merge(m, src)
}
func (m *InFlightPosition) XXX_Size() int {
	return m.Size()
}
func (m *InFlightPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_InFlightPosition.DiscardUnknown(m)
}

var xxx_messageInfo_InFlightPosition proto.InternalMessageInfo

func (m *InFlightPosition) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *InFlightPosition) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *InFlightPosition) GetUserAddress() []byte {
	if m != nil {
		return m.UserAddress
	}
	return nil
}

func (m *InFlightPosition) GetOperationType() InFlightOperationType {
	if m != nil {
		return m.OperationType
	}
	return OPERATION_REMOTE_DEPOSIT
}

func (m *InFlightPosition) GetInitiatedAt() time.Time {
	if m != nil {
		return m.InitiatedAt
	}
	return time.Time{}
}

func (m *InFlightPosition) GetExpectedCompletion() time.Time {
	if m != nil {
		return m.ExpectedCompletion
	}
	return time.Time{}
}

func (m *InFlightPosition) GetRetryCount() int32 {
	if m != nil {
		return m.RetryCount
	}
	return 0
}

func (m *InFlightPosition) GetStatus() InFlightStatus {
	if m != nil {
		return m.Status
	}
	return INFLIGHT_PENDING
}

func (m *InFlightPosition) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *InFlightPosition) GetProvider() v2.Provider {
	if m != nil {
		return m.Provider
	}
	return v2.Provider_IBC
}

func (m *InFlightPosition) GetProviderTracking() *ProviderTrackingInfo {
	if m != nil {
		return m.ProviderTracking
	}
	return nil
}

func (m *InFlightPosition) GetConfirmations() uint64 {
	if m != nil {
		return m.Confirmations
	}
	return 0
}

func (m *InFlightPosition) GetRequiredConfirmations() uint64 {
	if m != nil {
		return m.RequiredConfirmations
	}
	return 0
}

// CrossChainPositionSnapshot provides a snapshot of all cross-chain positions
type CrossChainPositionSnapshot struct {
	// Total remote value (sum of all remote positions)
	TotalRemoteValue cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_remote_value,json=totalRemoteValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_remote_value"`
	// Total conservative value (with haircuts applied)
	TotalConservativeValue cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_conservative_value,json=totalConservativeValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_conservative_value"`
	// Number of active remote positions
	ActivePositions int64 `protobuf:"varint,3,opt,name=active_positions,json=activePositions,proto3" json:"active_positions,omitempty"`
	// Number of positions with drift issues
	DriftExceededPositions int64 `protobuf:"varint,4,opt,name=drift_exceeded_positions,json=driftExceededPositions,proto3" json:"drift_exceeded_positions,omitempty"`
	// Snapshot timestamp
	Timestamp time.Time `protobuf:"bytes,5,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Total shares allocated to remote positions
	TotalRemoteShares cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=total_remote_shares,json=totalRemoteShares,proto3,customtype=cosmossdk.io/math.Int" json:"total_remote_shares"`
}

func (m *CrossChainPositionSnapshot) Reset()         { *m = CrossChainPositionSnapshot{} }
func (m *CrossChainPositionSnapshot) String() string { return proto.CompactTextString(m) }
func (*CrossChainPositionSnapshot) ProtoMessage()    {}
func (*CrossChainPositionSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{10}
}
func (m *CrossChainPositionSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainPositionSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainPositionSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainPositionSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainPositionSnapshot.Merge(m, src)
}
func (m *CrossChainPositionSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainPositionSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainPositionSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainPositionSnapshot proto.InternalMessageInfo

func (m *CrossChainPositionSnapshot) GetActivePositions() int64 {
	if m != nil {
		return m.ActivePositions
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetDriftExceededPositions() int64 {
	if m != nil {
		return m.DriftExceededPositions
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

// DriftAlert represents an alert when a position exceeds drift limits
type DriftAlert struct {
	// Position route ID
	RouteId string `protobuf:"bytes,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// User address
	UserAddress []byte `protobuf:"bytes,2,opt,name=user_address,json=userAddress,proto3" json:"user_address,omitempty"`
	// Current drift percentage (basis points)
	CurrentDrift int32 `protobuf:"varint,3,opt,name=current_drift,json=currentDrift,proto3" json:"current_drift,omitempty"`
	// Threshold that was exceeded (basis points)
	ThresholdExceeded int32 `protobuf:"varint,4,opt,name=threshold_exceeded,json=thresholdExceeded,proto3" json:"threshold_exceeded,omitempty"`
	// Alert timestamp
	Timestamp time.Time `protobuf:"bytes,5,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Recommended action
	RecommendedAction string `protobuf:"bytes,6,opt,name=recommended_action,json=recommendedAction,proto3" json:"recommended_action,omitempty"`
}

func (m *DriftAlert) Reset()         { *m = DriftAlert{} }
func (m *DriftAlert) String() string { return proto.CompactTextString(m) }
func (*DriftAlert) ProtoMessage()    {}
func (*DriftAlert) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{11}
}
func (m *DriftAlert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DriftAlert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DriftAlert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DriftAlert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DriftAlert.Merge(m, src)
}
func (m *DriftAlert) XXX_Size() int {
	return m.Size()
}
func (m *DriftAlert) XXX_DiscardUnknown() {
	xxx_messageInfo_DriftAlert.DiscardUnknown(m)
}

var xxx_messageInfo_DriftAlert proto.InternalMessageInfo

func (m *DriftAlert) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *DriftAlert) GetUserAddress() []byte {
	if m != nil {
		return m.UserAddress
	}
	return nil
}

func (m *DriftAlert) GetCurrentDrift() int32 {
	if m != nil {
		return m.CurrentDrift
	}
	return 0
}

func (m *DriftAlert) GetThresholdExceeded() int32 {
	if m != nil {
		return m.ThresholdExceeded
	}
	return 0
}

func (m *DriftAlert) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *DriftAlert) GetRecommendedAction() string {
	if m != nil {
		return m.RecommendedAction
	}
	return ""
}

// CrossChainConfig defines global configuration for cross-chain operations
type CrossChainConfig struct {
	// Global position haircut (basis points)
	GlobalHaircut int32 `protobuf:"varint,1,opt,name=global_haircut,json=globalHaircut,proto3" json:"global_haircut,omitempty"`
	// Maximum total remote position value as percentage of vault (basis points)
	MaxRemoteExposure int32 `protobuf:"varint,2,opt,name=max_remote_exposure,json=maxRemoteExposure,proto3" json:"max_remote_exposure,omitempty"`
	// Default operation timeout (seconds)
	DefaultTimeout int64 `protobuf:"varint,3,opt,name=default_timeout,json=defaultTimeout,proto3" json:"default_timeout,omitempty"`
	// Position update frequency (seconds)
	UpdateFrequency int64 `protobuf:"varint,4,opt,name=update_frequency,json=updateFrequency,proto3" json:"update_frequency,omitempty"`
	// Emergency liquidation threshold (basis points)
	EmergencyLiquidationThreshold int32 `protobuf:"varint,5,opt,name=emergency_liquidation_threshold,json=emergencyLiquidationThreshold,proto3" json:"emergency_liquidation_threshold,omitempty"`
	// Whether cross-chain operations are enabled
	Enabled bool `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *CrossChainConfig) Reset()         { *m = CrossChainConfig{} }
func (m *CrossChainConfig) String() string { return proto.CompactTextString(m) }
func (*CrossChainConfig) ProtoMessage()    {}
func (*CrossChainConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{12}
}
func (m *CrossChainConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainConfig.Merge(m, src)
}
func (m *CrossChainConfig) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainConfig proto.InternalMessageInfo

func (m *CrossChainConfig) GetGlobalHaircut() int32 {
	if m != nil {
		return m.GlobalHaircut
	}
	return 0
}

func (m *CrossChainConfig) GetMaxRemoteExposure() int32 {
	if m != nil {
		return m.MaxRemoteExposure
	}
	return 0
}

func (m *CrossChainConfig) GetDefaultTimeout() int64 {
	if m != nil {
		return m.DefaultTimeout
	}
	return 0
}

func (m *CrossChainConfig) GetUpdateFrequency() int64 {
	if m != nil {
		return m.UpdateFrequency
	}
	return 0
}

func (m *CrossChainConfig) GetEmergencyLiquidationThreshold() int32 {
	if m != nil {
		return m.EmergencyLiquidationThreshold
	}
	return 0
}

func (m *CrossChainConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func init() {
	proto.RegisterEnum("noble.dollar.vaults.v2.RemotePositionStatus", RemotePositionStatus_name, RemotePositionStatus_value)
	proto.RegisterEnum("noble.dollar.vaults.v2.InFlightOperationType", InFlightOperationType_name, InFlightOperationType_value)
	proto.RegisterEnum("noble.dollar.vaults.v2.InFlightStatus", InFlightStatus_name, InFlightStatus_value)
	proto.RegisterType((*CrossChainRoute)(nil), "noble.dollar.vaults.v2.CrossChainRoute")
	proto.RegisterType((*CrossChainProviderConfig)(nil), "noble.dollar.vaults.v2.CrossChainProviderConfig")
	proto.RegisterType((*IBCConfig)(nil), "noble.dollar.vaults.v2.IBCConfig")
	proto.RegisterType((*HyperlaneConfig)(nil), "noble.dollar.vaults.v2.HyperlaneConfig")
	proto.RegisterType((*CrossChainRiskParams)(nil), "noble.dollar.vaults.v2.CrossChainRiskParams")
	proto.RegisterType((*RemotePosition)(nil), "noble.dollar.vaults.v2.RemotePosition")
	proto.RegisterType((*ProviderTrackingInfo)(nil), "noble.dollar.vaults.v2.ProviderTrackingInfo")
	proto.RegisterType((*IBCTrackingInfo)(nil), "noble.dollar.vaults.v2.IBCTrackingInfo")
	proto.RegisterType((*HyperlaneTrackingInfo)(nil), "noble.dollar.vaults.v2.HyperlaneTrackingInfo")
	proto.RegisterType((*InFlightPosition)(nil), "noble.dollar.vaults.v2.InFlightPosition")
	proto.RegisterType((*CrossChainPositionSnapshot)(nil), "noble.dollar.vaults.v2.CrossChainPositionSnapshot")
	proto.RegisterType((*DriftAlert)(nil), "noble.dollar.vaults.v2.DriftAlert")
	proto.RegisterType((*CrossChainConfig)(nil), "noble.dollar.vaults.v2.CrossChainConfig")
}

func init() {
	proto.RegisterFile("noble/dollar/vaults/v2/cross_chain.proto", fileDescriptor_4abec74535b2c22a)
}

var fileDescriptor_4abec74535b2c22a = []byte{
	// 2185 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x49, 0x6f, 0x1b, 0xc9,
	0x15, 0x56, 0x6b, 0x25, 0x1f, 0xb7, 0x56, 0x69, 0x19, 0x5a, 0xb6, 0x25, 0x9b, 0x1e, 0x67, 0x6c,
	0x27, 0x26, 0x07, 0x1a, 0x0c, 0x90, 0x4b, 0x02, 0x50, 0x64, 0xcb, 0x6a, 0x40, 0x5b, 0x4a, 0xd4,
	0x4c, 0x16, 0x60, 0x3a, 0xa5, 0xee, 0x12, 0xd9, 0x51, 0x77, 0x17, 0xdd, 0xdd, 0x14, 0xa8, 0xfc,
	0x82, 0x1c, 0x72, 0x98, 0x9c, 0x82, 0xe4, 0x92, 0x00, 0xb9, 0x04, 0xc8, 0x25, 0x87, 0x9c, 0x73,
	0x9e, 0xe3, 0x20, 0xc0, 0x00, 0x83, 0x1c, 0x26, 0x81, 0x8d, 0x20, 0x3f, 0x20, 0xf9, 0x01, 0x41,
	0x2d, 0xdd, 0x6c, 0xd2, 0xf4, 0xa6, 0xc9, 0x5c, 0x04, 0xd6, 0x5b, 0xbe, 0xae, 0x7a, 0x55, 0xef,
	0x7d, 0xef, 0x09, 0x1e, 0x04, 0xec, 0xcc, 0xa3, 0x0d, 0x87, 0x79, 0x1e, 0x09, 0x1b, 0x97, 0x64,
	0xe0, 0xc5, 0x51, 0xe3, 0x72, 0xbb, 0x61, 0x87, 0x2c, 0x8a, 0x2c, 0xbb, 0x47, 0xdc, 0xa0, 0xde,
	0x0f, 0x59, 0xcc, 0xd0, 0xba, 0xb0, 0xac, 0x4b, 0xcb, 0xba, 0xb4, 0xac, 0x5f, 0x6e, 0x6f, 0x2c,
	0x13, 0xdf, 0x0d, 0x58, 0x43, 0xfc, 0x95, 0xa6, 0x1b, 0x37, 0x6c, 0x16, 0xf9, 0x2c, 0xb2, 0xc4,
	0xaa, 0x21, 0x17, 0x4a, 0xb5, 0xda, 0x65, 0x5d, 0x26, 0xe5, 0xfc, 0x97, 0x92, 0x6e, 0x75, 0x19,
	0xeb, 0x7a, 0xb4, 0x21, 0x56, 0x67, 0x83, 0xf3, 0x46, 0xec, 0xfa, 0x34, 0x8a, 0x89, 0xdf, 0x57,
	0x06, 0xb7, 0xc6, 0xb7, 0xb9, 0xad, 0x7e, 0x49, 0x6d, 0xed, 0x8b, 0x39, 0xa8, 0xb4, 0xf8, 0x86,
	0x5b, 0x7c, 0xbf, 0x98, 0x0d, 0x62, 0x8a, 0x6e, 0x40, 0x2e, 0xe4, 0x3f, 0x2c, 0xd7, 0xa9, 0x6a,
	0x77, 0xb4, 0x07, 0x79, 0xbc, 0x24, 0xd6, 0xa6, 0x83, 0xee, 0x42, 0x31, 0x62, 0x83, 0xd0, 0xa6,
	0xf2, 0x7c, 0xd5, 0x59, 0xa1, 0x2e, 0x48, 0x99, 0x80, 0x40, 0xdf, 0x86, 0x65, 0x87, 0x46, 0xb1,
	0x1b, 0x90, 0xd8, 0x65, 0x81, 0xb2, 0x9b, 0x13, 0x76, 0x7a, 0x46, 0x21, 0x8d, 0x3f, 0x84, 0x5c,
	0x3f, 0x64, 0x97, 0xae, 0x43, 0xc3, 0xea, 0xfc, 0x1d, 0xed, 0x41, 0x79, 0xfb, 0x46, 0x7d, 0x3c,
	0x58, 0xdb, 0xf5, 0x63, 0x65, 0x80, 0x53, 0x53, 0xf4, 0x23, 0xa8, 0x24, 0xbf, 0x2d, 0x9b, 0x05,
	0xe7, 0x6e, 0xb7, 0xba, 0x70, 0x47, 0x7b, 0x50, 0xd8, 0x7e, 0xbf, 0x3e, 0x3d, 0xd4, 0xf5, 0xd1,
	0x19, 0x13, 0xb8, 0x96, 0xf0, 0xc3, 0xe5, 0xfe, 0xd8, 0x1a, 0xad, 0xc3, 0x22, 0xb1, 0x63, 0xf7,
	0x92, 0x56, 0x17, 0xef, 0x68, 0x0f, 0x72, 0x58, 0xad, 0xd0, 0x27, 0x80, 0x7c, 0x32, 0xb4, 0xfa,
	0x2c, 0x72, 0xc5, 0xb9, 0x2e, 0x89, 0x37, 0xa0, 0xd5, 0x25, 0x7e, 0xae, 0x9d, 0xf7, 0x3f, 0xfb,
	0x6a, 0x6b, 0xe6, 0xef, 0x5f, 0x6d, 0xad, 0xc9, 0xfb, 0x8a, 0x9c, 0x8b, 0xba, 0xcb, 0x1a, 0x3e,
	0x89, 0x7b, 0x75, 0x33, 0x88, 0xff, 0xf6, 0x97, 0xc7, 0xa0, 0x2e, 0xd2, 0x0c, 0xe2, 0x3f, 0xfe,
	0xfb, 0xcf, 0x8f, 0x34, 0xac, 0xfb, 0x64, 0x78, 0xac, 0xa0, 0x3e, 0xe2, 0x48, 0xe8, 0x00, 0x0a,
	0xa1, 0x1b, 0x5d, 0x58, 0x7d, 0x12, 0x12, 0x3f, 0xaa, 0xe6, 0xc4, 0x71, 0xbe, 0xf3, 0xfa, 0xe3,
	0x60, 0x37, 0xba, 0x38, 0x16, 0x3e, 0x18, 0xc2, 0xf4, 0x77, 0xed, 0xaf, 0x1a, 0x54, 0x5f, 0x76,
	0x66, 0xb4, 0x03, 0xe0, 0x9e, 0xd9, 0x49, 0xe4, 0x34, 0xf1, 0xa9, 0xbb, 0x2f, 0xfb, 0x94, 0xb9,
	0xd3, 0x92, 0x6e, 0x7b, 0x33, 0x38, 0xef, 0x9e, 0xd9, 0x0a, 0xa3, 0x03, 0x7a, 0xef, 0xaa, 0x4f,
	0x43, 0x8f, 0x04, 0x34, 0x41, 0x9a, 0x15, 0x48, 0xef, 0xbd, 0x0c, 0x69, 0x2f, 0xb1, 0x4f, 0xf1,
	0x2a, 0xbd, 0x71, 0xd1, 0x4e, 0x0e, 0x16, 0x25, 0x56, 0xed, 0xd7, 0x1a, 0xe4, 0xd3, 0x4f, 0xa3,
	0xdb, 0x00, 0x76, 0x8f, 0x04, 0x01, 0xf5, 0x46, 0x8f, 0x32, 0xaf, 0x24, 0xa6, 0x83, 0xde, 0x81,
	0xa5, 0x3e, 0x0b, 0x63, 0xae, 0x93, 0x2f, 0x72, 0x91, 0x2f, 0x4d, 0x87, 0x3f, 0x46, 0x9e, 0x0f,
	0x6c, 0x10, 0x5b, 0x69, 0x5e, 0x88, 0xc7, 0x38, 0x8f, 0x75, 0xa5, 0xe8, 0x24, 0x72, 0x74, 0x1f,
	0xca, 0x89, 0x71, 0x8f, 0xba, 0xdd, 0x5e, 0x2c, 0x9e, 0xe4, 0x3c, 0x2e, 0x29, 0xe9, 0x9e, 0x10,
	0xd6, 0x7e, 0x3b, 0x0b, 0x95, 0x89, 0xa3, 0xa0, 0x9b, 0x90, 0x77, 0x98, 0x4f, 0xdc, 0x20, 0xd9,
	0x5e, 0x09, 0xe7, 0xa4, 0xc0, 0x74, 0xd0, 0x7b, 0x50, 0xf1, 0x89, 0xeb, 0x9d, 0xb1, 0xa1, 0x45,
	0x1c, 0x27, 0xa4, 0x51, 0xa4, 0x76, 0x59, 0x56, 0xe2, 0xa6, 0x94, 0xa2, 0x6d, 0x58, 0xeb, 0x92,
	0xc8, 0xea, 0x93, 0x2b, 0x9f, 0x44, 0x31, 0x0d, 0x53, 0x73, 0x99, 0x3e, 0x2b, 0x5d, 0x12, 0x1d,
	0x27, 0xba, 0xc4, 0xe7, 0x2e, 0x14, 0x7b, 0x8c, 0x5d, 0xa4, 0xa6, 0xf3, 0x32, 0x23, 0xb9, 0x2c,
	0x31, 0xb9, 0x09, 0x79, 0x0e, 0xeb, 0xb9, 0xbe, 0x1b, 0x8b, 0x3c, 0x99, 0xc7, 0xb9, 0x2e, 0x89,
	0xf6, 0xf9, 0x1a, 0x1d, 0x48, 0x65, 0x3f, 0x74, 0x6d, 0xf9, 0xe4, 0xaf, 0xf3, 0x9c, 0x39, 0xdc,
	0x31, 0x47, 0xa8, 0xfd, 0x57, 0x83, 0xd5, 0x69, 0x8f, 0x13, 0x3d, 0x04, 0x3d, 0xcd, 0x9d, 0x1e,
	0x71, 0x43, 0x7b, 0x10, 0x8b, 0x40, 0x2d, 0xe0, 0x4a, 0x22, 0xdf, 0x93, 0x62, 0x54, 0x87, 0x15,
	0x9e, 0x6a, 0x4e, 0xe8, 0x9e, 0xc7, 0x56, 0xdc, 0x0b, 0x69, 0xd4, 0x63, 0x9e, 0xbc, 0xd9, 0x05,
	0xbc, 0xec, 0x93, 0x61, 0x9b, 0x6b, 0x3a, 0x89, 0x82, 0x5f, 0x32, 0xeb, 0xd3, 0x50, 0xd6, 0x1b,
	0x75, 0x57, 0x22, 0x64, 0x73, 0x58, 0x4f, 0x15, 0x1d, 0x29, 0x47, 0x5b, 0x50, 0xe0, 0xe0, 0x21,
	0x8d, 0x43, 0x97, 0xca, 0x70, 0x2d, 0x60, 0xf0, 0xc9, 0x10, 0x4b, 0x09, 0xfa, 0x00, 0xd6, 0x6c,
	0x16, 0x44, 0x34, 0xbc, 0x24, 0x3c, 0xf1, 0x2d, 0xc7, 0x8d, 0x6c, 0x36, 0x08, 0x64, 0xe4, 0x16,
	0xf0, 0x6a, 0x56, 0xd9, 0x56, 0xba, 0xda, 0x9f, 0x16, 0xa1, 0x8c, 0xa9, 0xcf, 0x62, 0x9a, 0x64,
	0xf5, 0xab, 0xaa, 0xe8, 0x7d, 0x28, 0x87, 0xc2, 0x78, 0xe2, 0x3d, 0x94, 0xa4, 0x34, 0xb9, 0xb7,
	0x7b, 0x50, 0xf2, 0x98, 0x4d, 0xbc, 0xb1, 0x67, 0x50, 0xc4, 0x45, 0x21, 0x4c, 0x8c, 0x4e, 0xa0,
	0xa8, 0xb0, 0x64, 0x45, 0x9a, 0xbf, 0xe6, 0x15, 0x16, 0x24, 0x8a, 0x2c, 0x46, 0x16, 0xa0, 0xb1,
	0x18, 0x48, 0xe8, 0x85, 0x6b, 0x42, 0x2f, 0x67, 0xb1, 0xe4, 0x07, 0x0c, 0x28, 0x78, 0x24, 0x8a,
	0xad, 0x41, 0xdf, 0x21, 0xb1, 0x7c, 0x77, 0x85, 0xed, 0x8d, 0xba, 0xe4, 0xb2, 0x7a, 0xc2, 0x65,
	0xf5, 0x34, 0x37, 0x77, 0x72, 0xfc, 0xab, 0x9f, 0xfe, 0x63, 0x4b, 0xc3, 0xc0, 0x1d, 0x4f, 0x85,
	0x1f, 0x8f, 0x90, 0x3d, 0x08, 0x43, 0x1a, 0xc4, 0xf2, 0xb5, 0x88, 0x7a, 0xbc, 0x80, 0x8b, 0x4a,
	0x28, 0xde, 0x09, 0x6a, 0xc3, 0x62, 0x14, 0x93, 0x78, 0x20, 0x8b, 0x6a, 0xf9, 0xe5, 0x45, 0x75,
	0xfc, 0x02, 0x4f, 0x84, 0x0f, 0x56, 0xbe, 0xe8, 0x27, 0xa0, 0x13, 0x8f, 0x47, 0x3e, 0xa6, 0x8e,
	0x15, 0xf5, 0x48, 0x48, 0xa3, 0x6a, 0xfe, 0x9a, 0x01, 0xa9, 0xa4, 0x48, 0x27, 0x02, 0x68, 0x8c,
	0x06, 0xe1, 0x6d, 0x68, 0x70, 0x39, 0xa5, 0xc1, 0x38, 0x24, 0xf6, 0x85, 0x1b, 0x74, 0xab, 0x85,
	0x57, 0x33, 0x47, 0x02, 0xd3, 0x51, 0xf6, 0x66, 0x70, 0xce, 0xb0, 0xde, 0x9f, 0x90, 0xa2, 0x77,
	0xa1, 0x24, 0x0a, 0x71, 0xe8, 0x8b, 0xec, 0x89, 0xaa, 0x45, 0x59, 0x0a, 0xc7, 0x84, 0xe8, 0x43,
	0x58, 0x0f, 0xe9, 0xd3, 0x81, 0x1b, 0x52, 0xc7, 0x1a, 0x37, 0x2f, 0x09, 0xf3, 0xb5, 0x44, 0xdb,
	0xca, 0x2a, 0x6b, 0x5f, 0x68, 0xb0, 0x3a, 0x6d, 0x1f, 0x68, 0x1f, 0x8a, 0x9c, 0x98, 0xd2, 0xb3,
	0x68, 0xaf, 0x26, 0x14, 0x73, 0xa7, 0x95, 0x75, 0xdf, 0x9b, 0xc1, 0x05, 0xf7, 0xcc, 0x4e, 0xcf,
	0xf0, 0x09, 0xa0, 0x11, 0x45, 0xa5, 0x98, 0x92, 0xa4, 0x1e, 0xbf, 0x96, 0xa4, 0x26, 0x90, 0x97,
	0x7b, 0x93, 0x8a, 0x9d, 0x0a, 0x94, 0x12, 0x54, 0xcb, 0x0d, 0xce, 0x59, 0xed, 0xf9, 0x2c, 0x54,
	0x26, 0xf6, 0x84, 0x36, 0x20, 0x17, 0xd1, 0xa7, 0x03, 0x1a, 0xd8, 0x54, 0x1c, 0x67, 0x1e, 0xa7,
	0x6b, 0x5e, 0x07, 0x46, 0xdd, 0x14, 0xa7, 0xb2, 0xa4, 0x0e, 0xa4, 0xfd, 0x14, 0x17, 0xf2, 0x92,
	0xa5, 0xcc, 0x38, 0xab, 0x29, 0x32, 0x00, 0x29, 0x3a, 0x66, 0x61, 0x8c, 0x1a, 0xb0, 0x32, 0xd1,
	0x72, 0x09, 0x30, 0x49, 0x05, 0x68, 0xbc, 0xe9, 0x12, 0x88, 0x0f, 0x21, 0xdb, 0x8a, 0x49, 0x58,
	0x91, 0xdd, 0xb8, 0x92, 0x91, 0x0b, 0xec, 0xa9, 0x0c, 0xba, 0xf8, 0xc6, 0x0c, 0xba, 0x34, 0x85,
	0x41, 0x39, 0x67, 0x11, 0xfb, 0xc2, 0x0a, 0xa9, 0x4d, 0xdd, 0x4b, 0xea, 0x88, 0xbc, 0xcc, 0xe1,
	0x02, 0xb1, 0x2f, 0xb0, 0x12, 0xf1, 0xea, 0xc9, 0x4d, 0x1c, 0x12, 0x13, 0x91, 0x66, 0x45, 0xbc,
	0x44, 0xec, 0x8b, 0x36, 0x89, 0x49, 0xed, 0x37, 0x73, 0xb0, 0x36, 0xf5, 0x96, 0x78, 0x97, 0xe0,
	0xd3, 0x28, 0x22, 0xdd, 0xb4, 0xe8, 0x16, 0x71, 0x5e, 0x49, 0x4c, 0x87, 0x57, 0x0b, 0x16, 0xba,
	0x5d, 0x37, 0xb0, 0x24, 0x35, 0x8b, 0x68, 0x97, 0x70, 0x51, 0x0a, 0xdb, 0x42, 0x86, 0x1e, 0x43,
	0x36, 0x60, 0x89, 0xe5, 0x9c, 0xb0, 0xcc, 0x36, 0xb6, 0xca, 0x7c, 0x15, 0x16, 0x02, 0xc6, 0xef,
	0x56, 0xb6, 0x0a, 0x72, 0x81, 0xde, 0x85, 0xb2, 0xfa, 0x52, 0x3c, 0xb4, 0x7a, 0x24, 0xea, 0xa9,
	0xe8, 0xaa, 0x4f, 0x75, 0x86, 0x7b, 0x24, 0xea, 0x71, 0x9e, 0xcb, 0x7e, 0x2a, 0x31, 0x15, 0x24,
	0x3c, 0xf6, 0xad, 0x91, 0xbd, 0x42, 0x3d, 0xf3, 0x98, 0x7d, 0x61, 0x05, 0x03, 0xff, 0x8c, 0x86,
	0x2a, 0xc4, 0xcb, 0x52, 0xb5, 0xc3, 0x35, 0x87, 0x42, 0x81, 0xbe, 0x0b, 0xd5, 0x2c, 0xfe, 0x98,
	0x53, 0x4e, 0x38, 0xad, 0x67, 0xf4, 0x59, 0xcf, 0x5b, 0x90, 0xef, 0x87, 0xcc, 0xa6, 0x51, 0x44,
	0x1d, 0x11, 0xfe, 0x1c, 0x1e, 0x09, 0xf8, 0xdd, 0xf0, 0x96, 0x61, 0xc0, 0x95, 0x20, 0x70, 0x96,
	0xba, 0x24, 0x3a, 0x8d, 0xa8, 0x53, 0xfb, 0xd7, 0x22, 0xe8, 0x66, 0xb0, 0xeb, 0xf1, 0x6b, 0x4e,
	0x99, 0x30, 0x8d, 0x91, 0x96, 0x8d, 0x51, 0x96, 0x1f, 0x67, 0x5f, 0x98, 0x32, 0x06, 0xd1, 0x44,
	0xfb, 0x53, 0xc4, 0x05, 0x2e, 0x4b, 0x68, 0xaf, 0x03, 0xe5, 0x0c, 0xe7, 0x5f, 0xf5, 0xa9, 0x1a,
	0x1f, 0x5e, 0x9a, 0xd7, 0xc9, 0xae, 0x8e, 0xd2, 0x86, 0xe0, 0xaa, 0x4f, 0x71, 0x89, 0x65, 0x97,
	0x68, 0x0f, 0x16, 0x89, 0x9f, 0x92, 0xfd, 0x75, 0x4a, 0xbb, 0xf2, 0xe7, 0x48, 0x8a, 0x24, 0xae,
	0xdb, 0x53, 0x29, 0x7f, 0xf4, 0x04, 0x8a, 0x6e, 0xe0, 0xc6, 0xae, 0x20, 0x1e, 0x22, 0x33, 0xea,
	0x4d, 0xb9, 0xb2, 0x90, 0x7a, 0x36, 0x63, 0x74, 0x0a, 0x2b, 0x74, 0xd8, 0xa7, 0x76, 0x2c, 0x8a,
	0xb5, 0xdf, 0xf7, 0x28, 0x3f, 0xb7, 0x9a, 0x34, 0xde, 0x0c, 0x0f, 0x25, 0x00, 0xad, 0xd4, 0x9f,
	0x57, 0x27, 0xde, 0x4c, 0x5d, 0x59, 0xb2, 0x4b, 0xca, 0xcb, 0x86, 0x4a, 0x88, 0x5a, 0x22, 0x14,
	0xdf, 0x4f, 0xf9, 0x57, 0x52, 0xdb, 0xb7, 0x5e, 0x77, 0x45, 0x13, 0xcc, 0x7b, 0x0f, 0x4a, 0x34,
	0x0c, 0x59, 0x68, 0xa9, 0x4c, 0x16, 0x0c, 0x97, 0xc7, 0x45, 0x21, 0x3c, 0x90, 0xb2, 0x31, 0x06,
	0x2d, 0x7e, 0x4d, 0x06, 0x2d, 0x7d, 0x33, 0x0c, 0x5a, 0x7e, 0x3b, 0x06, 0xad, 0xbc, 0x8a, 0x41,
	0xff, 0x33, 0x07, 0x1b, 0x99, 0xf1, 0x2e, 0x69, 0x59, 0x02, 0xd2, 0x8f, 0x7a, 0x2c, 0xe6, 0xcc,
	0x17, 0xb3, 0x98, 0x78, 0xd6, 0x58, 0x6b, 0xa8, 0x5d, 0x77, 0x58, 0x15, 0x58, 0x38, 0xd3, 0x1f,
	0xfe, 0x0c, 0xaa, 0x12, 0x7f, 0x4a, 0x97, 0x38, 0x7b, 0xcd, 0xaf, 0xac, 0x0b, 0xc4, 0xd6, 0x0b,
	0xad, 0xe2, 0x43, 0xd0, 0xe5, 0x08, 0x9e, 0xce, 0xde, 0x91, 0x6a, 0xee, 0x2b, 0x52, 0x9e, 0x9c,
	0x3e, 0x12, 0x05, 0x4f, 0x0c, 0x0d, 0x74, 0x68, 0x53, 0xea, 0x50, 0x27, 0xe3, 0x32, 0x2f, 0x5c,
	0xd6, 0x85, 0xde, 0x50, 0xea, 0x91, 0xe7, 0x0e, 0xe4, 0x47, 0xec, 0xb6, 0xf0, 0x16, 0x19, 0x31,
	0x72, 0x43, 0x3f, 0x85, 0x95, 0xb1, 0xa0, 0x7f, 0xcd, 0xfc, 0x5f, 0xce, 0x44, 0x5d, 0xb6, 0x89,
	0xb5, 0x5f, 0xcd, 0x02, 0x88, 0x9e, 0xb6, 0xe9, 0xd1, 0x30, 0x7e, 0xcd, 0xff, 0x69, 0xc6, 0x2a,
	0xe8, 0xec, 0x8b, 0x15, 0xf4, 0x85, 0xde, 0x79, 0x6e, 0x4a, 0xef, 0xfc, 0x18, 0x50, 0x3a, 0x80,
	0xa5, 0x51, 0x55, 0x43, 0xd3, 0x72, 0xaa, 0x49, 0xe2, 0xf9, 0x7f, 0x09, 0xe3, 0x63, 0x40, 0x21,
	0xb5, 0x99, 0xef, 0xd3, 0x80, 0xdf, 0x20, 0xbf, 0x63, 0x16, 0x24, 0xa4, 0x98, 0xd1, 0x34, 0x85,
	0xa2, 0xf6, 0xbb, 0x59, 0xd0, 0x47, 0x99, 0xa0, 0xc6, 0xf1, 0xfb, 0x50, 0xee, 0x7a, 0xec, 0x8c,
	0x78, 0x13, 0xa3, 0x66, 0x49, 0x4a, 0x27, 0x06, 0x4d, 0x75, 0x5f, 0x74, 0xd8, 0x67, 0xd1, 0x20,
	0xa4, 0x99, 0x41, 0x53, 0x46, 0xdf, 0x50, 0x0a, 0x3e, 0xc8, 0x3b, 0xf4, 0x9c, 0x17, 0x82, 0x89,
	0x31, 0xb3, 0xac, 0xc4, 0xc9, 0x90, 0xf9, 0x10, 0x74, 0x39, 0xd9, 0x58, 0xe7, 0xa1, 0x6c, 0xf6,
	0xae, 0xd4, 0x03, 0xac, 0x48, 0xf9, 0x6e, 0x22, 0x46, 0xbb, 0xb0, 0x45, 0x7d, 0x1a, 0x76, 0xf9,
	0xc2, 0xf2, 0xdc, 0xa7, 0x03, 0xd7, 0x51, 0xa4, 0x96, 0x0e, 0xbe, 0x72, 0xf0, 0xbc, 0x9d, 0x9a,
	0xed, 0x8f, 0xac, 0x46, 0x43, 0x70, 0x15, 0x96, 0x68, 0x40, 0xce, 0x3c, 0xea, 0xa8, 0x7f, 0x5c,
	0x25, 0xcb, 0x47, 0x5f, 0x6a, 0xb0, 0x3a, 0x6d, 0xb4, 0x41, 0x1b, 0xb0, 0x8e, 0x8d, 0x83, 0xa3,
	0x8e, 0x61, 0x1d, 0x1f, 0x9d, 0x98, 0x1d, 0xf3, 0xe8, 0xd0, 0x6a, 0xb6, 0x3a, 0xe6, 0x47, 0x86,
	0x3e, 0x83, 0x6a, 0xb0, 0x39, 0xa9, 0x3b, 0x36, 0x0e, 0xdb, 0xe6, 0xe1, 0x13, 0xeb, 0xf4, 0xb8,
	0xdd, 0xec, 0x18, 0xba, 0x36, 0xcd, 0xa6, 0x8d, 0xcd, 0xdd, 0x8e, 0x65, 0xfc, 0xb0, 0x65, 0x18,
	0x6d, 0xa3, 0xad, 0xcf, 0xa2, 0x2d, 0xb8, 0x39, 0x69, 0xb3, 0x6f, 0xfe, 0xe0, 0xd4, 0x6c, 0x37,
	0x3b, 0xe6, 0xe1, 0x13, 0x7d, 0x6e, 0xda, 0x26, 0x5a, 0xfb, 0x47, 0x27, 0x46, 0x5b, 0x9f, 0x47,
	0x37, 0x60, 0x6d, 0x52, 0x67, 0x60, 0x7c, 0x84, 0xf5, 0x85, 0x8d, 0xf9, 0x5f, 0xfc, 0x61, 0x73,
	0xe6, 0xd1, 0x2f, 0x35, 0x58, 0x9b, 0x4a, 0xec, 0xe8, 0x16, 0x54, 0x8f, 0x8e, 0x0d, 0xdc, 0x14,
	0x4e, 0x0a, 0xa4, 0x6d, 0x08, 0x18, 0x7d, 0x06, 0xdd, 0x86, 0x1b, 0x2f, 0x68, 0x3f, 0x36, 0x3b,
	0x7b, 0x6d, 0xdc, 0xfc, 0x58, 0xd7, 0xd0, 0x3b, 0xb0, 0x92, 0x55, 0xef, 0x34, 0xf7, 0x9b, 0x87,
	0x2d, 0x43, 0x9f, 0x1d, 0x57, 0x24, 0xe7, 0x30, 0xf4, 0x39, 0xb5, 0x9d, 0xdf, 0x6b, 0x50, 0x1e,
	0x27, 0x31, 0xb4, 0x0a, 0xba, 0x79, 0xb8, 0xbb, 0x6f, 0x3e, 0xd9, 0xeb, 0x24, 0x01, 0xd4, 0x67,
	0x38, 0xce, 0x48, 0x8a, 0x8f, 0x5a, 0xc6, 0xc9, 0x09, 0x57, 0x68, 0x68, 0x1d, 0x50, 0xaa, 0x68,
	0x1d, 0x1d, 0x1c, 0xef, 0x1b, 0x1d, 0x11, 0xc6, 0x15, 0xa8, 0xa4, 0xf2, 0xdd, 0xa6, 0xb9, 0x6f,
	0xb4, 0xf5, 0xb9, 0x31, 0xec, 0x8e, 0x79, 0x60, 0x1c, 0x9d, 0x76, 0xf4, 0xf9, 0x71, 0x08, 0xbe,
	0xef, 0x7d, 0x6e, 0xad, 0x22, 0xb6, 0xf3, 0xbd, 0xcf, 0x9e, 0x6d, 0x6a, 0x9f, 0x3f, 0xdb, 0xd4,
	0xfe, 0xf9, 0x6c, 0x53, 0xfb, 0xf4, 0xf9, 0xe6, 0xcc, 0xe7, 0xcf, 0x37, 0x67, 0xbe, 0x7c, 0xbe,
	0x39, 0xf3, 0xe3, 0x7b, 0x8a, 0xe8, 0x24, 0xeb, 0x0d, 0xaf, 0x7e, 0xde, 0xb8, 0xdc, 0x6e, 0xf0,
	0xce, 0x2a, 0x1a, 0xfd, 0x6f, 0xfb, 0x6c, 0x51, 0x64, 0xf1, 0x07, 0xff, 0x0b, 0x00, 0x00, 0xff,
	0xff, 0x66, 0xa9, 0x0c, 0xae, 0xfc, 0x16, 0x00, 0x00,
}

func (m *CrossChainRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RiskParams != nil {
		{
			size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.MaxPositionValue.Size()
		i -= size
		if _, err := m.MaxPositionValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ProviderConfig != nil {
		{
			size, err := m.ProviderConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Provider != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Provider))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DestinationChain) > 0 {
		i -= len(m.DestinationChain)
		copy(dAtA[i:], m.DestinationChain)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.DestinationChain)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceChain) > 0 {
		i -= len(m.SourceChain)
		copy(dAtA[i:], m.SourceChain)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.SourceChain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainProviderConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainProviderConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainProviderConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		{
			size := m.Config.Size()
			i -= size
			if _, err := m.Config.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainProviderConfig_IbcConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainProviderConfig_IbcConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IbcConfig != nil {
		{
			size, err := m.IbcConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CrossChainProviderConfig_HyperlaneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainProviderConfig_HyperlaneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HyperlaneConfig != nil {
		{
			size, err := m.HyperlaneConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IBCConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IBCConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IBCConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeoutHeight != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.TimeoutHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.TimeoutTimestamp != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.TimeoutTimestamp))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HyperlaneConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HyperlaneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HyperlaneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.GasPrice.Size()
		i -= size
		if _, err := m.GasPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.GasLimit != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.GasLimit))
		i--
		dAtA[i] = 0x28
	}
	if len(m.HookAddress) > 0 {
		i -= len(m.HookAddress)
		copy(dAtA[i:], m.HookAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.HookAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GasPaymasterAddress) > 0 {
		i -= len(m.GasPaymasterAddress)
		copy(dAtA[i:], m.GasPaymasterAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.GasPaymasterAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MailboxAddress) > 0 {
		i -= len(m.MailboxAddress)
		copy(dAtA[i:], m.MailboxAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.MailboxAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.DomainId != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.DomainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConservativeDiscount != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.ConservativeDiscount))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxRetries != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxRetries))
		i--
		dAtA[i] = 0x20
	}
	if m.OperationTimeout != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.OperationTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxDriftThreshold != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxDriftThreshold))
		i--
		dAtA[i] = 0x10
	}
	if m.PositionHaircut != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.PositionHaircut))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemotePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemotePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemotePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequiredConfirmations != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.RequiredConfirmations))
		i--
		dAtA[i] = 0x68
	}
	if m.Confirmations != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Confirmations))
		i--
		dAtA[i] = 0x60
	}
	if m.ProviderTracking != nil {
		{
			size, err := m.ProviderTracking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Provider != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Provider))
		i--
		dAtA[i] = 0x50
	}
	{
		size := m.AllocatedShares.Size()
		i -= size
		if _, err := m.AllocatedShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.Status != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x40
	}
	if m.CurrentDrift != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.CurrentDrift))
		i--
		dAtA[i] = 0x38
	}
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastUpdate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdate):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintCrossChain(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x32
	{
		size := m.ConservativeValue.Size()
		i -= size
		if _, err := m.ConservativeValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.RemoteValue.Size()
		i -= size
		if _, err := m.RemoteValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.LocalAddress) > 0 {
		i -= len(m.LocalAddress)
		copy(dAtA[i:], m.LocalAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.LocalAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RemoteAddress) > 0 {
		i -= len(m.RemoteAddress)
		copy(dAtA[i:], m.RemoteAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.RemoteAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProviderTrackingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderTrackingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderTrackingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TrackingInfo != nil {
		{
			size := m.TrackingInfo.Size()
			i -= size
			if _, err := m.TrackingInfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProviderTrackingInfo_IbcTracking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderTrackingInfo_IbcTracking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IbcTracking != nil {
		{
			size, err := m.IbcTracking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ProviderTrackingInfo_HyperlaneTracking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderTrackingInfo_HyperlaneTracking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HyperlaneTracking != nil {
		{
			size, err := m.HyperlaneTracking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IBCTrackingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IBCTrackingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IBCTrackingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AckData) > 0 {
		i -= len(m.AckData)
		copy(dAtA[i:], m.AckData)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.AckData)))
		i--
		dAtA[i] = 0x4a
	}
	if m.AckReceived {
		i--
		if m.AckReceived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.TimeoutHeight != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.TimeoutHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.TimeoutTimestamp != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.TimeoutTimestamp))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DestinationPort) > 0 {
		i -= len(m.DestinationPort)
		copy(dAtA[i:], m.DestinationPort)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.DestinationPort)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DestinationChannel) > 0 {
		i -= len(m.DestinationChannel)
		copy(dAtA[i:], m.DestinationChannel)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.DestinationChannel)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SourcePort) > 0 {
		i -= len(m.SourcePort)
		copy(dAtA[i:], m.SourcePort)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.SourcePort)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceChannel) > 0 {
		i -= len(m.SourceChannel)
		copy(dAtA[i:], m.SourceChannel)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.SourceChannel)))
		i--
		dAtA[i] = 0x12
	}
	if m.Sequence != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HyperlaneTrackingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HyperlaneTrackingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HyperlaneTrackingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GasUsed != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x50
	}
	if m.Processed {
		i--
		if m.Processed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.DestinationBlockNumber != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.DestinationBlockNumber))
		i--
		dAtA[i] = 0x40
	}
	if m.OriginBlockNumber != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.OriginBlockNumber))
		i--
		dAtA[i] = 0x38
	}
	if len(m.DestinationTxHash) > 0 {
		i -= len(m.DestinationTxHash)
		copy(dAtA[i:], m.DestinationTxHash)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.DestinationTxHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OriginTxHash) > 0 {
		i -= len(m.OriginTxHash)
		copy(dAtA[i:], m.OriginTxHash)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.OriginTxHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Nonce != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x20
	}
	if m.DestinationDomain != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.DestinationDomain))
		i--
		dAtA[i] = 0x18
	}
	if m.OriginDomain != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.OriginDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MessageId) > 0 {
		i -= len(m.MessageId)
		copy(dAtA[i:], m.MessageId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.MessageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InFlightPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InFlightPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InFlightPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequiredConfirmations != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.RequiredConfirmations))
		i--
		dAtA[i] = 0x78
	}
	if m.Confirmations != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Confirmations))
		i--
		dAtA[i] = 0x70
	}
	if m.ProviderTracking != nil {
		{
			size, err := m.ProviderTracking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Provider != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Provider))
		i--
		dAtA[i] = 0x60
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Status != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.RetryCount != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.RetryCount))
		i--
		dAtA[i] = 0x48
	}
	n10, err10 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedCompletion, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedCompletion):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintCrossChain(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x42
	n11, err11 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.InitiatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.InitiatedAt):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintCrossChain(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x3a
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.OperationType != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.OperationType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.UserAddress) > 0 {
		i -= len(m.UserAddress)
		copy(dAtA[i:], m.UserAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.UserAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainPositionSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainPositionSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainPositionSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalRemoteShares.Size()
		i -= size
		if _, err := m.TotalRemoteShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	n12, err12 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err12 != nil {
		return 0, err12
	}
	i -= n12
	i = encodeVarintCrossChain(dAtA, i, uint64(n12))
	i--
	dAtA[i] = 0x2a
	if m.DriftExceededPositions != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.DriftExceededPositions))
		i--
		dAtA[i] = 0x20
	}
	if m.ActivePositions != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.ActivePositions))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.TotalConservativeValue.Size()
		i -= size
		if _, err := m.TotalConservativeValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalRemoteValue.Size()
		i -= size
		if _, err := m.TotalRemoteValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DriftAlert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DriftAlert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DriftAlert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RecommendedAction) > 0 {
		i -= len(m.RecommendedAction)
		copy(dAtA[i:], m.RecommendedAction)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.RecommendedAction)))
		i--
		dAtA[i] = 0x32
	}
	n13, err13 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err13 != nil {
		return 0, err13
	}
	i -= n13
	i = encodeVarintCrossChain(dAtA, i, uint64(n13))
	i--
	dAtA[i] = 0x2a
	if m.ThresholdExceeded != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.ThresholdExceeded))
		i--
		dAtA[i] = 0x20
	}
	if m.CurrentDrift != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.CurrentDrift))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UserAddress) > 0 {
		i -= len(m.UserAddress)
		copy(dAtA[i:], m.UserAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.UserAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.EmergencyLiquidationThreshold != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.EmergencyLiquidationThreshold))
		i--
		dAtA[i] = 0x28
	}
	if m.UpdateFrequency != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.UpdateFrequency))
		i--
		dAtA[i] = 0x20
	}
	if m.DefaultTimeout != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.DefaultTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxRemoteExposure != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxRemoteExposure))
		i--
		dAtA[i] = 0x10
	}
	if m.GlobalHaircut != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.GlobalHaircut))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCrossChain(dAtA []byte, offset int, v uint64) int {
	offset -= sovCrossChain(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CrossChainRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.SourceChain)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.DestinationChain)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.Provider != 0 {
		n += 1 + sovCrossChain(uint64(m.Provider))
	}
	if m.ProviderConfig != nil {
		l = m.ProviderConfig.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.Active {
		n += 2
	}
	l = m.MaxPositionValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if m.RiskParams != nil {
		l = m.RiskParams.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}

func (m *CrossChainProviderConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Config != nil {
		n += m.Config.Size()
	}
	return n
}

func (m *CrossChainProviderConfig_IbcConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IbcConfig != nil {
		l = m.IbcConfig.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}
func (m *CrossChainProviderConfig_HyperlaneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HyperlaneConfig != nil {
		l = m.HyperlaneConfig.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}
func (m *IBCConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.TimeoutTimestamp != 0 {
		n += 1 + sovCrossChain(uint64(m.TimeoutTimestamp))
	}
	if m.TimeoutHeight != 0 {
		n += 1 + sovCrossChain(uint64(m.TimeoutHeight))
	}
	return n
}

func (m *HyperlaneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainId != 0 {
		n += 1 + sovCrossChain(uint64(m.DomainId))
	}
	l = len(m.MailboxAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.GasPaymasterAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.HookAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.GasLimit != 0 {
		n += 1 + sovCrossChain(uint64(m.GasLimit))
	}
	l = m.GasPrice.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	return n
}

func (m *CrossChainRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionHaircut != 0 {
		n += 1 + sovCrossChain(uint64(m.PositionHaircut))
	}
	if m.MaxDriftThreshold != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxDriftThreshold))
	}
	if m.OperationTimeout != 0 {
		n += 1 + sovCrossChain(uint64(m.OperationTimeout))
	}
	if m.MaxRetries != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxRetries))
	}
	if m.ConservativeDiscount != 0 {
		n += 1 + sovCrossChain(uint64(m.ConservativeDiscount))
	}
	return n
}

func (m *RemotePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.RemoteAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.LocalAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = m.RemoteValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.ConservativeValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdate)
	n += 1 + l + sovCrossChain(uint64(l))
	if m.CurrentDrift != 0 {
		n += 1 + sovCrossChain(uint64(m.CurrentDrift))
	}
	if m.Status != 0 {
		n += 1 + sovCrossChain(uint64(m.Status))
	}
	l = m.AllocatedShares.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if m.Provider != 0 {
		n += 1 + sovCrossChain(uint64(m.Provider))
	}
	if m.ProviderTracking != nil {
		l = m.ProviderTracking.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.Confirmations != 0 {
		n += 1 + sovCrossChain(uint64(m.Confirmations))
	}
	if m.RequiredConfirmations != 0 {
		n += 1 + sovCrossChain(uint64(m.RequiredConfirmations))
	}
	return n
}

func (m *ProviderTrackingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrackingInfo != nil {
		n += m.TrackingInfo.Size()
	}
	return n
}

func (m *ProviderTrackingInfo_IbcTracking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IbcTracking != nil {
		l = m.IbcTracking.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}
func (m *ProviderTrackingInfo_HyperlaneTracking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HyperlaneTracking != nil {
		l = m.HyperlaneTracking.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}
func (m *IBCTrackingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sequence != 0 {
		n += 1 + sovCrossChain(uint64(m.Sequence))
	}
	l = len(m.SourceChannel)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.SourcePort)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.DestinationChannel)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.DestinationPort)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.TimeoutTimestamp != 0 {
		n += 1 + sovCrossChain(uint64(m.TimeoutTimestamp))
	}
	if m.TimeoutHeight != 0 {
		n += 1 + sovCrossChain(uint64(m.TimeoutHeight))
	}
	if m.AckReceived {
		n += 2
	}
	l = len(m.AckData)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}

func (m *HyperlaneTrackingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MessageId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.OriginDomain != 0 {
		n += 1 + sovCrossChain(uint64(m.OriginDomain))
	}
	if m.DestinationDomain != 0 {
		n += 1 + sovCrossChain(uint64(m.DestinationDomain))
	}
	if m.Nonce != 0 {
		n += 1 + sovCrossChain(uint64(m.Nonce))
	}
	l = len(m.OriginTxHash)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.DestinationTxHash)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.OriginBlockNumber != 0 {
		n += 1 + sovCrossChain(uint64(m.OriginBlockNumber))
	}
	if m.DestinationBlockNumber != 0 {
		n += 1 + sovCrossChain(uint64(m.DestinationBlockNumber))
	}
	if m.Processed {
		n += 2
	}
	if m.GasUsed != 0 {
		n += 1 + sovCrossChain(uint64(m.GasUsed))
	}
	return n
}

func (m *InFlightPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovCrossChain(uint64(m.Nonce))
	}
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.UserAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.OperationType != 0 {
		n += 1 + sovCrossChain(uint64(m.OperationType))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.Shares.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.InitiatedAt)
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedCompletion)
	n += 1 + l + sovCrossChain(uint64(l))
	if m.RetryCount != 0 {
		n += 1 + sovCrossChain(uint64(m.RetryCount))
	}
	if m.Status != 0 {
		n += 1 + sovCrossChain(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.Provider != 0 {
		n += 1 + sovCrossChain(uint64(m.Provider))
	}
	if m.ProviderTracking != nil {
		l = m.ProviderTracking.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.Confirmations != 0 {
		n += 1 + sovCrossChain(uint64(m.Confirmations))
	}
	if m.RequiredConfirmations != 0 {
		n += 1 + sovCrossChain(uint64(m.RequiredConfirmations))
	}
	return n
}

func (m *CrossChainPositionSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalRemoteValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.TotalConservativeValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if m.ActivePositions != 0 {
		n += 1 + sovCrossChain(uint64(m.ActivePositions))
	}
	if m.DriftExceededPositions != 0 {
		n += 1 + sovCrossChain(uint64(m.DriftExceededPositions))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.TotalRemoteShares.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	return n
}

func (m *DriftAlert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.UserAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.CurrentDrift != 0 {
		n += 1 + sovCrossChain(uint64(m.CurrentDrift))
	}
	if m.ThresholdExceeded != 0 {
		n += 1 + sovCrossChain(uint64(m.ThresholdExceeded))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovCrossChain(uint64(l))
	l = len(m.RecommendedAction)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}

func (m *CrossChainConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GlobalHaircut != 0 {
		n += 1 + sovCrossChain(uint64(m.GlobalHaircut))
	}
	if m.MaxRemoteExposure != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxRemoteExposure))
	}
	if m.DefaultTimeout != 0 {
		n += 1 + sovCrossChain(uint64(m.DefaultTimeout))
	}
	if m.UpdateFrequency != 0 {
		n += 1 + sovCrossChain(uint64(m.UpdateFrequency))
	}
	if m.EmergencyLiquidationThreshold != 0 {
		n += 1 + sovCrossChain(uint64(m.EmergencyLiquidationThreshold))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func sovCrossChain(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCrossChain(x uint64) (n int) {
	return sovCrossChain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CrossChainRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			m.Provider = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Provider |= v2.Provider(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderConfig == nil {
				m.ProviderConfig = &CrossChainProviderConfig{}
			}
			if err := m.ProviderConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPositionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxPositionValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RiskParams == nil {
				m.RiskParams = &CrossChainRiskParams{}
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainProviderConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainProviderConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainProviderConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IBCConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &CrossChainProviderConfig_IbcConfig{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyperlaneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HyperlaneConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &CrossChainProviderConfig_HyperlaneConfig{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IBCConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IBCConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IBCConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutTimestamp", wireType)
			}
			m.TimeoutTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutHeight", wireType)
			}
			m.TimeoutHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HyperlaneConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HyperlaneConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HyperlaneConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainId", wireType)
			}
			m.DomainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DomainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailboxAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailboxAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPaymasterAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasPaymasterAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HookAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HookAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
			}
			m.GasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionHaircut", wireType)
			}
			m.PositionHaircut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionHaircut |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDriftThreshold", wireType)
			}
			m.MaxDriftThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDriftThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationTimeout", wireType)
			}
			m.OperationTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
			}
			m.MaxRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConservativeDiscount", wireType)
			}
			m.ConservativeDiscount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConservativeDiscount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemotePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemotePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemotePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalAddress = append(m.LocalAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.LocalAddress == nil {
				m.LocalAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoteValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConservativeValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConservativeValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastUpdate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentDrift", wireType)
			}
			m.CurrentDrift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentDrift |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RemotePositionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocatedShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			m.Provider = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Provider |= v2.Provider(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderTracking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderTracking == nil {
				m.ProviderTracking = &ProviderTrackingInfo{}
			}
			if err := m.ProviderTracking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirmations", wireType)
			}
			m.Confirmations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Confirmations |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredConfirmations", wireType)
			}
			m.RequiredConfirmations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredConfirmations |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderTrackingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderTrackingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderTrackingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcTracking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IBCTrackingInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TrackingInfo = &ProviderTrackingInfo_IbcTracking{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyperlaneTracking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HyperlaneTrackingInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TrackingInfo = &ProviderTrackingInfo_HyperlaneTracking{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IBCTrackingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IBCTrackingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IBCTrackingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourcePort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutTimestamp", wireType)
			}
			m.TimeoutTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutHeight", wireType)
			}
			m.TimeoutHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckReceived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AckReceived = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AckData = append(m.AckData[:0], dAtA[iNdEx:postIndex]...)
			if m.AckData == nil {
				m.AckData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HyperlaneTrackingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HyperlaneTrackingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HyperlaneTrackingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = append(m.MessageId[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageId == nil {
				m.MessageId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginDomain", wireType)
			}
			m.OriginDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
			}
			m.DestinationDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginBlockNumber", wireType)
			}
			m.OriginBlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginBlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationBlockNumber", wireType)
			}
			m.DestinationBlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationBlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Processed = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InFlightPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InFlightPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InFlightPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAddress = append(m.UserAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.UserAddress == nil {
				m.UserAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationType", wireType)
			}
			m.OperationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationType |= InFlightOperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.InitiatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedCompletion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedCompletion, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryCount", wireType)
			}
			m.RetryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= InFlightStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			m.Provider = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Provider |= v2.Provider(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderTracking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderTracking == nil {
				m.ProviderTracking = &ProviderTrackingInfo{}
			}
			if err := m.ProviderTracking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirmations", wireType)
			}
			m.Confirmations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Confirmations |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredConfirmations", wireType)
			}
			m.RequiredConfirmations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredConfirmations |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainPositionSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainPositionSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainPositionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRemoteValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRemoteValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalConservativeValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalConservativeValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePositions", wireType)
			}
			m.ActivePositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivePositions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriftExceededPositions", wireType)
			}
			m.DriftExceededPositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DriftExceededPositions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRemoteShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRemoteShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DriftAlert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DriftAlert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DriftAlert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAddress = append(m.UserAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.UserAddress == nil {
				m.UserAddress = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentDrift", wireType)
			}
			m.CurrentDrift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentDrift |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdExceeded", wireType)
			}
			m.ThresholdExceeded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThresholdExceeded |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendedAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecommendedAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalHaircut", wireType)
			}
			m.GlobalHaircut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalHaircut |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRemoteExposure", wireType)
			}
			m.MaxRemoteExposure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRemoteExposure |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTimeout", wireType)
			}
			m.DefaultTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateFrequency", wireType)
			}
			m.UpdateFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateFrequency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmergencyLiquidationThreshold", wireType)
			}
			m.EmergencyLiquidationThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmergencyLiquidationThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCrossChain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCrossChain
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCrossChain
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCrossChain
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCrossChain        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCrossChain          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCrossChain = fmt.Errorf("proto: unexpected end of group")
)
