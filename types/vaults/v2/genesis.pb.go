// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/genesis.proto

package v2

import (
	cosmossdk_io_math "cosmossdk.io/math"
	_ "dollar.noble.xyz/v2/types/vaults"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GenesisState defines the V2 vaults module's genesis state
type GenesisState struct {
	// Module parameters
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
	// All V2 vault configurations
	VaultConfigs []VaultConfig `protobuf:"bytes,2,rep,name=vault_configs,json=vaultConfigs,proto3" json:"vault_configs"`
	// All user positions in V2 vaults
	UserPositions []UserPositionEntry `protobuf:"bytes,3,rep,name=user_positions,json=userPositions,proto3" json:"user_positions"`
	// Current NAV information for each vault type
	NavEntries []NAVEntry `protobuf:"bytes,4,rep,name=nav_entries,json=navEntries,proto3" json:"nav_entries"`
	// Fee configurations
	FeeConfigs []FeeConfigEntry `protobuf:"bytes,5,rep,name=fee_configs,json=feeConfigs,proto3" json:"fee_configs"`
	// Exit queue entries
	ExitQueue []ExitRequestEntry `protobuf:"bytes,6,rep,name=exit_queue,json=exitQueue,proto3" json:"exit_queue"`
	// Total shares issued per vault type
	SharesTotals []SharesTotalEntry `protobuf:"bytes,7,rep,name=shares_totals,json=sharesTotals,proto3" json:"shares_totals"`
	// Vault statistics
	VaultStats []VaultStatsEntry `protobuf:"bytes,8,rep,name=vault_stats,json=vaultStats,proto3" json:"vault_stats"`
}

func (m *GenesisState) Reset()         { *m = GenesisState{} }
func (m *GenesisState) String() string { return proto.CompactTextString(m) }
func (*GenesisState) ProtoMessage()    {}
func (*GenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{0}
}
func (m *GenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisState.Merge(m, src)
}
func (m *GenesisState) XXX_Size() int {
	return m.Size()
}
func (m *GenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

func (m *GenesisState) GetVaultConfigs() []VaultConfig {
	if m != nil {
		return m.VaultConfigs
	}
	return nil
}

func (m *GenesisState) GetUserPositions() []UserPositionEntry {
	if m != nil {
		return m.UserPositions
	}
	return nil
}

func (m *GenesisState) GetNavEntries() []NAVEntry {
	if m != nil {
		return m.NavEntries
	}
	return nil
}

func (m *GenesisState) GetFeeConfigs() []FeeConfigEntry {
	if m != nil {
		return m.FeeConfigs
	}
	return nil
}

func (m *GenesisState) GetExitQueue() []ExitRequestEntry {
	if m != nil {
		return m.ExitQueue
	}
	return nil
}

func (m *GenesisState) GetSharesTotals() []SharesTotalEntry {
	if m != nil {
		return m.SharesTotals
	}
	return nil
}

func (m *GenesisState) GetVaultStats() []VaultStatsEntry {
	if m != nil {
		return m.VaultStats
	}
	return nil
}

// Params defines the parameters for the V2 vaults module
type Params struct {
	// Authority address that can update parameters
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Default fee rate for deposits (basis points)
	DefaultDepositFeeRate int32 `protobuf:"varint,2,opt,name=default_deposit_fee_rate,json=defaultDepositFeeRate,proto3" json:"default_deposit_fee_rate,omitempty"`
	// Default fee rate for withdrawals (basis points)
	DefaultWithdrawalFeeRate int32 `protobuf:"varint,3,opt,name=default_withdrawal_fee_rate,json=defaultWithdrawalFeeRate,proto3" json:"default_withdrawal_fee_rate,omitempty"`
	// Minimum deposit amount
	MinDepositAmount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=min_deposit_amount,json=minDepositAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_deposit_amount"`
	// Minimum withdrawal amount
	MinWithdrawalAmount cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=min_withdrawal_amount,json=minWithdrawalAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_withdrawal_amount"`
	// Maximum NAV change percentage allowed per update (basis points)
	MaxNavChangeBps int32 `protobuf:"varint,6,opt,name=max_nav_change_bps,json=maxNavChangeBps,proto3" json:"max_nav_change_bps,omitempty"`
	// Exit request timeout duration (in seconds)
	ExitRequestTimeout int64 `protobuf:"varint,7,opt,name=exit_request_timeout,json=exitRequestTimeout,proto3" json:"exit_request_timeout,omitempty"`
	// Maximum number of exit requests to process per block
	MaxExitRequestsPerBlock int32 `protobuf:"varint,8,opt,name=max_exit_requests_per_block,json=maxExitRequestsPerBlock,proto3" json:"max_exit_requests_per_block,omitempty"`
	// Whether V2 vaults are enabled
	VaultsEnabled bool `protobuf:"varint,9,opt,name=vaults_enabled,json=vaultsEnabled,proto3" json:"vaults_enabled,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{1}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *Params) GetDefaultDepositFeeRate() int32 {
	if m != nil {
		return m.DefaultDepositFeeRate
	}
	return 0
}

func (m *Params) GetDefaultWithdrawalFeeRate() int32 {
	if m != nil {
		return m.DefaultWithdrawalFeeRate
	}
	return 0
}

func (m *Params) GetMaxNavChangeBps() int32 {
	if m != nil {
		return m.MaxNavChangeBps
	}
	return 0
}

func (m *Params) GetExitRequestTimeout() int64 {
	if m != nil {
		return m.ExitRequestTimeout
	}
	return 0
}

func (m *Params) GetMaxExitRequestsPerBlock() int32 {
	if m != nil {
		return m.MaxExitRequestsPerBlock
	}
	return 0
}

func (m *Params) GetVaultsEnabled() bool {
	if m != nil {
		return m.VaultsEnabled
	}
	return false
}

// VaultConfig stores configuration for a specific vault type
type VaultConfig struct {
	// Whether this vault type is enabled for new deposits
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Minimum staking period (for staked vaults)
	MinStakingPeriod int64 `protobuf:"varint,2,opt,name=min_staking_period,json=minStakingPeriod,proto3" json:"min_staking_period,omitempty"`
	// Custom fee rates (overrides default if set)
	DepositFeeRate    int32 `protobuf:"varint,3,opt,name=deposit_fee_rate,json=depositFeeRate,proto3" json:"deposit_fee_rate,omitempty"`
	WithdrawalFeeRate int32 `protobuf:"varint,4,opt,name=withdrawal_fee_rate,json=withdrawalFeeRate,proto3" json:"withdrawal_fee_rate,omitempty"`
	// Maximum total deposits allowed
	MaxTotalDeposits cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=max_total_deposits,json=maxTotalDeposits,proto3,customtype=cosmossdk.io/math.Int" json:"max_total_deposits"`
	// Target yield rate (informational)
	TargetYieldRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=target_yield_rate,json=targetYieldRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"target_yield_rate"`
}

func (m *VaultConfig) Reset()         { *m = VaultConfig{} }
func (m *VaultConfig) String() string { return proto.CompactTextString(m) }
func (*VaultConfig) ProtoMessage()    {}
func (*VaultConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{2}
}
func (m *VaultConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VaultConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VaultConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultConfig.Merge(m, src)
}
func (m *VaultConfig) XXX_Size() int {
	return m.Size()
}
func (m *VaultConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VaultConfig proto.InternalMessageInfo

func (m *VaultConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *VaultConfig) GetMinStakingPeriod() int64 {
	if m != nil {
		return m.MinStakingPeriod
	}
	return 0
}

func (m *VaultConfig) GetDepositFeeRate() int32 {
	if m != nil {
		return m.DepositFeeRate
	}
	return 0
}

func (m *VaultConfig) GetWithdrawalFeeRate() int32 {
	if m != nil {
		return m.WithdrawalFeeRate
	}
	return 0
}

// UserPositionEntry stores a user's position in the V2 system
type UserPositionEntry struct {
	// User address
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// User position details
	Position UserPosition `protobuf:"bytes,2,opt,name=position,proto3" json:"position"`
}

func (m *UserPositionEntry) Reset()         { *m = UserPositionEntry{} }
func (m *UserPositionEntry) String() string { return proto.CompactTextString(m) }
func (*UserPositionEntry) ProtoMessage()    {}
func (*UserPositionEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{3}
}
func (m *UserPositionEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPositionEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPositionEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPositionEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPositionEntry.Merge(m, src)
}
func (m *UserPositionEntry) XXX_Size() int {
	return m.Size()
}
func (m *UserPositionEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPositionEntry.DiscardUnknown(m)
}

var xxx_messageInfo_UserPositionEntry proto.InternalMessageInfo

func (m *UserPositionEntry) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *UserPositionEntry) GetPosition() UserPosition {
	if m != nil {
		return m.Position
	}
	return UserPosition{}
}

// NAVEntry stores NAV information for a vault type
type NAVEntry struct {
	// NAV information
	NavInfo NAVInfo `protobuf:"bytes,1,opt,name=nav_info,json=navInfo,proto3" json:"nav_info"`
}

func (m *NAVEntry) Reset()         { *m = NAVEntry{} }
func (m *NAVEntry) String() string { return proto.CompactTextString(m) }
func (*NAVEntry) ProtoMessage()    {}
func (*NAVEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{4}
}
func (m *NAVEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NAVEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NAVEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NAVEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NAVEntry.Merge(m, src)
}
func (m *NAVEntry) XXX_Size() int {
	return m.Size()
}
func (m *NAVEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_NAVEntry.DiscardUnknown(m)
}

var xxx_messageInfo_NAVEntry proto.InternalMessageInfo

func (m *NAVEntry) GetNavInfo() NAVInfo {
	if m != nil {
		return m.NavInfo
	}
	return NAVInfo{}
}

// FeeConfigEntry stores fee configuration for a vault type
type FeeConfigEntry struct {
	// Fee configuration
	FeeConfig FeeConfig `protobuf:"bytes,1,opt,name=fee_config,json=feeConfig,proto3" json:"fee_config"`
}

func (m *FeeConfigEntry) Reset()         { *m = FeeConfigEntry{} }
func (m *FeeConfigEntry) String() string { return proto.CompactTextString(m) }
func (*FeeConfigEntry) ProtoMessage()    {}
func (*FeeConfigEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{5}
}
func (m *FeeConfigEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeConfigEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeConfigEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeConfigEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeConfigEntry.Merge(m, src)
}
func (m *FeeConfigEntry) XXX_Size() int {
	return m.Size()
}
func (m *FeeConfigEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeConfigEntry.DiscardUnknown(m)
}

var xxx_messageInfo_FeeConfigEntry proto.InternalMessageInfo

func (m *FeeConfigEntry) GetFeeConfig() FeeConfig {
	if m != nil {
		return m.FeeConfig
	}
	return FeeConfig{}
}

// ExitRequestEntry stores an exit request in the queue
type ExitRequestEntry struct {
	// User address
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Exit request details
	ExitRequest ExitRequest `protobuf:"bytes,2,opt,name=exit_request,json=exitRequest,proto3" json:"exit_request"`
}

func (m *ExitRequestEntry) Reset()         { *m = ExitRequestEntry{} }
func (m *ExitRequestEntry) String() string { return proto.CompactTextString(m) }
func (*ExitRequestEntry) ProtoMessage()    {}
func (*ExitRequestEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{6}
}
func (m *ExitRequestEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExitRequestEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExitRequestEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExitRequestEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExitRequestEntry.Merge(m, src)
}
func (m *ExitRequestEntry) XXX_Size() int {
	return m.Size()
}
func (m *ExitRequestEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ExitRequestEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ExitRequestEntry proto.InternalMessageInfo

func (m *ExitRequestEntry) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *ExitRequestEntry) GetExitRequest() ExitRequest {
	if m != nil {
		return m.ExitRequest
	}
	return ExitRequest{}
}

// SharesTotalEntry tracks total shares for a vault type
type SharesTotalEntry struct {
	// Total shares issued
	TotalShares cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_shares,json=totalShares,proto3,customtype=cosmossdk.io/math.Int" json:"total_shares"`
	// Total NAV (Net Asset Value)
	TotalNav cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_nav,json=totalNav,proto3,customtype=cosmossdk.io/math.Int" json:"total_nav"`
}

func (m *SharesTotalEntry) Reset()         { *m = SharesTotalEntry{} }
func (m *SharesTotalEntry) String() string { return proto.CompactTextString(m) }
func (*SharesTotalEntry) ProtoMessage()    {}
func (*SharesTotalEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{7}
}
func (m *SharesTotalEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SharesTotalEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SharesTotalEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SharesTotalEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SharesTotalEntry.Merge(m, src)
}
func (m *SharesTotalEntry) XXX_Size() int {
	return m.Size()
}
func (m *SharesTotalEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SharesTotalEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SharesTotalEntry proto.InternalMessageInfo

// VaultStatsEntry tracks statistics for a vault type
type VaultStatsEntry struct {
	// Total number of depositors
	TotalDepositors uint64 `protobuf:"varint,1,opt,name=total_depositors,json=totalDepositors,proto3" json:"total_depositors,omitempty"`
	// Total value deposited (cumulative)
	TotalDeposited cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_deposited,json=totalDeposited,proto3,customtype=cosmossdk.io/math.Int" json:"total_deposited"`
	// Total value withdrawn (cumulative)
	TotalWithdrawn cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_withdrawn,json=totalWithdrawn,proto3,customtype=cosmossdk.io/math.Int" json:"total_withdrawn"`
	// Total fees collected
	TotalFeesCollected cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=total_fees_collected,json=totalFeesCollected,proto3,customtype=cosmossdk.io/math.Int" json:"total_fees_collected"`
	// Total yield distributed
	TotalYieldDistributed cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=total_yield_distributed,json=totalYieldDistributed,proto3,customtype=cosmossdk.io/math.Int" json:"total_yield_distributed"`
	// Number of active positions
	ActivePositions uint64 `protobuf:"varint,6,opt,name=active_positions,json=activePositions,proto3" json:"active_positions,omitempty"`
	// Average position size
	AveragePositionSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=average_position_size,json=averagePositionSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"average_position_size"`
}

func (m *VaultStatsEntry) Reset()         { *m = VaultStatsEntry{} }
func (m *VaultStatsEntry) String() string { return proto.CompactTextString(m) }
func (*VaultStatsEntry) ProtoMessage()    {}
func (*VaultStatsEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{8}
}
func (m *VaultStatsEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultStatsEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VaultStatsEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VaultStatsEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultStatsEntry.Merge(m, src)
}
func (m *VaultStatsEntry) XXX_Size() int {
	return m.Size()
}
func (m *VaultStatsEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultStatsEntry.DiscardUnknown(m)
}

var xxx_messageInfo_VaultStatsEntry proto.InternalMessageInfo

func (m *VaultStatsEntry) GetTotalDepositors() uint64 {
	if m != nil {
		return m.TotalDepositors
	}
	return 0
}

func (m *VaultStatsEntry) GetActivePositions() uint64 {
	if m != nil {
		return m.ActivePositions
	}
	return 0
}

func init() {
	proto.RegisterType((*GenesisState)(nil), "noble.dollar.vaults.v2.GenesisState")
	proto.RegisterType((*Params)(nil), "noble.dollar.vaults.v2.Params")
	proto.RegisterType((*VaultConfig)(nil), "noble.dollar.vaults.v2.VaultConfig")
	proto.RegisterType((*UserPositionEntry)(nil), "noble.dollar.vaults.v2.UserPositionEntry")
	proto.RegisterType((*NAVEntry)(nil), "noble.dollar.vaults.v2.NAVEntry")
	proto.RegisterType((*FeeConfigEntry)(nil), "noble.dollar.vaults.v2.FeeConfigEntry")
	proto.RegisterType((*ExitRequestEntry)(nil), "noble.dollar.vaults.v2.ExitRequestEntry")
	proto.RegisterType((*SharesTotalEntry)(nil), "noble.dollar.vaults.v2.SharesTotalEntry")
	proto.RegisterType((*VaultStatsEntry)(nil), "noble.dollar.vaults.v2.VaultStatsEntry")
}

func init() {
	proto.RegisterFile("noble/dollar/vaults/v2/genesis.proto", fileDescriptor_a687c7a1c262a427)
}

var fileDescriptor_a687c7a1c262a427 = []byte{
	// 1194 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x96, 0x4f, 0x6f, 0x13, 0x47,
	0x18, 0xc6, 0x63, 0xe2, 0x38, 0xce, 0xd8, 0x24, 0xce, 0x90, 0x94, 0x2d, 0x48, 0xc6, 0x38, 0xb4,
	0x35, 0x6d, 0xb1, 0xa9, 0x2b, 0xd1, 0x0b, 0x48, 0x25, 0x24, 0x41, 0x48, 0x10, 0xa5, 0x36, 0xa5,
	0xa5, 0x87, 0xae, 0xc6, 0xde, 0xd7, 0xf6, 0x14, 0xef, 0x8c, 0xd9, 0x19, 0x2f, 0x76, 0x4e, 0xfd,
	0x08, 0xfd, 0x18, 0x3d, 0xf6, 0x80, 0xfa, 0x01, 0x7a, 0xe2, 0x88, 0xb8, 0xb4, 0xea, 0x01, 0x55,
	0x70, 0xe8, 0x07, 0xe8, 0x17, 0xa8, 0xe6, 0xcf, 0x7a, 0xd7, 0x49, 0x9c, 0x52, 0x5f, 0x2c, 0xef,
	0xcc, 0x3b, 0xbf, 0xf7, 0x9d, 0x9d, 0xe7, 0x7d, 0x76, 0xd0, 0x15, 0xc6, 0x5b, 0x7d, 0xa8, 0x79,
	0xbc, 0xdf, 0x27, 0x41, 0x2d, 0x24, 0xc3, 0xbe, 0x14, 0xb5, 0xb0, 0x5e, 0xeb, 0x02, 0x03, 0x41,
	0x45, 0x75, 0x10, 0x70, 0xc9, 0xf1, 0x7b, 0x3a, 0xaa, 0x6a, 0xa2, 0xaa, 0x26, 0xaa, 0x1a, 0xd6,
	0x2f, 0xac, 0x13, 0x9f, 0x32, 0x5e, 0xd3, 0xbf, 0x26, 0xf4, 0xc2, 0xfb, 0x6d, 0x2e, 0x7c, 0x2e,
	0x5c, 0xfd, 0x54, 0x33, 0x0f, 0x76, 0x6a, 0xa3, 0xcb, 0xbb, 0xdc, 0x8c, 0xab, 0x7f, 0x76, 0x74,
	0xeb, 0xc4, 0x0a, 0x3e, 0xb3, 0xff, 0x6c, 0xd0, 0xe5, 0x19, 0x65, 0x76, 0x00, 0xa2, 0x90, 0xd2,
	0x8c, 0x10, 0x46, 0xc2, 0x53, 0x33, 0xd5, 0xa7, 0x32, 0x95, 0x7f, 0x5c, 0x42, 0xf9, 0xbb, 0x66,
	0xf3, 0x4d, 0x49, 0x24, 0xe0, 0x9b, 0x28, 0x33, 0x20, 0x01, 0xf1, 0x85, 0x93, 0x2a, 0xa5, 0x2a,
	0xb9, 0x7a, 0xb1, 0x7a, 0xf2, 0xcb, 0xa8, 0x1e, 0xe8, 0xa8, 0xed, 0xf4, 0x8b, 0xd7, 0x97, 0x16,
	0x1a, 0x76, 0x0d, 0xde, 0x47, 0x67, 0x75, 0x84, 0xdb, 0xe6, 0xac, 0x43, 0xbb, 0xc2, 0x39, 0x53,
	0x5a, 0xac, 0xe4, 0xea, 0x5b, 0xb3, 0x20, 0x8f, 0xd4, 0xbf, 0x3b, 0x3a, 0xd6, 0x92, 0xf2, 0x61,
	0x3c, 0x24, 0xf0, 0x23, 0xb4, 0x3a, 0x14, 0x10, 0xb8, 0x03, 0x2e, 0xa8, 0xa4, 0x9c, 0x09, 0x67,
	0x51, 0x03, 0xaf, 0xce, 0x02, 0x7e, 0x2d, 0x20, 0x38, 0xb0, 0xc1, 0xbb, 0x4c, 0x06, 0x63, 0x8b,
	0x3d, 0x3b, 0x4c, 0x4c, 0x08, 0x7c, 0x17, 0xe5, 0x18, 0x09, 0x5d, 0x60, 0x32, 0xa0, 0x20, 0x9c,
	0xb4, 0x86, 0x96, 0x66, 0x41, 0xf7, 0x6f, 0x3f, 0x4a, 0xb2, 0x10, 0x23, 0xe1, 0xae, 0x59, 0x89,
	0x1f, 0xa0, 0x5c, 0x07, 0x60, 0xb2, 0xdd, 0x25, 0x0d, 0xfa, 0x70, 0x16, 0x68, 0x0f, 0xc0, 0xec,
	0x6c, 0x0a, 0xd7, 0x89, 0x46, 0x15, 0x0e, 0xc1, 0x88, 0x4a, 0xf7, 0xe9, 0x10, 0x86, 0xe0, 0x64,
	0x34, 0xad, 0x32, 0x8b, 0xb6, 0x3b, 0xa2, 0xb2, 0x01, 0x4f, 0x87, 0x20, 0x64, 0x92, 0xb7, 0xa2,
	0x08, 0x5f, 0x29, 0x00, 0x6e, 0xa2, 0xb3, 0xa2, 0x47, 0x02, 0x10, 0xae, 0xe4, 0x92, 0xf4, 0x85,
	0xb3, 0x7c, 0x3a, 0xb1, 0xa9, 0x83, 0x1f, 0xaa, 0xd8, 0x24, 0x31, 0x2f, 0xe2, 0x71, 0x75, 0xc6,
	0x39, 0x73, 0xc6, 0x42, 0x12, 0x29, 0x9c, 0xac, 0x46, 0x7e, 0x74, 0xea, 0x09, 0x2b, 0x69, 0x89,
	0xa9, 0x3d, 0x87, 0x93, 0xe1, 0xf2, 0x6f, 0x69, 0x94, 0x31, 0x62, 0xc2, 0x37, 0xd0, 0x0a, 0x19,
	0xca, 0x1e, 0x0f, 0xa8, 0x1c, 0x6b, 0xfd, 0xad, 0x6c, 0x3b, 0xaf, 0x9e, 0x5f, 0xdb, 0xb0, 0x7d,
	0x75, 0xdb, 0xf3, 0x02, 0x10, 0xa2, 0x29, 0x03, 0xca, 0xba, 0x8d, 0x38, 0x14, 0x7f, 0x81, 0x1c,
	0x0f, 0x3a, 0xba, 0x28, 0x0f, 0xb4, 0x56, 0x5c, 0x75, 0x2a, 0x01, 0x91, 0xe0, 0x9c, 0x29, 0xa5,
	0x2a, 0x4b, 0x8d, 0x4d, 0x3b, 0xbf, 0x63, 0xa6, 0xf7, 0x00, 0x1a, 0x4a, 0xed, 0xb7, 0xd0, 0xc5,
	0x68, 0xe1, 0x33, 0x2a, 0x7b, 0x5e, 0x40, 0x9e, 0x91, 0x7e, 0xbc, 0x76, 0x51, 0xaf, 0x8d, 0xd8,
	0xdf, 0x4c, 0x22, 0xa2, 0xe5, 0xdf, 0x23, 0xec, 0x53, 0x36, 0xc9, 0x49, 0x7c, 0x3e, 0x64, 0xd2,
	0x49, 0xeb, 0xc2, 0xaf, 0xab, 0x8d, 0xfe, 0xf9, 0xfa, 0xd2, 0xa6, 0x29, 0x5e, 0x78, 0x4f, 0xaa,
	0x94, 0xd7, 0x7c, 0x22, 0x7b, 0xd5, 0x7b, 0x4c, 0xbe, 0x7a, 0x7e, 0x0d, 0xd9, 0x5d, 0xdd, 0x63,
	0xf2, 0xe7, 0xbf, 0x7f, 0xf9, 0x38, 0xd5, 0x28, 0xf8, 0x94, 0xd9, 0xfa, 0x6e, 0x6b, 0x12, 0xf6,
	0xd0, 0xa6, 0xe2, 0x27, 0x4a, 0xb3, 0x29, 0x96, 0xe6, 0x4c, 0x71, 0xce, 0xa7, 0x2c, 0xde, 0x86,
	0xcd, 0xf2, 0x09, 0xc2, 0x3e, 0x19, 0xb9, 0xaa, 0x21, 0xda, 0x3d, 0xc2, 0xba, 0xe0, 0xb6, 0x06,
	0xc2, 0xc9, 0xe8, 0xbd, 0xaf, 0xf9, 0x64, 0xb4, 0x4f, 0xc2, 0x3b, 0x7a, 0x7c, 0x7b, 0x20, 0xf0,
	0x75, 0xb4, 0xa1, 0x15, 0x1a, 0x18, 0xe1, 0xb9, 0x92, 0xfa, 0xc0, 0x87, 0xd2, 0x59, 0x2e, 0xa5,
	0x2a, 0x8b, 0x0d, 0x0c, 0xb1, 0x26, 0x1f, 0x9a, 0x19, 0x7c, 0x13, 0x5d, 0x54, 0xf8, 0xe4, 0x2a,
	0xe1, 0x0e, 0x20, 0x70, 0x5b, 0x7d, 0xde, 0x7e, 0xe2, 0x64, 0x75, 0x9e, 0xf3, 0x3e, 0x19, 0x25,
	0xf4, 0x2c, 0x0e, 0x20, 0xd8, 0x56, 0xd3, 0xf8, 0x03, 0xb4, 0x6a, 0xc4, 0xe4, 0x02, 0x23, 0xad,
	0x3e, 0x78, 0xce, 0x4a, 0x29, 0x55, 0xc9, 0x36, 0x8c, 0xcf, 0x88, 0x5d, 0x33, 0x58, 0xfe, 0xe7,
	0x0c, 0xca, 0x25, 0xcc, 0x04, 0x3b, 0x68, 0x39, 0x8a, 0x4f, 0xe9, 0xf8, 0xe8, 0x11, 0x7f, 0x6a,
	0xce, 0x4c, 0x48, 0xf2, 0x84, 0xb2, 0xae, 0x2a, 0x84, 0x72, 0x4f, 0xab, 0x64, 0x51, 0x9f, 0x40,
	0xd3, 0x4c, 0x1c, 0xe8, 0x71, 0x5c, 0x41, 0x85, 0x63, 0x8a, 0x32, 0xaa, 0x58, 0xf5, 0xa6, 0xa5,
	0x54, 0x45, 0xe7, 0x4e, 0x92, 0x50, 0x5a, 0x07, 0xaf, 0x3f, 0x3b, 0x51, 0x3b, 0x64, 0x64, 0x1a,
	0x33, 0x52, 0x90, 0x98, 0xfb, 0x60, 0x0b, 0x3e, 0x19, 0xe9, 0xfe, 0xb4, 0x02, 0x12, 0xb8, 0x85,
	0xd6, 0x25, 0x09, 0xba, 0x20, 0xdd, 0x31, 0x85, 0xbe, 0x67, 0xaa, 0xc9, 0x68, 0xfc, 0x0d, 0x8b,
	0xbf, 0x78, 0x1c, 0x7f, 0x1f, 0xba, 0xa4, 0x3d, 0xde, 0x81, 0x76, 0x22, 0xc9, 0x0e, 0xb4, 0x4d,
	0x92, 0x35, 0x03, 0x7c, 0xac, 0x78, 0x6a, 0x0f, 0xe5, 0x21, 0x5a, 0x3f, 0x66, 0xb8, 0xea, 0xd5,
	0x13, 0xd3, 0xa8, 0xfa, 0xd5, 0xe7, 0x1b, 0xd1, 0x23, 0xde, 0x43, 0xd9, 0xc8, 0xc8, 0xf5, 0x0b,
	0xcf, 0xd5, 0xaf, 0xbc, 0x8b, 0x8f, 0x5b, 0xcf, 0x98, 0xac, 0x2d, 0xdf, 0x47, 0xd9, 0xc8, 0x92,
	0xf1, 0x97, 0x28, 0xab, 0x84, 0x4b, 0x59, 0x87, 0xdb, 0x2f, 0xd6, 0xa5, 0x53, 0x6c, 0xfc, 0x1e,
	0xeb, 0x70, 0x8b, 0x5b, 0x66, 0x24, 0x54, 0x8f, 0xe5, 0x6f, 0xd1, 0xea, 0xb4, 0x2f, 0xe3, 0x3d,
	0x84, 0x62, 0x53, 0xb7, 0xd4, 0xcb, 0xff, 0xe9, 0xe9, 0x91, 0xfd, 0x4e, 0xec, 0xbc, 0x7c, 0x88,
	0x0a, 0x47, 0x3d, 0xfa, 0x94, 0xb7, 0x73, 0x1f, 0xe5, 0x93, 0x3d, 0x62, 0xdf, 0xd0, 0xd6, 0x3b,
	0xb8, 0xbf, 0xcd, 0x9c, 0x4b, 0x34, 0x5f, 0xf9, 0xd7, 0x14, 0x2a, 0x1c, 0xb5, 0x73, 0xdc, 0x44,
	0x79, 0xa3, 0x37, 0x63, 0xe8, 0xd6, 0x62, 0xff, 0xbf, 0xda, 0x72, 0x9a, 0x62, 0xf0, 0xf8, 0x01,
	0x5a, 0x31, 0x50, 0x46, 0x42, 0x5d, 0xf4, 0x3c, 0xc4, 0xac, 0x46, 0xec, 0x93, 0xb0, 0xfc, 0x7b,
	0x1a, 0xad, 0x1d, 0xf9, 0x68, 0xe0, 0xab, 0xa8, 0x30, 0xd5, 0x27, 0x3c, 0x30, 0xb5, 0xa7, 0x1b,
	0x6b, 0x32, 0x21, 0x7a, 0x1e, 0x08, 0xfc, 0x18, 0xad, 0x4d, 0x85, 0x82, 0x37, 0x77, 0x4d, 0xab,
	0x49, 0x36, 0x78, 0x31, 0x3a, 0x6a, 0x66, 0xa6, 0xad, 0x60, 0x7e, 0x74, 0xe4, 0xc4, 0x0c, 0xb7,
	0xd0, 0x86, 0x41, 0xab, 0x1b, 0x9e, 0xdb, 0xe6, 0xfd, 0x3e, 0xb4, 0x55, 0xe9, 0xf3, 0x7e, 0x4a,
	0xb0, 0xa6, 0xed, 0x01, 0x88, 0x3b, 0x11, 0x0b, 0xf7, 0xd0, 0x79, 0x93, 0xc3, 0xf8, 0x81, 0x47,
	0x85, 0x0c, 0x68, 0x6b, 0xa8, 0xd2, 0xcc, 0xeb, 0x3a, 0x9b, 0x1a, 0xa8, 0xfd, 0x60, 0x27, 0xc6,
	0xa9, 0xe3, 0x22, 0x6d, 0x49, 0x43, 0x48, 0xdc, 0xdb, 0x32, 0xe6, 0xb8, 0xcc, 0x78, 0x7c, 0x11,
	0xfb, 0x01, 0x6d, 0x92, 0x10, 0x02, 0xd2, 0x8d, 0x63, 0x5d, 0x41, 0x0f, 0x41, 0x7f, 0x4f, 0xe6,
	0x77, 0xaa, 0x73, 0x16, 0x1a, 0x25, 0x6a, 0xd2, 0x43, 0xd8, 0xbe, 0xf5, 0xe2, 0x4d, 0x31, 0xf5,
	0xf2, 0x4d, 0x31, 0xf5, 0xd7, 0x9b, 0x62, 0xea, 0xa7, 0xb7, 0xc5, 0x85, 0x97, 0x6f, 0x8b, 0x0b,
	0x7f, 0xbc, 0x2d, 0x2e, 0x7c, 0xb7, 0x65, 0xbb, 0xcb, 0xb4, 0xda, 0x68, 0x7c, 0xa8, 0xee, 0xc9,
	0x72, 0x3c, 0x00, 0x11, 0xdf, 0x9b, 0x5b, 0x19, 0x7d, 0x63, 0xfe, 0xfc, 0xdf, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x86, 0x0b, 0x5b, 0xb1, 0x44, 0x0c, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VaultStats) > 0 {
		for iNdEx := len(m.VaultStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VaultStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SharesTotals) > 0 {
		for iNdEx := len(m.SharesTotals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SharesTotals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ExitQueue) > 0 {
		for iNdEx := len(m.ExitQueue) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExitQueue[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.FeeConfigs) > 0 {
		for iNdEx := len(m.FeeConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeeConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NavEntries) > 0 {
		for iNdEx := len(m.NavEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NavEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.UserPositions) > 0 {
		for iNdEx := len(m.UserPositions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserPositions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.VaultConfigs) > 0 {
		for iNdEx := len(m.VaultConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VaultConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VaultsEnabled {
		i--
		if m.VaultsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.MaxExitRequestsPerBlock != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.MaxExitRequestsPerBlock))
		i--
		dAtA[i] = 0x40
	}
	if m.ExitRequestTimeout != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.ExitRequestTimeout))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxNavChangeBps != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.MaxNavChangeBps))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.MinWithdrawalAmount.Size()
		i -= size
		if _, err := m.MinWithdrawalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.MinDepositAmount.Size()
		i -= size
		if _, err := m.MinDepositAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.DefaultWithdrawalFeeRate != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.DefaultWithdrawalFeeRate))
		i--
		dAtA[i] = 0x18
	}
	if m.DefaultDepositFeeRate != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.DefaultDepositFeeRate))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TargetYieldRate.Size()
		i -= size
		if _, err := m.TargetYieldRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.MaxTotalDeposits.Size()
		i -= size
		if _, err := m.MaxTotalDeposits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.WithdrawalFeeRate != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.WithdrawalFeeRate))
		i--
		dAtA[i] = 0x20
	}
	if m.DepositFeeRate != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.DepositFeeRate))
		i--
		dAtA[i] = 0x18
	}
	if m.MinStakingPeriod != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.MinStakingPeriod))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserPositionEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPositionEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPositionEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NAVEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NAVEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NAVEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.NavInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeeConfigEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeConfigEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeConfigEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FeeConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ExitRequestEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExitRequestEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExitRequestEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ExitRequest.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SharesTotalEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SharesTotalEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SharesTotalEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalNav.Size()
		i -= size
		if _, err := m.TotalNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalShares.Size()
		i -= size
		if _, err := m.TotalShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *VaultStatsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultStatsEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultStatsEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AveragePositionSize.Size()
		i -= size
		if _, err := m.AveragePositionSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.ActivePositions != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.ActivePositions))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.TotalYieldDistributed.Size()
		i -= size
		if _, err := m.TotalYieldDistributed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.TotalFeesCollected.Size()
		i -= size
		if _, err := m.TotalFeesCollected.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalWithdrawn.Size()
		i -= size
		if _, err := m.TotalWithdrawn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalDeposited.Size()
		i -= size
		if _, err := m.TotalDeposited.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TotalDepositors != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.TotalDepositors))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenesis(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if len(m.VaultConfigs) > 0 {
		for _, e := range m.VaultConfigs {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.UserPositions) > 0 {
		for _, e := range m.UserPositions {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.NavEntries) > 0 {
		for _, e := range m.NavEntries {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.FeeConfigs) > 0 {
		for _, e := range m.FeeConfigs {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.ExitQueue) > 0 {
		for _, e := range m.ExitQueue {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.SharesTotals) > 0 {
		for _, e := range m.SharesTotals {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.VaultStats) > 0 {
		for _, e := range m.VaultStats {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	if m.DefaultDepositFeeRate != 0 {
		n += 1 + sovGenesis(uint64(m.DefaultDepositFeeRate))
	}
	if m.DefaultWithdrawalFeeRate != 0 {
		n += 1 + sovGenesis(uint64(m.DefaultWithdrawalFeeRate))
	}
	l = m.MinDepositAmount.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.MinWithdrawalAmount.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if m.MaxNavChangeBps != 0 {
		n += 1 + sovGenesis(uint64(m.MaxNavChangeBps))
	}
	if m.ExitRequestTimeout != 0 {
		n += 1 + sovGenesis(uint64(m.ExitRequestTimeout))
	}
	if m.MaxExitRequestsPerBlock != 0 {
		n += 1 + sovGenesis(uint64(m.MaxExitRequestsPerBlock))
	}
	if m.VaultsEnabled {
		n += 2
	}
	return n
}

func (m *VaultConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.MinStakingPeriod != 0 {
		n += 1 + sovGenesis(uint64(m.MinStakingPeriod))
	}
	if m.DepositFeeRate != 0 {
		n += 1 + sovGenesis(uint64(m.DepositFeeRate))
	}
	if m.WithdrawalFeeRate != 0 {
		n += 1 + sovGenesis(uint64(m.WithdrawalFeeRate))
	}
	l = m.MaxTotalDeposits.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TargetYieldRate.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *UserPositionEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.Position.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *NAVEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.NavInfo.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *FeeConfigEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FeeConfig.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *ExitRequestEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.ExitRequest.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *SharesTotalEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalShares.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalNav.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *VaultStatsEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalDepositors != 0 {
		n += 1 + sovGenesis(uint64(m.TotalDepositors))
	}
	l = m.TotalDeposited.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalWithdrawn.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalFeesCollected.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalYieldDistributed.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if m.ActivePositions != 0 {
		n += 1 + sovGenesis(uint64(m.ActivePositions))
	}
	l = m.AveragePositionSize.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func sovGenesis(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenesis(x uint64) (n int) {
	return sovGenesis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultConfigs = append(m.VaultConfigs, VaultConfig{})
			if err := m.VaultConfigs[len(m.VaultConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPositions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserPositions = append(m.UserPositions, UserPositionEntry{})
			if err := m.UserPositions[len(m.UserPositions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NavEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NavEntries = append(m.NavEntries, NAVEntry{})
			if err := m.NavEntries[len(m.NavEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeConfigs = append(m.FeeConfigs, FeeConfigEntry{})
			if err := m.FeeConfigs[len(m.FeeConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExitQueue = append(m.ExitQueue, ExitRequestEntry{})
			if err := m.ExitQueue[len(m.ExitQueue)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesTotals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SharesTotals = append(m.SharesTotals, SharesTotalEntry{})
			if err := m.SharesTotals[len(m.SharesTotals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultStats = append(m.VaultStats, VaultStatsEntry{})
			if err := m.VaultStats[len(m.VaultStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultDepositFeeRate", wireType)
			}
			m.DefaultDepositFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultDepositFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultWithdrawalFeeRate", wireType)
			}
			m.DefaultWithdrawalFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultWithdrawalFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDepositAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinDepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinWithdrawalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinWithdrawalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNavChangeBps", wireType)
			}
			m.MaxNavChangeBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNavChangeBps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitRequestTimeout", wireType)
			}
			m.ExitRequestTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitRequestTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxExitRequestsPerBlock", wireType)
			}
			m.MaxExitRequestsPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxExitRequestsPerBlock |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VaultsEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinStakingPeriod", wireType)
			}
			m.MinStakingPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinStakingPeriod |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositFeeRate", wireType)
			}
			m.DepositFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepositFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawalFeeRate", wireType)
			}
			m.WithdrawalFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithdrawalFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTotalDeposits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxTotalDeposits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetYieldRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetYieldRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPositionEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPositionEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPositionEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NAVEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NAVEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NAVEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NavInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NavInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeConfigEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeConfigEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeConfigEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeeConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExitRequestEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExitRequestEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExitRequestEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExitRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SharesTotalEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SharesTotalEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SharesTotalEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultStatsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultStatsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultStatsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDepositors", wireType)
			}
			m.TotalDepositors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDepositors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposited", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalDeposited.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFeesCollected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalFeesCollected.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalYieldDistributed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalYieldDistributed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePositions", wireType)
			}
			m.ActivePositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivePositions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AveragePositionSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AveragePositionSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenesis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenesis
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenesis
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenesis
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
