// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/tx.proto

package v2

import (
	context "context"
	cosmossdk_io_math "cosmossdk.io/math"
	vaults "dollar.noble.xyz/v2/types/vaults"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgDeposit allows users to deposit into a V2 vault
type MsgDeposit struct {
	// User making the deposit
	Depositor string `protobuf:"bytes,1,opt,name=depositor,proto3" json:"depositor,omitempty"`
	// Vault type to deposit into
	VaultType vaults.VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// Amount to deposit
	Amount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// Whether user wants to receive yield
	ReceiveYield bool `protobuf:"varint,4,opt,name=receive_yield,json=receiveYield,proto3" json:"receive_yield,omitempty"`
	// Minimum shares to receive (slippage protection)
	MinShares cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=min_shares,json=minShares,proto3,customtype=cosmossdk.io/math.Int" json:"min_shares"`
}

func (m *MsgDeposit) Reset()         { *m = MsgDeposit{} }
func (m *MsgDeposit) String() string { return proto.CompactTextString(m) }
func (*MsgDeposit) ProtoMessage()    {}
func (*MsgDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{0}
}
func (m *MsgDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeposit.Merge(m, src)
}
func (m *MsgDeposit) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeposit proto.InternalMessageInfo

// MsgDepositResponse returns the results of a deposit
type MsgDepositResponse struct {
	// Shares received
	SharesReceived cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=shares_received,json=sharesReceived,proto3,customtype=cosmossdk.io/math.Int" json:"shares_received"`
	// Amount actually deposited (after fees)
	AmountDeposited cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount_deposited,json=amountDeposited,proto3,customtype=cosmossdk.io/math.Int" json:"amount_deposited"`
	// Fees paid
	FeesPaid cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=fees_paid,json=feesPaid,proto3,customtype=cosmossdk.io/math.Int" json:"fees_paid"`
	// Share price at time of deposit
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
}

func (m *MsgDepositResponse) Reset()         { *m = MsgDepositResponse{} }
func (m *MsgDepositResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDepositResponse) ProtoMessage()    {}
func (*MsgDepositResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{1}
}
func (m *MsgDepositResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositResponse.Merge(m, src)
}
func (m *MsgDepositResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositResponse proto.InternalMessageInfo

// MsgWithdraw allows users to withdraw from flexible V2 vaults
type MsgWithdraw struct {
	// User making the withdrawal
	Withdrawer string `protobuf:"bytes,1,opt,name=withdrawer,proto3" json:"withdrawer,omitempty"`
	// Vault type to withdraw from
	VaultType vaults.VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// Shares to redeem
	Shares cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=shares,proto3,customtype=cosmossdk.io/math.Int" json:"shares"`
	// Minimum amount to receive (slippage protection)
	MinAmount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=min_amount,json=minAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_amount"`
}

func (m *MsgWithdraw) Reset()         { *m = MsgWithdraw{} }
func (m *MsgWithdraw) String() string { return proto.CompactTextString(m) }
func (*MsgWithdraw) ProtoMessage()    {}
func (*MsgWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{2}
}
func (m *MsgWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdraw.Merge(m, src)
}
func (m *MsgWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdraw proto.InternalMessageInfo

// MsgWithdrawResponse returns the results of a withdrawal
type MsgWithdrawResponse struct {
	// Amount withdrawn
	AmountWithdrawn cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=amount_withdrawn,json=amountWithdrawn,proto3,customtype=cosmossdk.io/math.Int" json:"amount_withdrawn"`
	// Shares redeemed
	SharesRedeemed cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=shares_redeemed,json=sharesRedeemed,proto3,customtype=cosmossdk.io/math.Int" json:"shares_redeemed"`
	// Fees paid
	FeesPaid cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=fees_paid,json=feesPaid,proto3,customtype=cosmossdk.io/math.Int" json:"fees_paid"`
	// Share price at time of withdrawal
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
}

func (m *MsgWithdrawResponse) Reset()         { *m = MsgWithdrawResponse{} }
func (m *MsgWithdrawResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawResponse) ProtoMessage()    {}
func (*MsgWithdrawResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{3}
}
func (m *MsgWithdrawResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawResponse.Merge(m, src)
}
func (m *MsgWithdrawResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawResponse proto.InternalMessageInfo

// MsgRequestExit allows users to request exit from staked vaults
type MsgRequestExit struct {
	// User requesting exit
	Requester string `protobuf:"bytes,1,opt,name=requester,proto3" json:"requester,omitempty"`
	// Vault type to exit from
	VaultType vaults.VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// Shares to exit
	Shares cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=shares,proto3,customtype=cosmossdk.io/math.Int" json:"shares"`
}

func (m *MsgRequestExit) Reset()         { *m = MsgRequestExit{} }
func (m *MsgRequestExit) String() string { return proto.CompactTextString(m) }
func (*MsgRequestExit) ProtoMessage()    {}
func (*MsgRequestExit) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{4}
}
func (m *MsgRequestExit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestExit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestExit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestExit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestExit.Merge(m, src)
}
func (m *MsgRequestExit) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestExit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestExit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestExit proto.InternalMessageInfo

// MsgRequestExitResponse returns the results of an exit request
type MsgRequestExitResponse struct {
	// Exit request ID
	ExitRequestId string `protobuf:"bytes,1,opt,name=exit_request_id,json=exitRequestId,proto3" json:"exit_request_id,omitempty"`
	// Shares to be exited
	SharesToExit cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=shares_to_exit,json=sharesToExit,proto3,customtype=cosmossdk.io/math.Int" json:"shares_to_exit"`
	// Expected unlock time
	ExpectedUnlockTime time.Time `protobuf:"bytes,3,opt,name=expected_unlock_time,json=expectedUnlockTime,proto3,stdtime" json:"expected_unlock_time"`
	// Estimated amount to receive (subject to change)
	EstimatedAmount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=estimated_amount,json=estimatedAmount,proto3,customtype=cosmossdk.io/math.Int" json:"estimated_amount"`
}

func (m *MsgRequestExitResponse) Reset()         { *m = MsgRequestExitResponse{} }
func (m *MsgRequestExitResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRequestExitResponse) ProtoMessage()    {}
func (*MsgRequestExitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{5}
}
func (m *MsgRequestExitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestExitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestExitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestExitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestExitResponse.Merge(m, src)
}
func (m *MsgRequestExitResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestExitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestExitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestExitResponse proto.InternalMessageInfo

func (m *MsgRequestExitResponse) GetExitRequestId() string {
	if m != nil {
		return m.ExitRequestId
	}
	return ""
}

func (m *MsgRequestExitResponse) GetExpectedUnlockTime() time.Time {
	if m != nil {
		return m.ExpectedUnlockTime
	}
	return time.Time{}
}

// MsgCancelExit allows users to cancel pending exit requests
type MsgCancelExit struct {
	// User cancelling the exit request
	Requester string `protobuf:"bytes,1,opt,name=requester,proto3" json:"requester,omitempty"`
	// Vault type
	VaultType vaults.VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// Exit request ID to cancel
	ExitRequestId string `protobuf:"bytes,3,opt,name=exit_request_id,json=exitRequestId,proto3" json:"exit_request_id,omitempty"`
}

func (m *MsgCancelExit) Reset()         { *m = MsgCancelExit{} }
func (m *MsgCancelExit) String() string { return proto.CompactTextString(m) }
func (*MsgCancelExit) ProtoMessage()    {}
func (*MsgCancelExit) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{6}
}
func (m *MsgCancelExit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelExit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelExit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelExit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelExit.Merge(m, src)
}
func (m *MsgCancelExit) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelExit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelExit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelExit proto.InternalMessageInfo

// MsgCancelExitResponse returns the results of cancelling an exit request
type MsgCancelExitResponse struct {
	// Shares returned to staking
	SharesReturned cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=shares_returned,json=sharesReturned,proto3,customtype=cosmossdk.io/math.Int" json:"shares_returned"`
	// Exit request ID that was cancelled
	CancelledExitRequestId string `protobuf:"bytes,2,opt,name=cancelled_exit_request_id,json=cancelledExitRequestId,proto3" json:"cancelled_exit_request_id,omitempty"`
}

func (m *MsgCancelExitResponse) Reset()         { *m = MsgCancelExitResponse{} }
func (m *MsgCancelExitResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelExitResponse) ProtoMessage()    {}
func (*MsgCancelExitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{7}
}
func (m *MsgCancelExitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelExitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelExitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelExitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelExitResponse.Merge(m, src)
}
func (m *MsgCancelExitResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelExitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelExitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelExitResponse proto.InternalMessageInfo

func (m *MsgCancelExitResponse) GetCancelledExitRequestId() string {
	if m != nil {
		return m.CancelledExitRequestId
	}
	return ""
}

// MsgSetYieldPreference allows users to set their yield preference
type MsgSetYieldPreference struct {
	// User setting the preference
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// Vault type
	VaultType vaults.VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// Whether to receive yield
	ReceiveYield bool `protobuf:"varint,3,opt,name=receive_yield,json=receiveYield,proto3" json:"receive_yield,omitempty"`
}

func (m *MsgSetYieldPreference) Reset()         { *m = MsgSetYieldPreference{} }
func (m *MsgSetYieldPreference) String() string { return proto.CompactTextString(m) }
func (*MsgSetYieldPreference) ProtoMessage()    {}
func (*MsgSetYieldPreference) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{8}
}
func (m *MsgSetYieldPreference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetYieldPreference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetYieldPreference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetYieldPreference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetYieldPreference.Merge(m, src)
}
func (m *MsgSetYieldPreference) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetYieldPreference) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetYieldPreference.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetYieldPreference proto.InternalMessageInfo

// MsgSetYieldPreferenceResponse confirms yield preference update
type MsgSetYieldPreferenceResponse struct {
	// Previous yield preference
	PreviousPreference bool `protobuf:"varint,1,opt,name=previous_preference,json=previousPreference,proto3" json:"previous_preference,omitempty"`
	// New yield preference
	NewPreference bool `protobuf:"varint,2,opt,name=new_preference,json=newPreference,proto3" json:"new_preference,omitempty"`
}

func (m *MsgSetYieldPreferenceResponse) Reset()         { *m = MsgSetYieldPreferenceResponse{} }
func (m *MsgSetYieldPreferenceResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetYieldPreferenceResponse) ProtoMessage()    {}
func (*MsgSetYieldPreferenceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{9}
}
func (m *MsgSetYieldPreferenceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetYieldPreferenceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetYieldPreferenceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetYieldPreferenceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetYieldPreferenceResponse.Merge(m, src)
}
func (m *MsgSetYieldPreferenceResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetYieldPreferenceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetYieldPreferenceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetYieldPreferenceResponse proto.InternalMessageInfo

func (m *MsgSetYieldPreferenceResponse) GetPreviousPreference() bool {
	if m != nil {
		return m.PreviousPreference
	}
	return false
}

func (m *MsgSetYieldPreferenceResponse) GetNewPreference() bool {
	if m != nil {
		return m.NewPreference
	}
	return false
}

// MsgProcessExitQueue allows processing of exit requests (admin only)
type MsgProcessExitQueue struct {
	// Authority processing the queue
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Vault type to process
	VaultType vaults.VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// Maximum number of requests to process
	MaxRequests int32 `protobuf:"varint,3,opt,name=max_requests,json=maxRequests,proto3" json:"max_requests,omitempty"`
}

func (m *MsgProcessExitQueue) Reset()         { *m = MsgProcessExitQueue{} }
func (m *MsgProcessExitQueue) String() string { return proto.CompactTextString(m) }
func (*MsgProcessExitQueue) ProtoMessage()    {}
func (*MsgProcessExitQueue) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{10}
}
func (m *MsgProcessExitQueue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProcessExitQueue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProcessExitQueue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProcessExitQueue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProcessExitQueue.Merge(m, src)
}
func (m *MsgProcessExitQueue) XXX_Size() int {
	return m.Size()
}
func (m *MsgProcessExitQueue) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProcessExitQueue.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProcessExitQueue proto.InternalMessageInfo

// MsgProcessExitQueueResponse returns processing results
type MsgProcessExitQueueResponse struct {
	// Number of requests processed
	RequestsProcessed int32 `protobuf:"varint,1,opt,name=requests_processed,json=requestsProcessed,proto3" json:"requests_processed,omitempty"`
	// Total shares processed
	TotalSharesProcessed cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_shares_processed,json=totalSharesProcessed,proto3,customtype=cosmossdk.io/math.Int" json:"total_shares_processed"`
	// Total amount distributed
	TotalAmountDistributed cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_amount_distributed,json=totalAmountDistributed,proto3,customtype=cosmossdk.io/math.Int" json:"total_amount_distributed"`
	// Remaining requests in queue
	RemainingRequests int32 `protobuf:"varint,4,opt,name=remaining_requests,json=remainingRequests,proto3" json:"remaining_requests,omitempty"`
}

func (m *MsgProcessExitQueueResponse) Reset()         { *m = MsgProcessExitQueueResponse{} }
func (m *MsgProcessExitQueueResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProcessExitQueueResponse) ProtoMessage()    {}
func (*MsgProcessExitQueueResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{11}
}
func (m *MsgProcessExitQueueResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProcessExitQueueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProcessExitQueueResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProcessExitQueueResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProcessExitQueueResponse.Merge(m, src)
}
func (m *MsgProcessExitQueueResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProcessExitQueueResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProcessExitQueueResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProcessExitQueueResponse proto.InternalMessageInfo

func (m *MsgProcessExitQueueResponse) GetRequestsProcessed() int32 {
	if m != nil {
		return m.RequestsProcessed
	}
	return 0
}

func (m *MsgProcessExitQueueResponse) GetRemainingRequests() int32 {
	if m != nil {
		return m.RemainingRequests
	}
	return 0
}

// MsgUpdateNAV allows authority to update NAV for a vault
type MsgUpdateNAV struct {
	// Authority updating NAV
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Vault type to update
	VaultType vaults.VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// New NAV value
	NewNav cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=new_nav,json=newNav,proto3,customtype=cosmossdk.io/math.Int" json:"new_nav"`
	// Reason for NAV update
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgUpdateNAV) Reset()         { *m = MsgUpdateNAV{} }
func (m *MsgUpdateNAV) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateNAV) ProtoMessage()    {}
func (*MsgUpdateNAV) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{12}
}
func (m *MsgUpdateNAV) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateNAV) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateNAV.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateNAV) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateNAV.Merge(m, src)
}
func (m *MsgUpdateNAV) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateNAV) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateNAV.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateNAV proto.InternalMessageInfo

// MsgUpdateNAVResponse returns NAV update results
type MsgUpdateNAVResponse struct {
	// Previous NAV
	PreviousNav cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=previous_nav,json=previousNav,proto3,customtype=cosmossdk.io/math.Int" json:"previous_nav"`
	// New NAV
	NewNav cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=new_nav,json=newNav,proto3,customtype=cosmossdk.io/math.Int" json:"new_nav"`
	// NAV change percentage (basis points)
	ChangeBps int32 `protobuf:"varint,3,opt,name=change_bps,json=changeBps,proto3" json:"change_bps,omitempty"`
	// New share price
	NewSharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=new_share_price,json=newSharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_share_price"`
}

func (m *MsgUpdateNAVResponse) Reset()         { *m = MsgUpdateNAVResponse{} }
func (m *MsgUpdateNAVResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateNAVResponse) ProtoMessage()    {}
func (*MsgUpdateNAVResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{13}
}
func (m *MsgUpdateNAVResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateNAVResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateNAVResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateNAVResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateNAVResponse.Merge(m, src)
}
func (m *MsgUpdateNAVResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateNAVResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateNAVResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateNAVResponse proto.InternalMessageInfo

func (m *MsgUpdateNAVResponse) GetChangeBps() int32 {
	if m != nil {
		return m.ChangeBps
	}
	return 0
}

// MsgUpdateVaultConfig allows authority to update vault configuration
type MsgUpdateVaultConfig struct {
	// Authority updating the config
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Vault type to update
	VaultType vaults.VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// New vault configuration
	Config VaultConfig `protobuf:"bytes,3,opt,name=config,proto3" json:"config"`
	// Reason for config update
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgUpdateVaultConfig) Reset()         { *m = MsgUpdateVaultConfig{} }
func (m *MsgUpdateVaultConfig) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateVaultConfig) ProtoMessage()    {}
func (*MsgUpdateVaultConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{14}
}
func (m *MsgUpdateVaultConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateVaultConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateVaultConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateVaultConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateVaultConfig.Merge(m, src)
}
func (m *MsgUpdateVaultConfig) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateVaultConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateVaultConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateVaultConfig proto.InternalMessageInfo

// MsgUpdateVaultConfigResponse confirms config update
type MsgUpdateVaultConfigResponse struct {
	// Previous configuration (JSON)
	PreviousConfig string `protobuf:"bytes,1,opt,name=previous_config,json=previousConfig,proto3" json:"previous_config,omitempty"`
	// New configuration (JSON)
	NewConfig string `protobuf:"bytes,2,opt,name=new_config,json=newConfig,proto3" json:"new_config,omitempty"`
}

func (m *MsgUpdateVaultConfigResponse) Reset()         { *m = MsgUpdateVaultConfigResponse{} }
func (m *MsgUpdateVaultConfigResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateVaultConfigResponse) ProtoMessage()    {}
func (*MsgUpdateVaultConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{15}
}
func (m *MsgUpdateVaultConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateVaultConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateVaultConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateVaultConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateVaultConfigResponse.Merge(m, src)
}
func (m *MsgUpdateVaultConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateVaultConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateVaultConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateVaultConfigResponse proto.InternalMessageInfo

func (m *MsgUpdateVaultConfigResponse) GetPreviousConfig() string {
	if m != nil {
		return m.PreviousConfig
	}
	return ""
}

func (m *MsgUpdateVaultConfigResponse) GetNewConfig() string {
	if m != nil {
		return m.NewConfig
	}
	return ""
}

// MsgUpdateParams allows authority to update module parameters
type MsgUpdateParams struct {
	// Authority updating the parameters
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// New parameters
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{16}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

// MsgUpdateParamsResponse confirms parameter update
type MsgUpdateParamsResponse struct {
	// Previous parameters (JSON)
	PreviousParams string `protobuf:"bytes,1,opt,name=previous_params,json=previousParams,proto3" json:"previous_params,omitempty"`
	// New parameters (JSON)
	NewParams string `protobuf:"bytes,2,opt,name=new_params,json=newParams,proto3" json:"new_params,omitempty"`
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{17}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

func (m *MsgUpdateParamsResponse) GetPreviousParams() string {
	if m != nil {
		return m.PreviousParams
	}
	return ""
}

func (m *MsgUpdateParamsResponse) GetNewParams() string {
	if m != nil {
		return m.NewParams
	}
	return ""
}

func init() {
	proto.RegisterType((*MsgDeposit)(nil), "noble.dollar.vaults.v2.MsgDeposit")
	proto.RegisterType((*MsgDepositResponse)(nil), "noble.dollar.vaults.v2.MsgDepositResponse")
	proto.RegisterType((*MsgWithdraw)(nil), "noble.dollar.vaults.v2.MsgWithdraw")
	proto.RegisterType((*MsgWithdrawResponse)(nil), "noble.dollar.vaults.v2.MsgWithdrawResponse")
	proto.RegisterType((*MsgRequestExit)(nil), "noble.dollar.vaults.v2.MsgRequestExit")
	proto.RegisterType((*MsgRequestExitResponse)(nil), "noble.dollar.vaults.v2.MsgRequestExitResponse")
	proto.RegisterType((*MsgCancelExit)(nil), "noble.dollar.vaults.v2.MsgCancelExit")
	proto.RegisterType((*MsgCancelExitResponse)(nil), "noble.dollar.vaults.v2.MsgCancelExitResponse")
	proto.RegisterType((*MsgSetYieldPreference)(nil), "noble.dollar.vaults.v2.MsgSetYieldPreference")
	proto.RegisterType((*MsgSetYieldPreferenceResponse)(nil), "noble.dollar.vaults.v2.MsgSetYieldPreferenceResponse")
	proto.RegisterType((*MsgProcessExitQueue)(nil), "noble.dollar.vaults.v2.MsgProcessExitQueue")
	proto.RegisterType((*MsgProcessExitQueueResponse)(nil), "noble.dollar.vaults.v2.MsgProcessExitQueueResponse")
	proto.RegisterType((*MsgUpdateNAV)(nil), "noble.dollar.vaults.v2.MsgUpdateNAV")
	proto.RegisterType((*MsgUpdateNAVResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateNAVResponse")
	proto.RegisterType((*MsgUpdateVaultConfig)(nil), "noble.dollar.vaults.v2.MsgUpdateVaultConfig")
	proto.RegisterType((*MsgUpdateVaultConfigResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateVaultConfigResponse")
	proto.RegisterType((*MsgUpdateParams)(nil), "noble.dollar.vaults.v2.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateParamsResponse")
}

func init() { proto.RegisterFile("noble/dollar/vaults/v2/tx.proto", fileDescriptor_c482f72d5d8ce397) }

var fileDescriptor_c482f72d5d8ce397 = []byte{
	// 1572 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0xcb, 0x6f, 0xd4, 0xd6,
	0x17, 0xce, 0x4c, 0x1e, 0x64, 0x4e, 0x5e, 0x60, 0x42, 0x18, 0x0c, 0x49, 0xc0, 0xe1, 0xa5, 0xfc,
	0xc8, 0xcc, 0x8f, 0x50, 0x28, 0x8c, 0x40, 0x6a, 0x42, 0x90, 0x1a, 0xa9, 0x43, 0x53, 0x07, 0x82,
	0x68, 0xab, 0x5a, 0x8e, 0x7d, 0xe3, 0xb8, 0x8c, 0x1f, 0xf5, 0xf5, 0xbc, 0x58, 0x55, 0x5d, 0x55,
	0x95, 0x2a, 0xf1, 0x27, 0xa0, 0xae, 0xaa, 0x4a, 0x95, 0x58, 0xd0, 0x3f, 0xa0, 0x9b, 0x8a, 0x4d,
	0x55, 0xc4, 0xaa, 0x6a, 0x25, 0x5a, 0xc1, 0x22, 0xed, 0xae, 0x8b, 0x76, 0xd5, 0x4d, 0x75, 0x1f,
	0x7e, 0x4c, 0x3c, 0x93, 0x4c, 0x26, 0x91, 0x68, 0x37, 0x60, 0xfb, 0x7e, 0xf7, 0x3b, 0xe7, 0x7e,
	0xe7, 0xbb, 0xf7, 0x9e, 0x09, 0x4c, 0xda, 0xce, 0x6a, 0x09, 0xe5, 0x75, 0xa7, 0x54, 0x52, 0xbd,
	0x7c, 0x45, 0x2d, 0x97, 0x7c, 0x9c, 0xaf, 0xcc, 0xe6, 0xfd, 0x5a, 0xce, 0xf5, 0x1c, 0xdf, 0x11,
	0xc6, 0x28, 0x20, 0xc7, 0x00, 0x39, 0x06, 0xc8, 0x55, 0x66, 0xc5, 0x03, 0xaa, 0x65, 0xda, 0x4e,
	0x9e, 0xfe, 0xcb, 0xa0, 0xe2, 0x61, 0xcd, 0xc1, 0x96, 0x83, 0xf3, 0x16, 0x36, 0xf2, 0x95, 0xf3,
	0xe4, 0x3f, 0x3e, 0x70, 0x84, 0x0d, 0x28, 0xf4, 0x2d, 0xcf, 0x5e, 0xf8, 0xd0, 0xa8, 0xe1, 0x18,
	0x0e, 0xfb, 0x4e, 0x9e, 0xf8, 0xd7, 0x49, 0xc3, 0x71, 0x8c, 0x12, 0xca, 0xd3, 0xb7, 0xd5, 0xf2,
	0x5a, 0xde, 0x37, 0x2d, 0x84, 0x7d, 0xd5, 0x72, 0x39, 0x60, 0xaa, 0x69, 0xda, 0xe7, 0xf9, 0x13,
	0x07, 0x9d, 0x6c, 0xb1, 0x36, 0x03, 0xd9, 0x08, 0x9b, 0x1c, 0x25, 0xfd, 0x9d, 0x06, 0x28, 0x62,
	0x63, 0x01, 0xb9, 0x0e, 0x36, 0x7d, 0xe1, 0x12, 0x64, 0x74, 0xf6, 0xe8, 0x78, 0xd9, 0xd4, 0xf1,
	0xd4, 0xd9, 0xcc, 0x7c, 0xf6, 0xd9, 0xe3, 0x99, 0x51, 0x9e, 0xf5, 0x9c, 0xae, 0x7b, 0x08, 0xe3,
	0x65, 0xdf, 0x33, 0x6d, 0x43, 0x8e, 0xa0, 0xc2, 0x1b, 0x00, 0x34, 0x82, 0xe2, 0xd7, 0x5d, 0x94,
	0x4d, 0x1f, 0x4f, 0x9d, 0x1d, 0x9e, 0x3d, 0x91, 0x6b, 0x2a, 0xde, 0xf9, 0xdc, 0x0a, 0x79, 0xba,
	0x55, 0x77, 0x91, 0x9c, 0xa9, 0x04, 0x8f, 0xc2, 0x9b, 0xd0, 0xa7, 0x5a, 0x4e, 0xd9, 0xf6, 0xb3,
	0xdd, 0x34, 0xec, 0xff, 0x9f, 0x3c, 0x9f, 0xec, 0xfa, 0xe9, 0xf9, 0xe4, 0x21, 0x16, 0x1a, 0xeb,
	0xf7, 0x72, 0xa6, 0x93, 0xb7, 0x54, 0x7f, 0x3d, 0xb7, 0x68, 0xfb, 0xcf, 0x1e, 0xcf, 0x00, 0xcf,
	0x69, 0xd1, 0xf6, 0xbf, 0xdc, 0x78, 0x34, 0x9d, 0x92, 0xf9, 0x7c, 0x61, 0x0a, 0x86, 0x3c, 0xa4,
	0x21, 0xb3, 0x82, 0x94, 0xba, 0x89, 0x4a, 0x7a, 0xb6, 0xe7, 0x78, 0xea, 0x6c, 0xbf, 0x3c, 0xc8,
	0x3f, 0xde, 0x25, 0xdf, 0x84, 0xb7, 0x01, 0x2c, 0xd3, 0x56, 0xf0, 0xba, 0xea, 0x21, 0x9c, 0xed,
	0xed, 0x30, 0x64, 0xc6, 0x32, 0xed, 0x65, 0x4a, 0x51, 0xb8, 0xf0, 0xe9, 0xc3, 0xc9, 0xae, 0xdf,
	0x1e, 0x4e, 0x76, 0x7d, 0xb2, 0xf1, 0x68, 0x3a, 0x52, 0xe6, 0xb3, 0x8d, 0x47, 0xd3, 0xd9, 0x44,
	0x0d, 0xb8, 0xdc, 0xd2, 0x9f, 0x69, 0x10, 0x22, 0xf5, 0x65, 0x84, 0x5d, 0xc7, 0xc6, 0x48, 0xb8,
	0x0b, 0x23, 0x2c, 0x31, 0x85, 0xe7, 0xac, 0xf3, 0x5a, 0xec, 0x3c, 0xc3, 0x61, 0x46, 0x24, 0x73,
	0x1e, 0xe1, 0x3d, 0xd8, 0xcf, 0x64, 0x52, 0x78, 0x8a, 0x48, 0xa7, 0xe5, 0xea, 0x84, 0x7b, 0x84,
	0x31, 0x2d, 0x04, 0x44, 0x42, 0x11, 0x32, 0x6b, 0x08, 0x61, 0xc5, 0x55, 0x4d, 0xbd, 0xe3, 0x32,
	0xf6, 0x13, 0x8a, 0x25, 0xd5, 0xd4, 0x85, 0x3b, 0x30, 0x40, 0xb3, 0x57, 0x5c, 0xcf, 0xd4, 0x10,
	0x2d, 0x63, 0x66, 0xfe, 0x12, 0x27, 0x3c, 0x9a, 0x24, 0x7c, 0x0b, 0x19, 0xaa, 0x56, 0x5f, 0x40,
	0x5a, 0x8c, 0x76, 0x01, 0x69, 0x8c, 0x16, 0x28, 0xd5, 0x12, 0x61, 0x92, 0x7e, 0x4e, 0xc3, 0x40,
	0x11, 0x1b, 0x77, 0x4c, 0x7f, 0x5d, 0xf7, 0xd4, 0xaa, 0x70, 0x19, 0xa0, 0xca, 0x9f, 0xd1, 0xf6,
	0xb6, 0x8f, 0x61, 0xf7, 0xc6, 0xf7, 0xdc, 0x84, 0x1d, 0xfb, 0x9e, 0xcd, 0x0f, 0x2c, 0xcd, 0x77,
	0x51, 0xcf, 0x2e, 0x2c, 0x3d, 0x47, 0x29, 0x0a, 0x17, 0xe3, 0x96, 0x8e, 0xad, 0x9a, 0x78, 0xfa,
	0x48, 0xc2, 0xd3, 0x81, 0x9a, 0xd2, 0x5f, 0x69, 0x38, 0x18, 0x53, 0x37, 0x74, 0x75, 0x64, 0xbd,
	0x80, 0xca, 0xee, 0xd8, 0xd6, 0xdc, 0x7a, 0x41, 0x0c, 0xbb, 0x61, 0xcb, 0xe8, 0x08, 0x59, 0xbb,
	0xb0, 0x75, 0xb8, 0x65, 0x18, 0xcf, 0x7f, 0xc6, 0xd5, 0x9f, 0xa7, 0x61, 0xb8, 0x88, 0x0d, 0x19,
	0x7d, 0x54, 0x46, 0xd8, 0xbf, 0x51, 0x63, 0xc7, 0xb9, 0xc7, 0x5e, 0xdb, 0xf0, 0x75, 0x04, 0xfd,
	0x37, 0xd9, 0xba, 0xf0, 0x7a, 0xc3, 0xc1, 0x1a, 0xe6, 0x48, 0x4c, 0x78, 0x2c, 0x61, 0xc2, 0xd8,
	0xe2, 0xa5, 0xef, 0xd3, 0x30, 0xd6, 0xa8, 0x47, 0x68, 0xc5, 0xd3, 0x30, 0x82, 0x6a, 0xa6, 0xaf,
	0x70, 0x36, 0xc5, 0xe4, 0x07, 0xac, 0x3c, 0x84, 0x28, 0x8c, 0x7e, 0x5d, 0xd4, 0x85, 0x15, 0xe0,
	0x66, 0x50, 0x7c, 0x47, 0x21, 0x43, 0x1d, 0x9b, 0x6a, 0x90, 0xf1, 0xdc, 0x72, 0x68, 0x5d, 0x56,
	0x60, 0x14, 0xd5, 0x5c, 0xa4, 0xf9, 0x48, 0x57, 0xca, 0x76, 0xc9, 0xd1, 0xee, 0x29, 0xe4, 0x8e,
	0xa7, 0x5a, 0x0d, 0xcc, 0x8a, 0x39, 0xd6, 0x00, 0xe4, 0x82, 0x06, 0x20, 0x77, 0x2b, 0x68, 0x00,
	0xe6, 0xfb, 0x49, 0xe4, 0x07, 0xbf, 0x4c, 0xa6, 0x64, 0x21, 0x60, 0xb8, 0x4d, 0x09, 0x08, 0x84,
	0x6c, 0x31, 0x84, 0x7d, 0xd3, 0x52, 0x09, 0xf1, 0x2e, 0x0f, 0x82, 0x91, 0x90, 0x89, 0x1d, 0x07,
	0xd2, 0xef, 0x29, 0x18, 0x2a, 0x62, 0xe3, 0xba, 0x6a, 0x6b, 0xa8, 0xf4, 0x8a, 0xed, 0xd5, 0xa4,
	0x80, 0xdd, 0x4d, 0x0a, 0x58, 0xb8, 0xd4, 0xda, 0x3c, 0x47, 0x13, 0xe6, 0x89, 0x56, 0x26, 0x7d,
	0x9d, 0x82, 0x43, 0x0d, 0x6b, 0x6d, 0x7a, 0x37, 0xfb, 0x65, 0xcf, 0xde, 0x8b, 0xbb, 0x99, 0xf1,
	0x08, 0x57, 0xe0, 0x88, 0x46, 0x03, 0x96, 0x90, 0xae, 0x6c, 0x5e, 0x1e, 0x35, 0x9e, 0x3c, 0x16,
	0x02, 0x6e, 0xc4, 0xd7, 0x29, 0x6d, 0xb0, 0x7c, 0x97, 0x91, 0x4f, 0xdb, 0x9b, 0x25, 0x0f, 0xad,
	0x21, 0x0f, 0xd9, 0x1a, 0x12, 0xce, 0x41, 0x4f, 0x19, 0xb7, 0x51, 0x1e, 0x8a, 0xda, 0x83, 0xca,
	0x24, 0xba, 0xaf, 0xee, 0x64, 0xf7, 0x55, 0xb8, 0x12, 0x2f, 0x0b, 0x8d, 0x4c, 0x2a, 0x32, 0x95,
	0xa8, 0x48, 0x72, 0x3d, 0x52, 0x15, 0xc6, 0x9b, 0x2e, 0x34, 0x2c, 0x50, 0x1e, 0x0e, 0xba, 0x1e,
	0xaa, 0x98, 0x4e, 0x99, 0xb4, 0xdc, 0xc1, 0x30, 0x5d, 0x7f, 0xbf, 0x2c, 0x04, 0x43, 0x31, 0x85,
	0x4e, 0xc1, 0xb0, 0x8d, 0xaa, 0x71, 0x6c, 0x9a, 0x62, 0x87, 0x6c, 0x54, 0x8d, 0x05, 0xfe, 0x23,
	0x45, 0xaf, 0xb5, 0x25, 0xcf, 0xd1, 0x10, 0xc6, 0x44, 0xfe, 0x77, 0xca, 0xa8, 0x8c, 0xc8, 0x26,
	0x50, 0xcb, 0xfe, 0xba, 0xe3, 0x99, 0x7e, 0x7d, 0xfb, 0x4d, 0x10, 0x42, 0xf7, 0x40, 0xea, 0x13,
	0x30, 0x68, 0xa9, 0xb5, 0xc0, 0x24, 0xec, 0xa4, 0xed, 0x95, 0x07, 0x2c, 0xb5, 0xc6, 0x8d, 0x81,
	0x0b, 0x57, 0x1b, 0xfc, 0x1f, 0x06, 0x27, 0x6a, 0x9f, 0x48, 0xa8, 0xbd, 0x79, 0x69, 0xd2, 0x0f,
	0x69, 0x38, 0xda, 0x64, 0xc9, 0xa1, 0xd4, 0x33, 0x20, 0x04, 0xc1, 0xc9, 0xaf, 0x1b, 0x02, 0xe2,
	0xdb, 0xa1, 0x57, 0x3e, 0x10, 0x8c, 0x2c, 0x05, 0x03, 0xc2, 0x1a, 0x8c, 0xf9, 0x8e, 0xaf, 0x96,
	0x78, 0xd7, 0x1d, 0x9b, 0xd2, 0xe9, 0xa9, 0x3a, 0x4a, 0xf9, 0x58, 0x07, 0x1e, 0xc5, 0xf9, 0x10,
	0xb2, 0x2c, 0x4e, 0xd0, 0xe9, 0x9a, 0xd8, 0xf7, 0xcc, 0xd5, 0x32, 0xe9, 0x75, 0x3b, 0xbd, 0x8d,
	0x58, 0xe6, 0xec, 0x24, 0x5c, 0x88, 0xf8, 0x98, 0x04, 0x96, 0x6a, 0xda, 0xa6, 0x6d, 0x44, 0x95,
	0xe8, 0x09, 0x24, 0xe0, 0x23, 0x41, 0x3d, 0xa4, 0x2f, 0xd2, 0x30, 0x58, 0xc4, 0xc6, 0x6d, 0x57,
	0x57, 0x7d, 0x74, 0x73, 0x6e, 0xe5, 0x15, 0xba, 0x67, 0x11, 0xf6, 0x11, 0xdb, 0xdb, 0x6a, 0xa5,
	0xf3, 0x2b, 0xda, 0x46, 0xd5, 0x9b, 0x6a, 0x45, 0x18, 0x83, 0x3e, 0x0f, 0xa9, 0xd8, 0xb1, 0xd9,
	0x65, 0x23, 0xf3, 0xb7, 0xc6, 0x06, 0xb2, 0xd1, 0x7d, 0x62, 0xc2, 0x7d, 0xa1, 0x26, 0xd2, 0x37,
	0x69, 0x18, 0x8d, 0x8b, 0x14, 0xfa, 0x6d, 0x19, 0x06, 0xc3, 0xad, 0x4d, 0xf2, 0xee, 0xf4, 0xe0,
	0x1d, 0x08, 0x58, 0x48, 0xf2, 0x31, 0x1d, 0xd2, 0xbb, 0xd4, 0x61, 0x1c, 0x40, 0x5b, 0x57, 0x6d,
	0x03, 0x29, 0xab, 0x6e, 0xb0, 0x1d, 0x33, 0xec, 0xcb, 0xbc, 0x8b, 0x85, 0x0f, 0x60, 0x84, 0x44,
	0xda, 0xbb, 0xee, 0x8f, 0x9c, 0x50, 0xcb, 0x51, 0x03, 0xf8, 0x55, 0x5c, 0x37, 0x5a, 0xf3, 0xeb,
	0x8e, 0xbd, 0x66, 0x1a, 0xaf, 0xd0, 0x64, 0x73, 0xd0, 0xa7, 0xd1, 0x1c, 0x78, 0x6b, 0x33, 0xd5,
	0x7c, 0xf6, 0x6c, 0x2e, 0x96, 0xee, 0x7c, 0x0f, 0x91, 0x43, 0xe6, 0x13, 0x5b, 0x9a, 0xeb, 0x5a,
	0x6b, 0x73, 0x49, 0x2d, 0xcc, 0x15, 0x0b, 0x22, 0xad, 0xc1, 0xb1, 0x66, 0x5a, 0x85, 0x5e, 0x3b,
	0x03, 0x23, 0xa1, 0xd7, 0xf8, 0x12, 0x58, 0x8b, 0x38, 0x1c, 0x7c, 0xe6, 0xe2, 0x8e, 0x03, 0x90,
	0xaa, 0x72, 0x0c, 0xbb, 0xa6, 0x33, 0x36, 0xaa, 0xf2, 0x38, 0xdf, 0xa6, 0x60, 0x24, 0x0c, 0xb4,
	0xa4, 0x7a, 0xaa, 0x85, 0x3b, 0xae, 0xc7, 0x55, 0xe8, 0x73, 0x29, 0x03, 0x0d, 0x33, 0x30, 0x3b,
	0xd1, 0x4a, 0x4d, 0x16, 0x27, 0x10, 0x92, 0xcd, 0x29, 0x5c, 0x6e, 0x2d, 0xd8, 0x78, 0x0b, 0xc1,
	0x18, 0x8f, 0xa4, 0xc2, 0xe1, 0x4d, 0x4b, 0x68, 0x2a, 0x13, 0xcf, 0x6d, 0x93, 0x4c, 0x7c, 0xcd,
	0x5c, 0xa6, 0x58, 0xfe, 0x4c, 0x26, 0x36, 0x3c, 0xfb, 0xdd, 0x3e, 0xe8, 0x2e, 0x62, 0x43, 0xb8,
	0x0b, 0xfb, 0x82, 0xbf, 0x45, 0x49, 0xad, 0x56, 0x17, 0xfd, 0xc5, 0x44, 0x9c, 0xde, 0x1e, 0x13,
	0xa6, 0xfa, 0x3e, 0xf4, 0x87, 0xbf, 0xf8, 0xa7, 0xb6, 0x98, 0x17, 0x80, 0xc4, 0xff, 0xb5, 0x01,
	0x0a, 0xd9, 0x11, 0x0c, 0xc4, 0x7f, 0x79, 0x9d, 0xde, 0x62, 0x6e, 0x0c, 0x27, 0xe6, 0xda, 0xc3,
	0x85, 0x61, 0x56, 0x01, 0x62, 0x0d, 0xf8, 0xa9, 0x2d, 0x66, 0x47, 0x30, 0x71, 0xa6, 0x2d, 0x58,
	0x18, 0xe3, 0x3e, 0x08, 0x4d, 0x1a, 0xc9, 0xad, 0x48, 0x92, 0x70, 0xf1, 0xe2, 0x8e, 0xe0, 0x61,
	0x6c, 0x1f, 0xf6, 0x27, 0x3a, 0xac, 0xad, 0xea, 0xb0, 0x19, 0x2c, 0x5e, 0xd8, 0x01, 0x38, 0x8c,
	0xaa, 0x40, 0x26, 0xba, 0x92, 0x4f, 0x6e, 0xc1, 0x10, 0xa2, 0xc4, 0x73, 0xed, 0xa0, 0xc2, 0x00,
	0x55, 0x38, 0x90, 0x3c, 0x96, 0xb7, 0xa7, 0x88, 0xa1, 0xc5, 0xd7, 0x76, 0x82, 0x0e, 0x03, 0xaf,
	0xc3, 0x60, 0xc3, 0xd1, 0x73, 0x66, 0x5b, 0x16, 0x06, 0x14, 0xf3, 0x6d, 0x02, 0x83, 0x48, 0x62,
	0xef, 0xc7, 0xe4, 0x4e, 0x9a, 0xbf, 0xf6, 0xe4, 0xc5, 0x44, 0xea, 0xe9, 0x8b, 0x89, 0xd4, 0xaf,
	0x2f, 0x26, 0x52, 0x0f, 0x5e, 0x4e, 0x74, 0x3d, 0x7d, 0x39, 0xd1, 0xf5, 0xe3, 0xcb, 0x89, 0xae,
	0x77, 0x79, 0x7b, 0xcf, 0x79, 0x6b, 0xf5, 0xfb, 0xf4, 0x2f, 0xed, 0x75, 0x17, 0xe1, 0xe8, 0xdc,
	0x59, 0xed, 0xa3, 0xbf, 0x79, 0x2f, 0xfc, 0x13, 0x00, 0x00, 0xff, 0xff, 0xfe, 0xb1, 0x4b, 0x23,
	0x9a, 0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Deposit into a V2 vault
	Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error)
	// Withdraw from a V2 vault (flexible vaults only)
	Withdraw(ctx context.Context, in *MsgWithdraw, opts ...grpc.CallOption) (*MsgWithdrawResponse, error)
	// Request exit from a staked vault
	RequestExit(ctx context.Context, in *MsgRequestExit, opts ...grpc.CallOption) (*MsgRequestExitResponse, error)
	// Cancel a pending exit request
	CancelExit(ctx context.Context, in *MsgCancelExit, opts ...grpc.CallOption) (*MsgCancelExitResponse, error)
	// Set yield preference for a user's position
	SetYieldPreference(ctx context.Context, in *MsgSetYieldPreference, opts ...grpc.CallOption) (*MsgSetYieldPreferenceResponse, error)
	// Process exit queue (admin only)
	ProcessExitQueue(ctx context.Context, in *MsgProcessExitQueue, opts ...grpc.CallOption) (*MsgProcessExitQueueResponse, error)
	// Update NAV for a vault (authority only)
	UpdateNAV(ctx context.Context, in *MsgUpdateNAV, opts ...grpc.CallOption) (*MsgUpdateNAVResponse, error)
	// Update vault configuration (authority only)
	UpdateVaultConfig(ctx context.Context, in *MsgUpdateVaultConfig, opts ...grpc.CallOption) (*MsgUpdateVaultConfigResponse, error)
	// Update module parameters (authority only)
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error) {
	out := new(MsgDepositResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/Deposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Withdraw(ctx context.Context, in *MsgWithdraw, opts ...grpc.CallOption) (*MsgWithdrawResponse, error) {
	out := new(MsgWithdrawResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/Withdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RequestExit(ctx context.Context, in *MsgRequestExit, opts ...grpc.CallOption) (*MsgRequestExitResponse, error) {
	out := new(MsgRequestExitResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/RequestExit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelExit(ctx context.Context, in *MsgCancelExit, opts ...grpc.CallOption) (*MsgCancelExitResponse, error) {
	out := new(MsgCancelExitResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/CancelExit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetYieldPreference(ctx context.Context, in *MsgSetYieldPreference, opts ...grpc.CallOption) (*MsgSetYieldPreferenceResponse, error) {
	out := new(MsgSetYieldPreferenceResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/SetYieldPreference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ProcessExitQueue(ctx context.Context, in *MsgProcessExitQueue, opts ...grpc.CallOption) (*MsgProcessExitQueueResponse, error) {
	out := new(MsgProcessExitQueueResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/ProcessExitQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateNAV(ctx context.Context, in *MsgUpdateNAV, opts ...grpc.CallOption) (*MsgUpdateNAVResponse, error) {
	out := new(MsgUpdateNAVResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateNAV", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateVaultConfig(ctx context.Context, in *MsgUpdateVaultConfig, opts ...grpc.CallOption) (*MsgUpdateVaultConfigResponse, error) {
	out := new(MsgUpdateVaultConfigResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateVaultConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Deposit into a V2 vault
	Deposit(context.Context, *MsgDeposit) (*MsgDepositResponse, error)
	// Withdraw from a V2 vault (flexible vaults only)
	Withdraw(context.Context, *MsgWithdraw) (*MsgWithdrawResponse, error)
	// Request exit from a staked vault
	RequestExit(context.Context, *MsgRequestExit) (*MsgRequestExitResponse, error)
	// Cancel a pending exit request
	CancelExit(context.Context, *MsgCancelExit) (*MsgCancelExitResponse, error)
	// Set yield preference for a user's position
	SetYieldPreference(context.Context, *MsgSetYieldPreference) (*MsgSetYieldPreferenceResponse, error)
	// Process exit queue (admin only)
	ProcessExitQueue(context.Context, *MsgProcessExitQueue) (*MsgProcessExitQueueResponse, error)
	// Update NAV for a vault (authority only)
	UpdateNAV(context.Context, *MsgUpdateNAV) (*MsgUpdateNAVResponse, error)
	// Update vault configuration (authority only)
	UpdateVaultConfig(context.Context, *MsgUpdateVaultConfig) (*MsgUpdateVaultConfigResponse, error)
	// Update module parameters (authority only)
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Deposit(ctx context.Context, req *MsgDeposit) (*MsgDepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposit not implemented")
}
func (*UnimplementedMsgServer) Withdraw(ctx context.Context, req *MsgWithdraw) (*MsgWithdrawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Withdraw not implemented")
}
func (*UnimplementedMsgServer) RequestExit(ctx context.Context, req *MsgRequestExit) (*MsgRequestExitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestExit not implemented")
}
func (*UnimplementedMsgServer) CancelExit(ctx context.Context, req *MsgCancelExit) (*MsgCancelExitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelExit not implemented")
}
func (*UnimplementedMsgServer) SetYieldPreference(ctx context.Context, req *MsgSetYieldPreference) (*MsgSetYieldPreferenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetYieldPreference not implemented")
}
func (*UnimplementedMsgServer) ProcessExitQueue(ctx context.Context, req *MsgProcessExitQueue) (*MsgProcessExitQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessExitQueue not implemented")
}
func (*UnimplementedMsgServer) UpdateNAV(ctx context.Context, req *MsgUpdateNAV) (*MsgUpdateNAVResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNAV not implemented")
}
func (*UnimplementedMsgServer) UpdateVaultConfig(ctx context.Context, req *MsgUpdateVaultConfig) (*MsgUpdateVaultConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVaultConfig not implemented")
}
func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Deposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Deposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/Deposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Deposit(ctx, req.(*MsgDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Withdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWithdraw)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Withdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/Withdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Withdraw(ctx, req.(*MsgWithdraw))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RequestExit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRequestExit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RequestExit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/RequestExit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RequestExit(ctx, req.(*MsgRequestExit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelExit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelExit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelExit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/CancelExit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelExit(ctx, req.(*MsgCancelExit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetYieldPreference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetYieldPreference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetYieldPreference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/SetYieldPreference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetYieldPreference(ctx, req.(*MsgSetYieldPreference))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ProcessExitQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProcessExitQueue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProcessExitQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/ProcessExitQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProcessExitQueue(ctx, req.(*MsgProcessExitQueue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateNAV_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateNAV)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateNAV(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateNAV",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateNAV(ctx, req.(*MsgUpdateNAV))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateVaultConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateVaultConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateVaultConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateVaultConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateVaultConfig(ctx, req.(*MsgUpdateVaultConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "noble.dollar.vaults.v2.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deposit",
			Handler:    _Msg_Deposit_Handler,
		},
		{
			MethodName: "Withdraw",
			Handler:    _Msg_Withdraw_Handler,
		},
		{
			MethodName: "RequestExit",
			Handler:    _Msg_RequestExit_Handler,
		},
		{
			MethodName: "CancelExit",
			Handler:    _Msg_CancelExit_Handler,
		},
		{
			MethodName: "SetYieldPreference",
			Handler:    _Msg_SetYieldPreference_Handler,
		},
		{
			MethodName: "ProcessExitQueue",
			Handler:    _Msg_ProcessExitQueue_Handler,
		},
		{
			MethodName: "UpdateNAV",
			Handler:    _Msg_UpdateNAV_Handler,
		},
		{
			MethodName: "UpdateVaultConfig",
			Handler:    _Msg_UpdateVaultConfig_Handler,
		},
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "noble/dollar/vaults/v2/tx.proto",
}

func (m *MsgDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinShares.Size()
		i -= size
		if _, err := m.MinShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.ReceiveYield {
		i--
		if m.ReceiveYield {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.VaultType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Depositor) > 0 {
		i -= len(m.Depositor)
		copy(dAtA[i:], m.Depositor)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Depositor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.FeesPaid.Size()
		i -= size
		if _, err := m.FeesPaid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.AmountDeposited.Size()
		i -= size
		if _, err := m.AmountDeposited.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.SharesReceived.Size()
		i -= size
		if _, err := m.SharesReceived.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinAmount.Size()
		i -= size
		if _, err := m.MinAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.VaultType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Withdrawer) > 0 {
		i -= len(m.Withdrawer)
		copy(dAtA[i:], m.Withdrawer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Withdrawer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.FeesPaid.Size()
		i -= size
		if _, err := m.FeesPaid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SharesRedeemed.Size()
		i -= size
		if _, err := m.SharesRedeemed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.AmountWithdrawn.Size()
		i -= size
		if _, err := m.AmountWithdrawn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgRequestExit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestExit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestExit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.VaultType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRequestExitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestExitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestExitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.EstimatedAmount.Size()
		i -= size
		if _, err := m.EstimatedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedUnlockTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedUnlockTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintTx(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x1a
	{
		size := m.SharesToExit.Size()
		i -= size
		if _, err := m.SharesToExit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ExitRequestId) > 0 {
		i -= len(m.ExitRequestId)
		copy(dAtA[i:], m.ExitRequestId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ExitRequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelExit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelExit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelExit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExitRequestId) > 0 {
		i -= len(m.ExitRequestId)
		copy(dAtA[i:], m.ExitRequestId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ExitRequestId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.VaultType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelExitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelExitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelExitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CancelledExitRequestId) > 0 {
		i -= len(m.CancelledExitRequestId)
		copy(dAtA[i:], m.CancelledExitRequestId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CancelledExitRequestId)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.SharesReturned.Size()
		i -= size
		if _, err := m.SharesReturned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetYieldPreference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetYieldPreference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetYieldPreference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReceiveYield {
		i--
		if m.ReceiveYield {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.VaultType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTx(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetYieldPreferenceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetYieldPreferenceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetYieldPreferenceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewPreference {
		i--
		if m.NewPreference {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.PreviousPreference {
		i--
		if m.PreviousPreference {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgProcessExitQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProcessExitQueue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProcessExitQueue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxRequests != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MaxRequests))
		i--
		dAtA[i] = 0x18
	}
	if m.VaultType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProcessExitQueueResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProcessExitQueueResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProcessExitQueueResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemainingRequests != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RemainingRequests))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.TotalAmountDistributed.Size()
		i -= size
		if _, err := m.TotalAmountDistributed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalSharesProcessed.Size()
		i -= size
		if _, err := m.TotalSharesProcessed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.RequestsProcessed != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RequestsProcessed))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateNAV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateNAV) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateNAV) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.NewNav.Size()
		i -= size
		if _, err := m.NewNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.VaultType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateNAVResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateNAVResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateNAVResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NewSharePrice.Size()
		i -= size
		if _, err := m.NewSharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ChangeBps != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChangeBps))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.NewNav.Size()
		i -= size
		if _, err := m.NewNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.PreviousNav.Size()
		i -= size
		if _, err := m.PreviousNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateVaultConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateVaultConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateVaultConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.VaultType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VaultType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateVaultConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateVaultConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateVaultConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewConfig) > 0 {
		i -= len(m.NewConfig)
		copy(dAtA[i:], m.NewConfig)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewConfig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousConfig) > 0 {
		i -= len(m.PreviousConfig)
		copy(dAtA[i:], m.PreviousConfig)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PreviousConfig)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewParams) > 0 {
		i -= len(m.NewParams)
		copy(dAtA[i:], m.NewParams)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewParams)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousParams) > 0 {
		i -= len(m.PreviousParams)
		copy(dAtA[i:], m.PreviousParams)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PreviousParams)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.VaultType != 0 {
		n += 1 + sovTx(uint64(m.VaultType))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.ReceiveYield {
		n += 2
	}
	l = m.MinShares.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDepositResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SharesReceived.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.AmountDeposited.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.FeesPaid.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.SharePrice.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Withdrawer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.VaultType != 0 {
		n += 1 + sovTx(uint64(m.VaultType))
	}
	l = m.Shares.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgWithdrawResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AmountWithdrawn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.SharesRedeemed.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.FeesPaid.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.SharePrice.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRequestExit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.VaultType != 0 {
		n += 1 + sovTx(uint64(m.VaultType))
	}
	l = m.Shares.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRequestExitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExitRequestId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.SharesToExit.Size()
	n += 1 + l + sovTx(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedUnlockTime)
	n += 1 + l + sovTx(uint64(l))
	l = m.EstimatedAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCancelExit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.VaultType != 0 {
		n += 1 + sovTx(uint64(m.VaultType))
	}
	l = len(m.ExitRequestId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelExitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SharesReturned.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.CancelledExitRequestId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetYieldPreference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.VaultType != 0 {
		n += 1 + sovTx(uint64(m.VaultType))
	}
	if m.ReceiveYield {
		n += 2
	}
	return n
}

func (m *MsgSetYieldPreferenceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreviousPreference {
		n += 2
	}
	if m.NewPreference {
		n += 2
	}
	return n
}

func (m *MsgProcessExitQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.VaultType != 0 {
		n += 1 + sovTx(uint64(m.VaultType))
	}
	if m.MaxRequests != 0 {
		n += 1 + sovTx(uint64(m.MaxRequests))
	}
	return n
}

func (m *MsgProcessExitQueueResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestsProcessed != 0 {
		n += 1 + sovTx(uint64(m.RequestsProcessed))
	}
	l = m.TotalSharesProcessed.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TotalAmountDistributed.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.RemainingRequests != 0 {
		n += 1 + sovTx(uint64(m.RemainingRequests))
	}
	return n
}

func (m *MsgUpdateNAV) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.VaultType != 0 {
		n += 1 + sovTx(uint64(m.VaultType))
	}
	l = m.NewNav.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateNAVResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PreviousNav.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.NewNav.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.ChangeBps != 0 {
		n += 1 + sovTx(uint64(m.ChangeBps))
	}
	l = m.NewSharePrice.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateVaultConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.VaultType != 0 {
		n += 1 + sovTx(uint64(m.VaultType))
	}
	l = m.Config.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateVaultConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousConfig)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewConfig)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousParams)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewParams)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= vaults.VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveYield", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReceiveYield = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesReceived.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountDeposited", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountDeposited.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeesPaid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeesPaid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdrawer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Withdrawer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= vaults.VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesRedeemed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesRedeemed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeesPaid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeesPaid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestExit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestExit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestExit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= vaults.VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestExitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestExitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestExitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitRequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExitRequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesToExit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesToExit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedUnlockTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedUnlockTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EstimatedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelExit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelExit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelExit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= vaults.VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitRequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExitRequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelExitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelExitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelExitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesReturned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesReturned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledExitRequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelledExitRequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetYieldPreference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetYieldPreference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetYieldPreference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= vaults.VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveYield", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReceiveYield = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetYieldPreferenceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetYieldPreferenceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetYieldPreferenceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousPreference", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreviousPreference = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPreference", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewPreference = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProcessExitQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProcessExitQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProcessExitQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= vaults.VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequests", wireType)
			}
			m.MaxRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequests |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProcessExitQueueResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProcessExitQueueResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProcessExitQueueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestsProcessed", wireType)
			}
			m.RequestsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestsProcessed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSharesProcessed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSharesProcessed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmountDistributed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmountDistributed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingRequests", wireType)
			}
			m.RemainingRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainingRequests |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateNAV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateNAV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateNAV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= vaults.VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateNAVResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateNAVResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateNAVResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PreviousNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeBps", wireType)
			}
			m.ChangeBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeBps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewSharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateVaultConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateVaultConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateVaultConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
			}
			m.VaultType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultType |= vaults.VaultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateVaultConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateVaultConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateVaultConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousParams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousParams = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewParams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewParams = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
