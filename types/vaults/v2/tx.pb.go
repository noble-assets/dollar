// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/tx.proto

package v2

import (
	context "context"
	cosmossdk_io_math "cosmossdk.io/math"
	_ "dollar.noble.xyz/v2/types/vaults"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgDeposit allows users to deposit into a V2 vault
type MsgDeposit struct {
	// User making the deposit
	Depositor string `protobuf:"bytes,1,opt,name=depositor,proto3" json:"depositor,omitempty"`
	// Amount to deposit
	Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// Whether user wants to receive yield
	ReceiveYield bool `protobuf:"varint,3,opt,name=receive_yield,json=receiveYield,proto3" json:"receive_yield,omitempty"`
	// Minimum shares to receive (slippage protection)
	MinShares cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=min_shares,json=minShares,proto3,customtype=cosmossdk.io/math.Int" json:"min_shares"`
}

func (m *MsgDeposit) Reset()         { *m = MsgDeposit{} }
func (m *MsgDeposit) String() string { return proto.CompactTextString(m) }
func (*MsgDeposit) ProtoMessage()    {}
func (*MsgDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{0}
}
func (m *MsgDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeposit.Merge(m, src)
}
func (m *MsgDeposit) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeposit proto.InternalMessageInfo

// MsgDepositResponse returns the results of a deposit
type MsgDepositResponse struct {
	// Shares received
	SharesReceived cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=shares_received,json=sharesReceived,proto3,customtype=cosmossdk.io/math.Int" json:"shares_received"`
	// Amount actually deposited (after fees)
	AmountDeposited cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount_deposited,json=amountDeposited,proto3,customtype=cosmossdk.io/math.Int" json:"amount_deposited"`
	// Fees paid
	FeesPaid cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=fees_paid,json=feesPaid,proto3,customtype=cosmossdk.io/math.Int" json:"fees_paid"`
	// Share price at time of deposit
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
}

func (m *MsgDepositResponse) Reset()         { *m = MsgDepositResponse{} }
func (m *MsgDepositResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDepositResponse) ProtoMessage()    {}
func (*MsgDepositResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{1}
}
func (m *MsgDepositResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositResponse.Merge(m, src)
}
func (m *MsgDepositResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositResponse proto.InternalMessageInfo

// MsgWithdraw allows users to withdraw from flexible V2 vaults
type MsgWithdraw struct {
	// User making the withdrawal
	Withdrawer string `protobuf:"bytes,1,opt,name=withdrawer,proto3" json:"withdrawer,omitempty"`
	// Shares to redeem
	Shares cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=shares,proto3,customtype=cosmossdk.io/math.Int" json:"shares"`
	// Minimum amount to receive (slippage protection)
	MinAmount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=min_amount,json=minAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_amount"`
}

func (m *MsgWithdraw) Reset()         { *m = MsgWithdraw{} }
func (m *MsgWithdraw) String() string { return proto.CompactTextString(m) }
func (*MsgWithdraw) ProtoMessage()    {}
func (*MsgWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{2}
}
func (m *MsgWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdraw.Merge(m, src)
}
func (m *MsgWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdraw proto.InternalMessageInfo

// MsgWithdrawResponse returns the results of a withdrawal
type MsgWithdrawResponse struct {
	// Amount withdrawn
	AmountWithdrawn cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=amount_withdrawn,json=amountWithdrawn,proto3,customtype=cosmossdk.io/math.Int" json:"amount_withdrawn"`
	// Shares redeemed
	SharesRedeemed cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=shares_redeemed,json=sharesRedeemed,proto3,customtype=cosmossdk.io/math.Int" json:"shares_redeemed"`
	// Fees paid
	FeesPaid cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=fees_paid,json=feesPaid,proto3,customtype=cosmossdk.io/math.Int" json:"fees_paid"`
	// Share price at time of withdrawal
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
}

func (m *MsgWithdrawResponse) Reset()         { *m = MsgWithdrawResponse{} }
func (m *MsgWithdrawResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawResponse) ProtoMessage()    {}
func (*MsgWithdrawResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{3}
}
func (m *MsgWithdrawResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawResponse.Merge(m, src)
}
func (m *MsgWithdrawResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawResponse proto.InternalMessageInfo

// MsgRequestExit allows users to request exit from staked vaults
type MsgRequestExit struct {
	// User requesting exit
	Requester string `protobuf:"bytes,1,opt,name=requester,proto3" json:"requester,omitempty"`
	// Shares to exit
	Shares cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=shares,proto3,customtype=cosmossdk.io/math.Int" json:"shares"`
}

func (m *MsgRequestExit) Reset()         { *m = MsgRequestExit{} }
func (m *MsgRequestExit) String() string { return proto.CompactTextString(m) }
func (*MsgRequestExit) ProtoMessage()    {}
func (*MsgRequestExit) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{4}
}
func (m *MsgRequestExit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestExit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestExit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestExit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestExit.Merge(m, src)
}
func (m *MsgRequestExit) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestExit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestExit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestExit proto.InternalMessageInfo

// MsgRequestExitResponse returns the results of an exit request
type MsgRequestExitResponse struct {
	// Exit request ID
	ExitRequestId string `protobuf:"bytes,1,opt,name=exit_request_id,json=exitRequestId,proto3" json:"exit_request_id,omitempty"`
	// Shares to be exited
	SharesToExit cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=shares_to_exit,json=sharesToExit,proto3,customtype=cosmossdk.io/math.Int" json:"shares_to_exit"`
	// Expected unlock time
	ExpectedUnlockTime time.Time `protobuf:"bytes,3,opt,name=expected_unlock_time,json=expectedUnlockTime,proto3,stdtime" json:"expected_unlock_time"`
	// Estimated amount to receive (subject to change)
	EstimatedAmount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=estimated_amount,json=estimatedAmount,proto3,customtype=cosmossdk.io/math.Int" json:"estimated_amount"`
}

func (m *MsgRequestExitResponse) Reset()         { *m = MsgRequestExitResponse{} }
func (m *MsgRequestExitResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRequestExitResponse) ProtoMessage()    {}
func (*MsgRequestExitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{5}
}
func (m *MsgRequestExitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestExitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestExitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestExitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestExitResponse.Merge(m, src)
}
func (m *MsgRequestExitResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestExitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestExitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestExitResponse proto.InternalMessageInfo

func (m *MsgRequestExitResponse) GetExitRequestId() string {
	if m != nil {
		return m.ExitRequestId
	}
	return ""
}

func (m *MsgRequestExitResponse) GetExpectedUnlockTime() time.Time {
	if m != nil {
		return m.ExpectedUnlockTime
	}
	return time.Time{}
}

// MsgCancelExit allows users to cancel pending exit requests
type MsgCancelExit struct {
	// User cancelling the exit request
	Requester string `protobuf:"bytes,1,opt,name=requester,proto3" json:"requester,omitempty"`
	// Exit request ID to cancel
	ExitRequestId string `protobuf:"bytes,2,opt,name=exit_request_id,json=exitRequestId,proto3" json:"exit_request_id,omitempty"`
}

func (m *MsgCancelExit) Reset()         { *m = MsgCancelExit{} }
func (m *MsgCancelExit) String() string { return proto.CompactTextString(m) }
func (*MsgCancelExit) ProtoMessage()    {}
func (*MsgCancelExit) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{6}
}
func (m *MsgCancelExit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelExit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelExit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelExit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelExit.Merge(m, src)
}
func (m *MsgCancelExit) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelExit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelExit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelExit proto.InternalMessageInfo

// MsgCancelExitResponse returns the results of cancelling an exit request
type MsgCancelExitResponse struct {
	// Shares returned to staking
	SharesReturned cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=shares_returned,json=sharesReturned,proto3,customtype=cosmossdk.io/math.Int" json:"shares_returned"`
	// Exit request ID that was cancelled
	CancelledExitRequestId string `protobuf:"bytes,2,opt,name=cancelled_exit_request_id,json=cancelledExitRequestId,proto3" json:"cancelled_exit_request_id,omitempty"`
}

func (m *MsgCancelExitResponse) Reset()         { *m = MsgCancelExitResponse{} }
func (m *MsgCancelExitResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelExitResponse) ProtoMessage()    {}
func (*MsgCancelExitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{7}
}
func (m *MsgCancelExitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelExitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelExitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelExitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelExitResponse.Merge(m, src)
}
func (m *MsgCancelExitResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelExitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelExitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelExitResponse proto.InternalMessageInfo

func (m *MsgCancelExitResponse) GetCancelledExitRequestId() string {
	if m != nil {
		return m.CancelledExitRequestId
	}
	return ""
}

// MsgSetYieldPreference allows users to set their yield preference
type MsgSetYieldPreference struct {
	// User setting the preference
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// Whether to receive yield
	ReceiveYield bool `protobuf:"varint,2,opt,name=receive_yield,json=receiveYield,proto3" json:"receive_yield,omitempty"`
}

func (m *MsgSetYieldPreference) Reset()         { *m = MsgSetYieldPreference{} }
func (m *MsgSetYieldPreference) String() string { return proto.CompactTextString(m) }
func (*MsgSetYieldPreference) ProtoMessage()    {}
func (*MsgSetYieldPreference) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{8}
}
func (m *MsgSetYieldPreference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetYieldPreference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetYieldPreference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetYieldPreference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetYieldPreference.Merge(m, src)
}
func (m *MsgSetYieldPreference) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetYieldPreference) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetYieldPreference.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetYieldPreference proto.InternalMessageInfo

// MsgSetYieldPreferenceResponse confirms yield preference update
type MsgSetYieldPreferenceResponse struct {
	// Previous yield preference
	PreviousPreference bool `protobuf:"varint,1,opt,name=previous_preference,json=previousPreference,proto3" json:"previous_preference,omitempty"`
	// New yield preference
	NewPreference bool `protobuf:"varint,2,opt,name=new_preference,json=newPreference,proto3" json:"new_preference,omitempty"`
}

func (m *MsgSetYieldPreferenceResponse) Reset()         { *m = MsgSetYieldPreferenceResponse{} }
func (m *MsgSetYieldPreferenceResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetYieldPreferenceResponse) ProtoMessage()    {}
func (*MsgSetYieldPreferenceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{9}
}
func (m *MsgSetYieldPreferenceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetYieldPreferenceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetYieldPreferenceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetYieldPreferenceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetYieldPreferenceResponse.Merge(m, src)
}
func (m *MsgSetYieldPreferenceResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetYieldPreferenceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetYieldPreferenceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetYieldPreferenceResponse proto.InternalMessageInfo

func (m *MsgSetYieldPreferenceResponse) GetPreviousPreference() bool {
	if m != nil {
		return m.PreviousPreference
	}
	return false
}

func (m *MsgSetYieldPreferenceResponse) GetNewPreference() bool {
	if m != nil {
		return m.NewPreference
	}
	return false
}

// MsgProcessExitQueue allows authority to process exit queue for a vault
type MsgProcessExitQueue struct {
	// Authority processing the queue
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Maximum number of requests to process
	MaxRequests int32 `protobuf:"varint,2,opt,name=max_requests,json=maxRequests,proto3" json:"max_requests,omitempty"`
}

func (m *MsgProcessExitQueue) Reset()         { *m = MsgProcessExitQueue{} }
func (m *MsgProcessExitQueue) String() string { return proto.CompactTextString(m) }
func (*MsgProcessExitQueue) ProtoMessage()    {}
func (*MsgProcessExitQueue) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{10}
}
func (m *MsgProcessExitQueue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProcessExitQueue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProcessExitQueue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProcessExitQueue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProcessExitQueue.Merge(m, src)
}
func (m *MsgProcessExitQueue) XXX_Size() int {
	return m.Size()
}
func (m *MsgProcessExitQueue) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProcessExitQueue.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProcessExitQueue proto.InternalMessageInfo

// MsgProcessExitQueueResponse returns processing results
type MsgProcessExitQueueResponse struct {
	// Number of requests processed
	RequestsProcessed int32 `protobuf:"varint,1,opt,name=requests_processed,json=requestsProcessed,proto3" json:"requests_processed,omitempty"`
	// Total shares processed
	TotalSharesProcessed cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_shares_processed,json=totalSharesProcessed,proto3,customtype=cosmossdk.io/math.Int" json:"total_shares_processed"`
	// Total amount distributed
	TotalAmountDistributed cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_amount_distributed,json=totalAmountDistributed,proto3,customtype=cosmossdk.io/math.Int" json:"total_amount_distributed"`
	// Remaining requests in queue
	RemainingRequests int32 `protobuf:"varint,4,opt,name=remaining_requests,json=remainingRequests,proto3" json:"remaining_requests,omitempty"`
}

func (m *MsgProcessExitQueueResponse) Reset()         { *m = MsgProcessExitQueueResponse{} }
func (m *MsgProcessExitQueueResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProcessExitQueueResponse) ProtoMessage()    {}
func (*MsgProcessExitQueueResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{11}
}
func (m *MsgProcessExitQueueResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProcessExitQueueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProcessExitQueueResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProcessExitQueueResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProcessExitQueueResponse.Merge(m, src)
}
func (m *MsgProcessExitQueueResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProcessExitQueueResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProcessExitQueueResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProcessExitQueueResponse proto.InternalMessageInfo

func (m *MsgProcessExitQueueResponse) GetRequestsProcessed() int32 {
	if m != nil {
		return m.RequestsProcessed
	}
	return 0
}

func (m *MsgProcessExitQueueResponse) GetRemainingRequests() int32 {
	if m != nil {
		return m.RemainingRequests
	}
	return 0
}

// MsgUpdateNAV allows authority to update NAV for a vault
type MsgUpdateNAV struct {
	// Authority updating NAV
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// New NAV value
	NewNav cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=new_nav,json=newNav,proto3,customtype=cosmossdk.io/math.Int" json:"new_nav"`
	// Reason for NAV update
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgUpdateNAV) Reset()         { *m = MsgUpdateNAV{} }
func (m *MsgUpdateNAV) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateNAV) ProtoMessage()    {}
func (*MsgUpdateNAV) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{12}
}
func (m *MsgUpdateNAV) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateNAV) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateNAV.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateNAV) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateNAV.Merge(m, src)
}
func (m *MsgUpdateNAV) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateNAV) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateNAV.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateNAV proto.InternalMessageInfo

// MsgUpdateNAVResponse returns NAV update results
type MsgUpdateNAVResponse struct {
	// Previous NAV
	PreviousNav cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=previous_nav,json=previousNav,proto3,customtype=cosmossdk.io/math.Int" json:"previous_nav"`
	// New NAV
	NewNav cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=new_nav,json=newNav,proto3,customtype=cosmossdk.io/math.Int" json:"new_nav"`
	// NAV change percentage (basis points)
	ChangeBps int32 `protobuf:"varint,3,opt,name=change_bps,json=changeBps,proto3" json:"change_bps,omitempty"`
	// New share price
	NewSharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=new_share_price,json=newSharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_share_price"`
}

func (m *MsgUpdateNAVResponse) Reset()         { *m = MsgUpdateNAVResponse{} }
func (m *MsgUpdateNAVResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateNAVResponse) ProtoMessage()    {}
func (*MsgUpdateNAVResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{13}
}
func (m *MsgUpdateNAVResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateNAVResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateNAVResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateNAVResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateNAVResponse.Merge(m, src)
}
func (m *MsgUpdateNAVResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateNAVResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateNAVResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateNAVResponse proto.InternalMessageInfo

func (m *MsgUpdateNAVResponse) GetChangeBps() int32 {
	if m != nil {
		return m.ChangeBps
	}
	return 0
}

// MsgUpdateVaultConfig allows authority to update vault configuration
type MsgUpdateVaultConfig struct {
	// Authority updating the config
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// New vault configuration
	Config VaultConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config"`
	// Reason for config update
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgUpdateVaultConfig) Reset()         { *m = MsgUpdateVaultConfig{} }
func (m *MsgUpdateVaultConfig) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateVaultConfig) ProtoMessage()    {}
func (*MsgUpdateVaultConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{14}
}
func (m *MsgUpdateVaultConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateVaultConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateVaultConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateVaultConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateVaultConfig.Merge(m, src)
}
func (m *MsgUpdateVaultConfig) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateVaultConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateVaultConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateVaultConfig proto.InternalMessageInfo

// MsgUpdateVaultConfigResponse confirms config update
type MsgUpdateVaultConfigResponse struct {
	// Previous configuration (JSON)
	PreviousConfig string `protobuf:"bytes,1,opt,name=previous_config,json=previousConfig,proto3" json:"previous_config,omitempty"`
	// New configuration (JSON)
	NewConfig string `protobuf:"bytes,2,opt,name=new_config,json=newConfig,proto3" json:"new_config,omitempty"`
}

func (m *MsgUpdateVaultConfigResponse) Reset()         { *m = MsgUpdateVaultConfigResponse{} }
func (m *MsgUpdateVaultConfigResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateVaultConfigResponse) ProtoMessage()    {}
func (*MsgUpdateVaultConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{15}
}
func (m *MsgUpdateVaultConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateVaultConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateVaultConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateVaultConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateVaultConfigResponse.Merge(m, src)
}
func (m *MsgUpdateVaultConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateVaultConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateVaultConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateVaultConfigResponse proto.InternalMessageInfo

func (m *MsgUpdateVaultConfigResponse) GetPreviousConfig() string {
	if m != nil {
		return m.PreviousConfig
	}
	return ""
}

func (m *MsgUpdateVaultConfigResponse) GetNewConfig() string {
	if m != nil {
		return m.NewConfig
	}
	return ""
}

// MsgUpdateParams allows authority to update module parameters
type MsgUpdateParams struct {
	// Authority updating the parameters
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// New parameters
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{16}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

// MsgUpdateParamsResponse confirms parameter update
type MsgUpdateParamsResponse struct {
	// Previous parameters (JSON)
	PreviousParams string `protobuf:"bytes,1,opt,name=previous_params,json=previousParams,proto3" json:"previous_params,omitempty"`
	// New parameters (JSON)
	NewParams string `protobuf:"bytes,2,opt,name=new_params,json=newParams,proto3" json:"new_params,omitempty"`
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{17}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

func (m *MsgUpdateParamsResponse) GetPreviousParams() string {
	if m != nil {
		return m.PreviousParams
	}
	return ""
}

func (m *MsgUpdateParamsResponse) GetNewParams() string {
	if m != nil {
		return m.NewParams
	}
	return ""
}

// MsgCreateCrossChainRoute creates a new cross-chain route
type MsgCreateCrossChainRoute struct {
	// Authority creating the route
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Route configuration
	Route CrossChainRoute `protobuf:"bytes,2,opt,name=route,proto3" json:"route"`
}

func (m *MsgCreateCrossChainRoute) Reset()         { *m = MsgCreateCrossChainRoute{} }
func (m *MsgCreateCrossChainRoute) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCrossChainRoute) ProtoMessage()    {}
func (*MsgCreateCrossChainRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{18}
}
func (m *MsgCreateCrossChainRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCrossChainRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCrossChainRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCrossChainRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCrossChainRoute.Merge(m, src)
}
func (m *MsgCreateCrossChainRoute) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCrossChainRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCrossChainRoute.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCrossChainRoute proto.InternalMessageInfo

// MsgCreateCrossChainRouteResponse confirms route creation
type MsgCreateCrossChainRouteResponse struct {
	// Created route ID
	RouteId string `protobuf:"bytes,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Route configuration
	RouteConfig string `protobuf:"bytes,2,opt,name=route_config,json=routeConfig,proto3" json:"route_config,omitempty"`
}

func (m *MsgCreateCrossChainRouteResponse) Reset()         { *m = MsgCreateCrossChainRouteResponse{} }
func (m *MsgCreateCrossChainRouteResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCrossChainRouteResponse) ProtoMessage()    {}
func (*MsgCreateCrossChainRouteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{19}
}
func (m *MsgCreateCrossChainRouteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCrossChainRouteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCrossChainRouteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCrossChainRouteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCrossChainRouteResponse.Merge(m, src)
}
func (m *MsgCreateCrossChainRouteResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCrossChainRouteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCrossChainRouteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCrossChainRouteResponse proto.InternalMessageInfo

func (m *MsgCreateCrossChainRouteResponse) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *MsgCreateCrossChainRouteResponse) GetRouteConfig() string {
	if m != nil {
		return m.RouteConfig
	}
	return ""
}

// MsgUpdateCrossChainRoute updates an existing cross-chain route
type MsgUpdateCrossChainRoute struct {
	// Authority updating the route
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Route ID to update
	RouteId string `protobuf:"bytes,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Updated route configuration
	Route CrossChainRoute `protobuf:"bytes,3,opt,name=route,proto3" json:"route"`
}

func (m *MsgUpdateCrossChainRoute) Reset()         { *m = MsgUpdateCrossChainRoute{} }
func (m *MsgUpdateCrossChainRoute) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCrossChainRoute) ProtoMessage()    {}
func (*MsgUpdateCrossChainRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{20}
}
func (m *MsgUpdateCrossChainRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCrossChainRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCrossChainRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCrossChainRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCrossChainRoute.Merge(m, src)
}
func (m *MsgUpdateCrossChainRoute) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCrossChainRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCrossChainRoute.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCrossChainRoute proto.InternalMessageInfo

// MsgUpdateCrossChainRouteResponse confirms route update
type MsgUpdateCrossChainRouteResponse struct {
	// Updated route ID
	RouteId string `protobuf:"bytes,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Previous configuration
	PreviousConfig string `protobuf:"bytes,2,opt,name=previous_config,json=previousConfig,proto3" json:"previous_config,omitempty"`
	// New configuration
	NewConfig string `protobuf:"bytes,3,opt,name=new_config,json=newConfig,proto3" json:"new_config,omitempty"`
}

func (m *MsgUpdateCrossChainRouteResponse) Reset()         { *m = MsgUpdateCrossChainRouteResponse{} }
func (m *MsgUpdateCrossChainRouteResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCrossChainRouteResponse) ProtoMessage()    {}
func (*MsgUpdateCrossChainRouteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{21}
}
func (m *MsgUpdateCrossChainRouteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCrossChainRouteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCrossChainRouteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCrossChainRouteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCrossChainRouteResponse.Merge(m, src)
}
func (m *MsgUpdateCrossChainRouteResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCrossChainRouteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCrossChainRouteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCrossChainRouteResponse proto.InternalMessageInfo

func (m *MsgUpdateCrossChainRouteResponse) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *MsgUpdateCrossChainRouteResponse) GetPreviousConfig() string {
	if m != nil {
		return m.PreviousConfig
	}
	return ""
}

func (m *MsgUpdateCrossChainRouteResponse) GetNewConfig() string {
	if m != nil {
		return m.NewConfig
	}
	return ""
}

// MsgDisableCrossChainRoute disables a cross-chain route
type MsgDisableCrossChainRoute struct {
	// Authority disabling the route
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Route ID to disable
	RouteId string `protobuf:"bytes,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Reason for disabling
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgDisableCrossChainRoute) Reset()         { *m = MsgDisableCrossChainRoute{} }
func (m *MsgDisableCrossChainRoute) String() string { return proto.CompactTextString(m) }
func (*MsgDisableCrossChainRoute) ProtoMessage()    {}
func (*MsgDisableCrossChainRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{22}
}
func (m *MsgDisableCrossChainRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisableCrossChainRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisableCrossChainRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisableCrossChainRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisableCrossChainRoute.Merge(m, src)
}
func (m *MsgDisableCrossChainRoute) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisableCrossChainRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisableCrossChainRoute.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisableCrossChainRoute proto.InternalMessageInfo

// MsgDisableCrossChainRouteResponse confirms route disabling
type MsgDisableCrossChainRouteResponse struct {
	// Disabled route ID
	RouteId string `protobuf:"bytes,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Number of affected positions
	AffectedPositions int64 `protobuf:"varint,2,opt,name=affected_positions,json=affectedPositions,proto3" json:"affected_positions,omitempty"`
}

func (m *MsgDisableCrossChainRouteResponse) Reset()         { *m = MsgDisableCrossChainRouteResponse{} }
func (m *MsgDisableCrossChainRouteResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDisableCrossChainRouteResponse) ProtoMessage()    {}
func (*MsgDisableCrossChainRouteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{23}
}
func (m *MsgDisableCrossChainRouteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisableCrossChainRouteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisableCrossChainRouteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisableCrossChainRouteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisableCrossChainRouteResponse.Merge(m, src)
}
func (m *MsgDisableCrossChainRouteResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisableCrossChainRouteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisableCrossChainRouteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisableCrossChainRouteResponse proto.InternalMessageInfo

func (m *MsgDisableCrossChainRouteResponse) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *MsgDisableCrossChainRouteResponse) GetAffectedPositions() int64 {
	if m != nil {
		return m.AffectedPositions
	}
	return 0
}

// MsgRemoteDeposit initiates a deposit to a remote chain
type MsgRemoteDeposit struct {
	// User making the remote deposit
	Depositor string `protobuf:"bytes,1,opt,name=depositor,proto3" json:"depositor,omitempty"`
	// Route ID for the deposit
	RouteId string `protobuf:"bytes,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Amount to deposit
	Amount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// Remote address to receive the position
	RemoteAddress string `protobuf:"bytes,4,opt,name=remote_address,json=remoteAddress,proto3" json:"remote_address,omitempty"`
	// Minimum shares to receive (slippage protection)
	MinShares cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=min_shares,json=minShares,proto3,customtype=cosmossdk.io/math.Int" json:"min_shares"`
	// Gas limit for remote execution (Hyperlane only)
	GasLimit uint64 `protobuf:"varint,6,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	// Gas price for remote execution (Hyperlane only)
	GasPrice cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=gas_price,json=gasPrice,proto3,customtype=cosmossdk.io/math.Int" json:"gas_price"`
}

func (m *MsgRemoteDeposit) Reset()         { *m = MsgRemoteDeposit{} }
func (m *MsgRemoteDeposit) String() string { return proto.CompactTextString(m) }
func (*MsgRemoteDeposit) ProtoMessage()    {}
func (*MsgRemoteDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{24}
}
func (m *MsgRemoteDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoteDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoteDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoteDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoteDeposit.Merge(m, src)
}
func (m *MsgRemoteDeposit) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoteDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoteDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoteDeposit proto.InternalMessageInfo

// MsgRemoteDepositResponse returns the results of a remote deposit
type MsgRemoteDepositResponse struct {
	// Operation nonce for tracking
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Route ID used
	RouteId string `protobuf:"bytes,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Local shares allocated
	SharesAllocated cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=shares_allocated,json=sharesAllocated,proto3,customtype=cosmossdk.io/math.Int" json:"shares_allocated"`
	// Amount sent to remote chain
	AmountSent cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=amount_sent,json=amountSent,proto3,customtype=cosmossdk.io/math.Int" json:"amount_sent"`
	// Expected completion time
	ExpectedCompletion time.Time `protobuf:"bytes,5,opt,name=expected_completion,json=expectedCompletion,proto3,stdtime" json:"expected_completion"`
	// Provider-specific tracking information
	ProviderTracking *ProviderTrackingInfo `protobuf:"bytes,6,opt,name=provider_tracking,json=providerTracking,proto3" json:"provider_tracking,omitempty"`
}

func (m *MsgRemoteDepositResponse) Reset()         { *m = MsgRemoteDepositResponse{} }
func (m *MsgRemoteDepositResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRemoteDepositResponse) ProtoMessage()    {}
func (*MsgRemoteDepositResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{25}
}
func (m *MsgRemoteDepositResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoteDepositResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoteDepositResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoteDepositResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoteDepositResponse.Merge(m, src)
}
func (m *MsgRemoteDepositResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoteDepositResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoteDepositResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoteDepositResponse proto.InternalMessageInfo

func (m *MsgRemoteDepositResponse) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *MsgRemoteDepositResponse) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *MsgRemoteDepositResponse) GetExpectedCompletion() time.Time {
	if m != nil {
		return m.ExpectedCompletion
	}
	return time.Time{}
}

func (m *MsgRemoteDepositResponse) GetProviderTracking() *ProviderTrackingInfo {
	if m != nil {
		return m.ProviderTracking
	}
	return nil
}

// MsgRemoteWithdraw initiates a withdrawal from a remote chain
type MsgRemoteWithdraw struct {
	// User making the remote withdrawal
	Withdrawer string `protobuf:"bytes,1,opt,name=withdrawer,proto3" json:"withdrawer,omitempty"`
	// Route ID for the withdrawal
	RouteId string `protobuf:"bytes,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Shares to withdraw from remote position
	Shares cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=shares,proto3,customtype=cosmossdk.io/math.Int" json:"shares"`
	// Minimum amount to receive (slippage protection)
	MinAmount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=min_amount,json=minAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_amount"`
	// Gas limit for remote execution (Hyperlane only)
	GasLimit uint64 `protobuf:"varint,5,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	// Gas price for remote execution (Hyperlane only)
	GasPrice cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=gas_price,json=gasPrice,proto3,customtype=cosmossdk.io/math.Int" json:"gas_price"`
}

func (m *MsgRemoteWithdraw) Reset()         { *m = MsgRemoteWithdraw{} }
func (m *MsgRemoteWithdraw) String() string { return proto.CompactTextString(m) }
func (*MsgRemoteWithdraw) ProtoMessage()    {}
func (*MsgRemoteWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{26}
}
func (m *MsgRemoteWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoteWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoteWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoteWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoteWithdraw.Merge(m, src)
}
func (m *MsgRemoteWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoteWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoteWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoteWithdraw proto.InternalMessageInfo

// MsgRemoteWithdrawResponse returns the results of a remote withdrawal
type MsgRemoteWithdrawResponse struct {
	// Operation nonce for tracking
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Route ID used
	RouteId string `protobuf:"bytes,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Shares being withdrawn
	SharesWithdrawn cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=shares_withdrawn,json=sharesWithdrawn,proto3,customtype=cosmossdk.io/math.Int" json:"shares_withdrawn"`
	// Expected amount to receive
	ExpectedAmount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=expected_amount,json=expectedAmount,proto3,customtype=cosmossdk.io/math.Int" json:"expected_amount"`
	// Expected completion time
	ExpectedCompletion time.Time `protobuf:"bytes,5,opt,name=expected_completion,json=expectedCompletion,proto3,stdtime" json:"expected_completion"`
	// Provider-specific tracking information
	ProviderTracking *ProviderTrackingInfo `protobuf:"bytes,6,opt,name=provider_tracking,json=providerTracking,proto3" json:"provider_tracking,omitempty"`
}

func (m *MsgRemoteWithdrawResponse) Reset()         { *m = MsgRemoteWithdrawResponse{} }
func (m *MsgRemoteWithdrawResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRemoteWithdrawResponse) ProtoMessage()    {}
func (*MsgRemoteWithdrawResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{27}
}
func (m *MsgRemoteWithdrawResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoteWithdrawResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoteWithdrawResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoteWithdrawResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoteWithdrawResponse.Merge(m, src)
}
func (m *MsgRemoteWithdrawResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoteWithdrawResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoteWithdrawResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoteWithdrawResponse proto.InternalMessageInfo

func (m *MsgRemoteWithdrawResponse) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *MsgRemoteWithdrawResponse) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *MsgRemoteWithdrawResponse) GetExpectedCompletion() time.Time {
	if m != nil {
		return m.ExpectedCompletion
	}
	return time.Time{}
}

func (m *MsgRemoteWithdrawResponse) GetProviderTracking() *ProviderTrackingInfo {
	if m != nil {
		return m.ProviderTracking
	}
	return nil
}

// MsgUpdateRemotePosition updates a remote position status
type MsgUpdateRemotePosition struct {
	// Relayer updating the position
	Relayer string `protobuf:"bytes,1,opt,name=relayer,proto3" json:"relayer,omitempty"`
	// Route ID
	RouteId string `protobuf:"bytes,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// User address
	UserAddress []byte `protobuf:"bytes,3,opt,name=user_address,json=userAddress,proto3" json:"user_address,omitempty"`
	// Updated remote value
	RemoteValue cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=remote_value,json=remoteValue,proto3,customtype=cosmossdk.io/math.Int" json:"remote_value"`
	// Number of confirmations
	Confirmations uint64 `protobuf:"varint,5,opt,name=confirmations,proto3" json:"confirmations,omitempty"`
	// Provider-specific tracking information
	ProviderTracking *ProviderTrackingInfo `protobuf:"bytes,6,opt,name=provider_tracking,json=providerTracking,proto3" json:"provider_tracking,omitempty"`
	// Position status
	Status RemotePositionStatus `protobuf:"varint,7,opt,name=status,proto3,enum=noble.dollar.vaults.v2.RemotePositionStatus" json:"status,omitempty"`
}

func (m *MsgUpdateRemotePosition) Reset()         { *m = MsgUpdateRemotePosition{} }
func (m *MsgUpdateRemotePosition) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateRemotePosition) ProtoMessage()    {}
func (*MsgUpdateRemotePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{28}
}
func (m *MsgUpdateRemotePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateRemotePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateRemotePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateRemotePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateRemotePosition.Merge(m, src)
}
func (m *MsgUpdateRemotePosition) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateRemotePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateRemotePosition.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateRemotePosition proto.InternalMessageInfo

// MsgUpdateRemotePositionResponse confirms position update
type MsgUpdateRemotePositionResponse struct {
	// Route ID
	RouteId string `protobuf:"bytes,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// User address
	UserAddress []byte `protobuf:"bytes,2,opt,name=user_address,json=userAddress,proto3" json:"user_address,omitempty"`
	// Previous value
	PreviousValue cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=previous_value,json=previousValue,proto3,customtype=cosmossdk.io/math.Int" json:"previous_value"`
	// New value
	NewValue cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=new_value,json=newValue,proto3,customtype=cosmossdk.io/math.Int" json:"new_value"`
	// Conservative value (with haircut)
	ConservativeValue cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=conservative_value,json=conservativeValue,proto3,customtype=cosmossdk.io/math.Int" json:"conservative_value"`
}

func (m *MsgUpdateRemotePositionResponse) Reset()         { *m = MsgUpdateRemotePositionResponse{} }
func (m *MsgUpdateRemotePositionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateRemotePositionResponse) ProtoMessage()    {}
func (*MsgUpdateRemotePositionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{29}
}
func (m *MsgUpdateRemotePositionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateRemotePositionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateRemotePositionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateRemotePositionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateRemotePositionResponse.Merge(m, src)
}
func (m *MsgUpdateRemotePositionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateRemotePositionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateRemotePositionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateRemotePositionResponse proto.InternalMessageInfo

func (m *MsgUpdateRemotePositionResponse) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *MsgUpdateRemotePositionResponse) GetUserAddress() []byte {
	if m != nil {
		return m.UserAddress
	}
	return nil
}

// MsgProcessInFlightPosition processes an in-flight position
type MsgProcessInFlightPosition struct {
	// Authority processing the position
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Operation nonce
	Nonce uint64 `protobuf:"varint,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Operation result
	ResultStatus InFlightStatus `protobuf:"varint,3,opt,name=result_status,json=resultStatus,proto3,enum=noble.dollar.vaults.v2.InFlightStatus" json:"result_status,omitempty"`
	// Result amount (for successful operations)
	ResultAmount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=result_amount,json=resultAmount,proto3,customtype=cosmossdk.io/math.Int" json:"result_amount"`
	// Error message (for failed operations)
	ErrorMessage string `protobuf:"bytes,5,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Provider-specific tracking information
	ProviderTracking *ProviderTrackingInfo `protobuf:"bytes,6,opt,name=provider_tracking,json=providerTracking,proto3" json:"provider_tracking,omitempty"`
}

func (m *MsgProcessInFlightPosition) Reset()         { *m = MsgProcessInFlightPosition{} }
func (m *MsgProcessInFlightPosition) String() string { return proto.CompactTextString(m) }
func (*MsgProcessInFlightPosition) ProtoMessage()    {}
func (*MsgProcessInFlightPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{30}
}
func (m *MsgProcessInFlightPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProcessInFlightPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProcessInFlightPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProcessInFlightPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProcessInFlightPosition.Merge(m, src)
}
func (m *MsgProcessInFlightPosition) XXX_Size() int {
	return m.Size()
}
func (m *MsgProcessInFlightPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProcessInFlightPosition.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProcessInFlightPosition proto.InternalMessageInfo

// MsgProcessInFlightPositionResponse confirms processing
type MsgProcessInFlightPositionResponse struct {
	// Operation nonce
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Final status
	FinalStatus InFlightStatus `protobuf:"varint,2,opt,name=final_status,json=finalStatus,proto3,enum=noble.dollar.vaults.v2.InFlightStatus" json:"final_status,omitempty"`
	// Amount processed
	AmountProcessed cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount_processed,json=amountProcessed,proto3,customtype=cosmossdk.io/math.Int" json:"amount_processed"`
	// Shares affected
	SharesAffected cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=shares_affected,json=sharesAffected,proto3,customtype=cosmossdk.io/math.Int" json:"shares_affected"`
}

func (m *MsgProcessInFlightPositionResponse) Reset()         { *m = MsgProcessInFlightPositionResponse{} }
func (m *MsgProcessInFlightPositionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProcessInFlightPositionResponse) ProtoMessage()    {}
func (*MsgProcessInFlightPositionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{31}
}
func (m *MsgProcessInFlightPositionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProcessInFlightPositionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProcessInFlightPositionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProcessInFlightPositionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProcessInFlightPositionResponse.Merge(m, src)
}
func (m *MsgProcessInFlightPositionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProcessInFlightPositionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProcessInFlightPositionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProcessInFlightPositionResponse proto.InternalMessageInfo

func (m *MsgProcessInFlightPositionResponse) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *MsgProcessInFlightPositionResponse) GetFinalStatus() InFlightStatus {
	if m != nil {
		return m.FinalStatus
	}
	return INFLIGHT_PENDING
}

func init() {
	proto.RegisterType((*MsgDeposit)(nil), "noble.dollar.vaults.v2.MsgDeposit")
	proto.RegisterType((*MsgDepositResponse)(nil), "noble.dollar.vaults.v2.MsgDepositResponse")
	proto.RegisterType((*MsgWithdraw)(nil), "noble.dollar.vaults.v2.MsgWithdraw")
	proto.RegisterType((*MsgWithdrawResponse)(nil), "noble.dollar.vaults.v2.MsgWithdrawResponse")
	proto.RegisterType((*MsgRequestExit)(nil), "noble.dollar.vaults.v2.MsgRequestExit")
	proto.RegisterType((*MsgRequestExitResponse)(nil), "noble.dollar.vaults.v2.MsgRequestExitResponse")
	proto.RegisterType((*MsgCancelExit)(nil), "noble.dollar.vaults.v2.MsgCancelExit")
	proto.RegisterType((*MsgCancelExitResponse)(nil), "noble.dollar.vaults.v2.MsgCancelExitResponse")
	proto.RegisterType((*MsgSetYieldPreference)(nil), "noble.dollar.vaults.v2.MsgSetYieldPreference")
	proto.RegisterType((*MsgSetYieldPreferenceResponse)(nil), "noble.dollar.vaults.v2.MsgSetYieldPreferenceResponse")
	proto.RegisterType((*MsgProcessExitQueue)(nil), "noble.dollar.vaults.v2.MsgProcessExitQueue")
	proto.RegisterType((*MsgProcessExitQueueResponse)(nil), "noble.dollar.vaults.v2.MsgProcessExitQueueResponse")
	proto.RegisterType((*MsgUpdateNAV)(nil), "noble.dollar.vaults.v2.MsgUpdateNAV")
	proto.RegisterType((*MsgUpdateNAVResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateNAVResponse")
	proto.RegisterType((*MsgUpdateVaultConfig)(nil), "noble.dollar.vaults.v2.MsgUpdateVaultConfig")
	proto.RegisterType((*MsgUpdateVaultConfigResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateVaultConfigResponse")
	proto.RegisterType((*MsgUpdateParams)(nil), "noble.dollar.vaults.v2.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgCreateCrossChainRoute)(nil), "noble.dollar.vaults.v2.MsgCreateCrossChainRoute")
	proto.RegisterType((*MsgCreateCrossChainRouteResponse)(nil), "noble.dollar.vaults.v2.MsgCreateCrossChainRouteResponse")
	proto.RegisterType((*MsgUpdateCrossChainRoute)(nil), "noble.dollar.vaults.v2.MsgUpdateCrossChainRoute")
	proto.RegisterType((*MsgUpdateCrossChainRouteResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateCrossChainRouteResponse")
	proto.RegisterType((*MsgDisableCrossChainRoute)(nil), "noble.dollar.vaults.v2.MsgDisableCrossChainRoute")
	proto.RegisterType((*MsgDisableCrossChainRouteResponse)(nil), "noble.dollar.vaults.v2.MsgDisableCrossChainRouteResponse")
	proto.RegisterType((*MsgRemoteDeposit)(nil), "noble.dollar.vaults.v2.MsgRemoteDeposit")
	proto.RegisterType((*MsgRemoteDepositResponse)(nil), "noble.dollar.vaults.v2.MsgRemoteDepositResponse")
	proto.RegisterType((*MsgRemoteWithdraw)(nil), "noble.dollar.vaults.v2.MsgRemoteWithdraw")
	proto.RegisterType((*MsgRemoteWithdrawResponse)(nil), "noble.dollar.vaults.v2.MsgRemoteWithdrawResponse")
	proto.RegisterType((*MsgUpdateRemotePosition)(nil), "noble.dollar.vaults.v2.MsgUpdateRemotePosition")
	proto.RegisterType((*MsgUpdateRemotePositionResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateRemotePositionResponse")
	proto.RegisterType((*MsgProcessInFlightPosition)(nil), "noble.dollar.vaults.v2.MsgProcessInFlightPosition")
	proto.RegisterType((*MsgProcessInFlightPositionResponse)(nil), "noble.dollar.vaults.v2.MsgProcessInFlightPositionResponse")
}

func init() { proto.RegisterFile("noble/dollar/vaults/v2/tx.proto", fileDescriptor_c482f72d5d8ce397) }

var fileDescriptor_c482f72d5d8ce397 = []byte{
	// 2451 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x5a, 0xcb, 0x73, 0x1c, 0x47,
	0x19, 0xd7, 0xec, 0x4a, 0xb2, 0xf4, 0xed, 0x4a, 0xb2, 0xc6, 0xb2, 0x2c, 0xaf, 0x63, 0xc9, 0x1e,
	0xbf, 0x84, 0xb1, 0x77, 0x6d, 0x99, 0x38, 0xf6, 0x92, 0x50, 0xa5, 0x47, 0x28, 0x54, 0x64, 0x83,
	0x32, 0xb2, 0xe5, 0x32, 0xa1, 0x18, 0x5a, 0xbb, 0xad, 0xd1, 0xe0, 0xdd, 0x99, 0x65, 0x7a, 0x76,
	0x25, 0xe5, 0x94, 0x82, 0x82, 0x02, 0x4e, 0xb9, 0x72, 0xcb, 0x85, 0x82, 0x03, 0xa1, 0x7c, 0x08,
	0x54, 0x71, 0xe0, 0xc0, 0x89, 0x14, 0x14, 0x90, 0x0a, 0x17, 0x2a, 0x87, 0x90, 0xb2, 0x0f, 0xf6,
	0x1f, 0x40, 0xee, 0x54, 0x3f, 0xa6, 0x67, 0x66, 0x77, 0x66, 0xb5, 0x0f, 0x25, 0x55, 0xb9, 0xd8,
	0x3b, 0xdd, 0xdf, 0xab, 0x7f, 0xdf, 0xaf, 0xbb, 0xbf, 0xf9, 0x46, 0xb0, 0x60, 0x3b, 0xdb, 0x55,
	0x5c, 0xa8, 0x38, 0xd5, 0x2a, 0x72, 0x0b, 0x4d, 0xd4, 0xa8, 0x7a, 0xa4, 0xd0, 0x5c, 0x2a, 0x78,
	0xfb, 0xf9, 0xba, 0xeb, 0x78, 0x8e, 0x3a, 0xcb, 0x04, 0xf2, 0x5c, 0x20, 0xcf, 0x05, 0xf2, 0xcd,
	0xa5, 0xdc, 0x34, 0xaa, 0x59, 0xb6, 0x53, 0x60, 0xff, 0x72, 0xd1, 0xdc, 0xa9, 0xb2, 0x43, 0x6a,
	0x0e, 0x29, 0xd4, 0x88, 0x59, 0x68, 0xde, 0xa4, 0xff, 0x89, 0x89, 0xd3, 0x7c, 0xc2, 0x60, 0x4f,
	0x05, 0xfe, 0x20, 0xa6, 0x66, 0x4c, 0xc7, 0x74, 0xf8, 0x38, 0xfd, 0x25, 0x46, 0x17, 0x4c, 0xc7,
	0x31, 0xab, 0xb8, 0xc0, 0x9e, 0xb6, 0x1b, 0x3b, 0x05, 0xcf, 0xaa, 0x61, 0xe2, 0xa1, 0x5a, 0x5d,
	0x08, 0x5c, 0x88, 0x0d, 0xfb, 0xa6, 0xf8, 0x25, 0x84, 0x16, 0x13, 0xd6, 0x56, 0x76, 0x1d, 0x42,
	0x8c, 0xf2, 0x2e, 0xb2, 0x6c, 0x21, 0x79, 0x31, 0x41, 0xd2, 0xc4, 0x36, 0x26, 0x96, 0xb0, 0xa7,
	0xfd, 0x29, 0x05, 0x50, 0x22, 0xe6, 0x1a, 0xae, 0x3b, 0xc4, 0xf2, 0xd4, 0xdb, 0x30, 0x5e, 0xe1,
	0x3f, 0x1d, 0x77, 0x4e, 0x39, 0xa7, 0x2c, 0x8e, 0xaf, 0xcc, 0x7d, 0xf4, 0xfe, 0xf5, 0x19, 0xb1,
	0xbe, 0xe5, 0x4a, 0xc5, 0xc5, 0x84, 0x6c, 0x7a, 0xae, 0x65, 0x9b, 0x7a, 0x20, 0xaa, 0x7e, 0x0b,
	0x46, 0x51, 0xcd, 0x69, 0xd8, 0xde, 0x5c, 0x8a, 0x29, 0xdd, 0xf8, 0xe0, 0x93, 0x85, 0xa1, 0x8f,
	0x3f, 0x59, 0x38, 0xc9, 0x15, 0x49, 0xe5, 0x51, 0xde, 0x72, 0x0a, 0x35, 0xe4, 0xed, 0xe6, 0xd7,
	0x6d, 0xef, 0xa3, 0xf7, 0xaf, 0x83, 0xb0, 0xb8, 0x6e, 0x7b, 0xbf, 0x7d, 0xf6, 0xf8, 0xaa, 0xa2,
	0x0b, 0x7d, 0xf5, 0x02, 0x4c, 0xb8, 0xb8, 0x8c, 0xad, 0x26, 0x36, 0x0e, 0x2c, 0x5c, 0xad, 0xcc,
	0xa5, 0xcf, 0x29, 0x8b, 0x63, 0x7a, 0x56, 0x0c, 0x3e, 0xa4, 0x63, 0xea, 0x77, 0x00, 0x6a, 0x96,
	0x6d, 0x90, 0x5d, 0xe4, 0x62, 0x32, 0x37, 0xdc, 0xa7, 0xcb, 0xf1, 0x9a, 0x65, 0x6f, 0x32, 0x13,
	0xc5, 0x5b, 0x3f, 0x7f, 0x77, 0x61, 0xe8, 0xf9, 0xbb, 0x0b, 0x43, 0x3f, 0x7e, 0xf6, 0xf8, 0x6a,
	0xb0, 0xae, 0x5f, 0x3e, 0x7b, 0x7c, 0x75, 0xae, 0x0d, 0x41, 0x01, 0x96, 0xf6, 0xbf, 0x14, 0xa8,
	0x01, 0x76, 0x3a, 0x26, 0x75, 0xc7, 0x26, 0x58, 0x7d, 0x08, 0x53, 0x3c, 0x30, 0x43, 0xc4, 0x5c,
	0x11, 0x48, 0xf6, 0x1e, 0xe1, 0x24, 0x37, 0xa4, 0x0b, 0x3b, 0xea, 0x9b, 0x70, 0x9c, 0xc3, 0x64,
	0x88, 0x10, 0x71, 0xa5, 0x6f, 0xc0, 0xa7, 0xb8, 0xa5, 0x35, 0xdf, 0x90, 0x5a, 0x82, 0xf1, 0x1d,
	0x8c, 0x89, 0x51, 0x47, 0x16, 0x47, 0xbd, 0x1f, 0xab, 0x63, 0xd4, 0xc4, 0x06, 0xb2, 0x2a, 0xea,
	0x03, 0xc8, 0xb0, 0xe8, 0x8d, 0xba, 0x6b, 0x95, 0xb1, 0x48, 0xd2, 0x6d, 0x61, 0xf0, 0x4c, 0xbb,
	0xc1, 0xd7, 0xb0, 0x89, 0xca, 0x07, 0x6b, 0xb8, 0x1c, 0x32, 0xbb, 0x86, 0xcb, 0xdc, 0x2c, 0x30,
	0x53, 0x1b, 0xd4, 0x92, 0xf6, 0xab, 0x14, 0x64, 0x4a, 0xc4, 0x7c, 0x60, 0x79, 0xbb, 0x15, 0x17,
	0xed, 0xa9, 0x77, 0x00, 0xf6, 0xc4, 0x6f, 0x7c, 0x38, 0x69, 0x43, 0xb2, 0x94, 0xb5, 0x82, 0x42,
	0x7d, 0xb3, 0x96, 0xeb, 0xfb, 0x84, 0x14, 0x7b, 0x20, 0x3d, 0x00, 0x21, 0x97, 0x99, 0x89, 0xe2,
	0x8b, 0x61, 0x42, 0x86, 0x62, 0xa6, 0x8c, 0x3c, 0xdd, 0xc6, 0x48, 0x1f, 0x0b, 0xed, 0xb3, 0x14,
	0x9c, 0x08, 0x61, 0x23, 0x39, 0x19, 0x10, 0xc7, 0x37, 0x65, 0xf7, 0x4d, 0x4a, 0x41, 0x1c, 0xdf,
	0x87, 0x1d, 0x21, 0x7c, 0x05, 0xe3, 0xda, 0x00, 0xa4, 0x94, 0x84, 0xe7, 0x76, 0xbe, 0x34, 0x9c,
	0xfc, 0xbb, 0x02, 0x93, 0x25, 0x62, 0xea, 0xf8, 0x47, 0x0d, 0x4c, 0xbc, 0x57, 0xf7, 0xf9, 0x51,
	0xea, 0xf2, 0xc7, 0x2e, 0x58, 0x19, 0x88, 0x1e, 0x1d, 0x29, 0x8b, 0x2f, 0x45, 0x0e, 0x35, 0xe9,
	0x81, 0x52, 0xe8, 0x85, 0x36, 0x0a, 0x85, 0x42, 0xd7, 0xfe, 0x91, 0x82, 0xd9, 0xe8, 0x6a, 0x24,
	0x91, 0x2e, 0xc3, 0x14, 0xde, 0xb7, 0x3c, 0x43, 0x58, 0x33, 0x2c, 0x71, 0xb8, 0xe9, 0x13, 0x98,
	0x89, 0xb1, 0xd1, 0xf5, 0x8a, 0xba, 0x05, 0x22, 0x95, 0x86, 0xe7, 0x18, 0x74, 0xaa, 0xef, 0xd5,
	0x64, 0xb9, 0x9d, 0x7b, 0x0e, 0x43, 0x75, 0x0b, 0x66, 0xf0, 0x7e, 0x1d, 0x97, 0x3d, 0x5c, 0x31,
	0x1a, 0x76, 0xd5, 0x29, 0x3f, 0x32, 0xe8, 0x3d, 0xca, 0xb8, 0x91, 0x59, 0xca, 0xe5, 0xf9, 0x25,
	0x9b, 0xf7, 0x2f, 0xd9, 0xfc, 0x3d, 0xff, 0x92, 0x5d, 0x19, 0xa3, 0x9e, 0xdf, 0xf9, 0xef, 0x82,
	0xa2, 0xab, 0xbe, 0x85, 0xfb, 0xcc, 0x00, 0x15, 0xa1, 0x1b, 0x04, 0x13, 0xcf, 0xaa, 0x21, 0x6a,
	0x58, 0x6c, 0xe3, 0x7e, 0xef, 0x95, 0x29, 0x69, 0x89, 0x6f, 0x66, 0xed, 0x37, 0x0a, 0x4c, 0x94,
	0x88, 0xb9, 0x8a, 0xec, 0x32, 0xae, 0x0e, 0x44, 0x8e, 0x18, 0xf8, 0x53, 0x31, 0xf0, 0x17, 0x6f,
	0x27, 0xa7, 0xfe, 0x4c, 0x5b, 0xea, 0x83, 0xb8, 0xb4, 0xf7, 0x14, 0x38, 0x19, 0x89, 0x34, 0xf6,
	0x56, 0xf3, 0x1a, 0xae, 0x7d, 0x14, 0xb7, 0x1a, 0xb7, 0xa3, 0xde, 0x85, 0xd3, 0x65, 0xe6, 0xb0,
	0x8a, 0x2b, 0x46, 0xfc, 0xf2, 0x66, 0xa5, 0xc0, 0xab, 0xe1, 0x75, 0x6a, 0xbf, 0xe6, 0xf1, 0x6e,
	0x62, 0x8f, 0x15, 0x06, 0x1b, 0x2e, 0xde, 0xc1, 0x2e, 0xb6, 0xcb, 0x58, 0xbd, 0x06, 0xc3, 0x0d,
	0xd2, 0x05, 0xb8, 0x4c, 0xaa, 0xbd, 0xea, 0x48, 0xb5, 0x57, 0x1d, 0xc5, 0xbb, 0x61, 0x50, 0x99,
	0x1e, 0xc5, 0xf3, 0x42, 0x1b, 0x9e, 0xed, 0xd1, 0x68, 0x7b, 0x70, 0x36, 0x36, 0x4c, 0x09, 0x6f,
	0x01, 0x4e, 0xd4, 0x5d, 0xdc, 0xb4, 0x9c, 0x06, 0x2d, 0x29, 0xfd, 0x69, 0x16, 0xfd, 0x98, 0xae,
	0xfa, 0x53, 0xa1, 0xf5, 0x5d, 0x82, 0x49, 0x1b, 0xef, 0x85, 0x65, 0x79, 0xc8, 0x13, 0x36, 0xde,
	0x0b, 0x39, 0xfe, 0xbd, 0xc2, 0x2e, 0x84, 0x0d, 0xd7, 0x29, 0x63, 0x42, 0x28, 0x78, 0x6f, 0x34,
	0x70, 0x03, 0x53, 0x02, 0xa2, 0x86, 0xb7, 0xeb, 0xb8, 0x96, 0x77, 0x70, 0x38, 0x01, 0xa5, 0xa8,
	0x7a, 0x1e, 0xb2, 0x35, 0xb4, 0xef, 0x27, 0x88, 0x9f, 0x51, 0x23, 0x7a, 0xa6, 0x86, 0xf6, 0x45,
	0x52, 0x48, 0xf1, 0xe5, 0x08, 0xf7, 0xa4, 0x2a, 0xc5, 0xea, 0x7c, 0x1b, 0x56, 0xad, 0x81, 0x69,
	0xff, 0x4a, 0xc1, 0x99, 0x98, 0x80, 0x25, 0x50, 0xd7, 0x41, 0xf5, 0x9d, 0xd3, 0xda, 0x9b, 0x0a,
	0x09, 0x2a, 0x8e, 0xe8, 0xd3, 0xfe, 0xcc, 0x86, 0x3f, 0xa1, 0xee, 0xc0, 0xac, 0xe7, 0x78, 0xa8,
	0x2a, 0x6a, 0xc5, 0x90, 0x4a, 0xbf, 0xe7, 0xd1, 0x0c, 0xb3, 0xc7, 0xeb, 0xc6, 0xc0, 0xcf, 0x0f,
	0x61, 0x8e, 0xfb, 0xf1, 0xeb, 0x33, 0x8b, 0x78, 0xae, 0xb5, 0xdd, 0xa0, 0x15, 0x5a, 0xbf, 0xf7,
	0x16, 0x8f, 0x9c, 0x9f, 0x21, 0x6b, 0x81, 0x3d, 0x0e, 0x41, 0x0d, 0x59, 0xb6, 0x65, 0x9b, 0x41,
	0x26, 0x86, 0x7d, 0x08, 0xc4, 0x8c, 0x9f, 0x0f, 0xed, 0x53, 0x05, 0xb2, 0x25, 0x62, 0xde, 0xaf,
	0x57, 0x90, 0x87, 0x5f, 0x5f, 0xde, 0xea, 0x3b, 0xf7, 0xeb, 0x70, 0x8c, 0x52, 0xce, 0x46, 0xcd,
	0xfe, 0xaf, 0x26, 0x1b, 0xef, 0xbd, 0x8e, 0x9a, 0xea, 0x2c, 0x8c, 0xba, 0x18, 0x11, 0xc7, 0xe6,
	0xe0, 0xe8, 0xe2, 0x29, 0x5a, 0xf6, 0x44, 0xb9, 0x93, 0x6b, 0xe3, 0x8e, 0x5c, 0x91, 0xf6, 0x87,
	0x14, 0xcc, 0x84, 0x97, 0x28, 0xd9, 0xb2, 0x09, 0x59, 0xb9, 0xad, 0x68, 0xdc, 0xfd, 0x1e, 0x59,
	0x19, 0xdf, 0x0a, 0x0d, 0xfe, 0x08, 0x71, 0x38, 0x0b, 0x50, 0xde, 0x45, 0xb6, 0x89, 0x8d, 0xed,
	0x3a, 0x61, 0x58, 0x8c, 0xe8, 0xe3, 0x7c, 0x64, 0xa5, 0x4e, 0xd4, 0xef, 0xc3, 0x14, 0xf5, 0x74,
	0x74, 0x35, 0x0b, 0x3d, 0x1d, 0x36, 0x83, 0xb2, 0xe5, 0xb9, 0x12, 0xc2, 0x6d, 0x8b, 0x02, 0xbb,
	0xea, 0xd8, 0x3b, 0x96, 0xd9, 0x37, 0x45, 0x96, 0x61, 0xb4, 0xcc, 0x2c, 0x30, 0x64, 0x32, 0x4b,
	0x17, 0xf2, 0xf1, 0xaf, 0xda, 0xf9, 0x90, 0xb3, 0x95, 0x61, 0xba, 0x18, 0x5d, 0x28, 0x26, 0x52,
	0xe3, 0x95, 0x64, 0x6a, 0x68, 0x09, 0xd4, 0x08, 0x39, 0xd1, 0x76, 0xe0, 0x85, 0xb8, 0x95, 0x4a,
	0xa6, 0x5c, 0x81, 0x29, 0xc9, 0x14, 0xb1, 0x04, 0x5e, 0xd8, 0x4c, 0xfa, 0xc3, 0x02, 0x9a, 0xb3,
	0x00, 0x34, 0x27, 0xa1, 0x65, 0x8e, 0xeb, 0xe3, 0x36, 0xde, 0x13, 0x7e, 0xfe, 0xa2, 0xc0, 0x94,
	0x74, 0xb4, 0x81, 0x5c, 0x54, 0x23, 0x7d, 0xa3, 0xf9, 0x32, 0x8c, 0xd6, 0x99, 0x05, 0x81, 0xe6,
	0x7c, 0x12, 0x9a, 0xdc, 0x8f, 0x0f, 0x24, 0xd7, 0x29, 0xde, 0x49, 0x06, 0xec, 0x6c, 0x02, 0x60,
	0xdc, 0x8e, 0x86, 0xe0, 0x54, 0xcb, 0x12, 0x62, 0x61, 0x12, 0xb1, 0xb5, 0xc0, 0x24, 0xd6, 0x2c,
	0x60, 0x0a, 0xc5, 0xcf, 0x61, 0x12, 0x2e, 0x3e, 0x56, 0x60, 0x8e, 0x16, 0x1a, 0x2e, 0x46, 0x1e,
	0x5e, 0x75, 0x1d, 0x42, 0x56, 0x77, 0x91, 0x65, 0xeb, 0x4e, 0xc3, 0xeb, 0xff, 0x72, 0x5a, 0x85,
	0x11, 0x97, 0x1a, 0x10, 0x70, 0x5d, 0x49, 0x82, 0xab, 0xc5, 0x9f, 0xc0, 0x8d, 0xeb, 0x16, 0x97,
	0x93, 0x61, 0xbb, 0xdc, 0x5e, 0x3a, 0xc5, 0xc5, 0xaf, 0xfd, 0x00, 0xce, 0x25, 0xad, 0x4d, 0x02,
	0x79, 0x1a, 0xc6, 0x98, 0xbf, 0xa0, 0x82, 0x3e, 0xc6, 0x9e, 0xd7, 0x2b, 0xf4, 0x8e, 0xe5, 0x53,
	0x11, 0x8e, 0x65, 0xd8, 0x98, 0x60, 0xd9, 0x67, 0x1c, 0x3e, 0x9e, 0xa2, 0xa3, 0x82, 0x2f, 0x1c,
	0x52, 0x2a, 0x1a, 0x92, 0x44, 0x36, 0xfd, 0x45, 0x21, 0x1b, 0xbb, 0x34, 0xed, 0xa7, 0x0a, 0x83,
	0x36, 0x76, 0xb2, 0x1b, 0x68, 0x63, 0x76, 0x79, 0xaa, 0x8b, 0x5d, 0x9e, 0x6e, 0xdd, 0xe5, 0x7f,
	0x53, 0xe0, 0x74, 0x89, 0x98, 0x6b, 0x16, 0x41, 0xdb, 0xd5, 0x2f, 0x22, 0x01, 0x49, 0xa7, 0xe2,
	0x4a, 0x32, 0xa6, 0x57, 0xda, 0x1b, 0x57, 0xb1, 0xe1, 0x6a, 0x35, 0x38, 0x9f, 0xb8, 0x96, 0x6e,
	0x40, 0xbd, 0x0e, 0x2a, 0xda, 0xd9, 0xe1, 0xef, 0x64, 0xac, 0x99, 0x64, 0x39, 0x36, 0xdf, 0xf2,
	0x69, 0x7d, 0xda, 0x9f, 0xd9, 0xf0, 0x27, 0xb4, 0x7f, 0xa6, 0xe1, 0x38, 0x7b, 0xbb, 0xac, 0x39,
	0x1e, 0x1e, 0xb4, 0xf1, 0xd8, 0x01, 0xb2, 0xa0, 0x27, 0x99, 0x1e, 0xb0, 0x27, 0x79, 0x09, 0x26,
	0x5d, 0x16, 0xad, 0x81, 0x78, 0x1c, 0xfc, 0x16, 0xd6, 0x27, 0xf8, 0xa8, 0x08, 0xae, 0xa5, 0x2b,
	0x39, 0x32, 0x70, 0x57, 0x52, 0x3d, 0x03, 0xe3, 0x26, 0x22, 0x46, 0xd5, 0xaa, 0x59, 0xde, 0xdc,
	0xe8, 0x39, 0x65, 0x71, 0x58, 0x1f, 0x33, 0x11, 0x79, 0x8d, 0x3e, 0xab, 0x25, 0x3e, 0xc9, 0xab,
	0x82, 0x63, 0xfd, 0xb6, 0x46, 0x4c, 0x44, 0x58, 0x29, 0x10, 0x7d, 0xb9, 0x89, 0x76, 0x40, 0xe7,
	0x63, 0x9a, 0x05, 0xa1, 0xdc, 0x69, 0xef, 0xa5, 0xd9, 0x61, 0x14, 0x19, 0x94, 0xbc, 0x99, 0x81,
	0x11, 0xdb, 0xf1, 0x5f, 0x65, 0x86, 0x75, 0xfe, 0xd0, 0x29, 0x6d, 0x6f, 0xc2, 0x71, 0x51, 0xab,
	0xa3, 0x6a, 0xd5, 0x29, 0xa3, 0x41, 0x2a, 0x68, 0xf1, 0xca, 0xba, 0xec, 0x1b, 0x52, 0xdf, 0x80,
	0x8c, 0x28, 0xd0, 0x09, 0x1e, 0xe0, 0x0d, 0x1f, 0xb8, 0x91, 0x4d, 0x6c, 0x7b, 0xea, 0x7d, 0x38,
	0x21, 0x3b, 0x12, 0x65, 0xa7, 0x56, 0xaf, 0x62, 0x4a, 0x73, 0x96, 0xfe, 0x9e, 0x1b, 0x12, 0xab,
	0x52, 0x5f, 0x7d, 0x08, 0xd3, 0x75, 0xd7, 0x69, 0x5a, 0x15, 0xec, 0x1a, 0x9e, 0x8b, 0xca, 0x8f,
	0x2c, 0xdb, 0x64, 0x1c, 0xc8, 0x2c, 0x5d, 0x4b, 0x2c, 0x03, 0x84, 0xc2, 0x3d, 0x21, 0xbf, 0x6e,
	0xef, 0x38, 0xfa, 0xf1, 0x7a, 0xcb, 0xa8, 0xf6, 0xbb, 0x34, 0x4c, 0xcb, 0x7c, 0x1d, 0x41, 0x1b,
	0xb5, 0xf3, 0x1e, 0x14, 0xdb, 0x21, 0x7d, 0xa4, 0x1d, 0xd6, 0xe1, 0x81, 0x3b, 0xac, 0xd1, 0xcd,
	0x35, 0xd2, 0x69, 0x73, 0x8d, 0x0e, 0xbc, 0xb9, 0xbe, 0xde, 0xa1, 0x9b, 0xbb, 0x90, 0xb0, 0xbb,
	0x64, 0x4f, 0xf7, 0x8f, 0x69, 0x76, 0xd7, 0x44, 0x47, 0x8f, 0x62, 0x7f, 0x05, 0xad, 0xe0, 0x01,
	0xf7, 0x57, 0xa4, 0x15, 0x2c, 0x37, 0xc3, 0x80, 0xa9, 0x9a, 0xf4, 0x0d, 0x89, 0x7c, 0x7d, 0xf9,
	0xf6, 0xd9, 0xb3, 0x74, 0xa8, 0x8e, 0xe6, 0xe9, 0xf3, 0x6f, 0x41, 0x75, 0x09, 0x8e, 0xb9, 0xb8,
	0x8a, 0x0e, 0xba, 0xd8, 0x6a, 0xbe, 0x60, 0xa7, 0xa4, 0x9e, 0x87, 0x6c, 0x83, 0x60, 0x57, 0xde,
	0x4f, 0x34, 0xa1, 0x59, 0x3d, 0x43, 0xc7, 0xfc, 0xdb, 0x69, 0x13, 0xb2, 0xe2, 0x12, 0x6b, 0xa2,
	0x6a, 0x03, 0xf7, 0x9d, 0x97, 0x0c, 0xb7, 0xb2, 0x45, 0x8d, 0xa8, 0x17, 0x61, 0x82, 0x95, 0x48,
	0x6e, 0x0d, 0xf1, 0x5b, 0x9f, 0x6f, 0xa4, 0xe8, 0xe0, 0xe7, 0x88, 0xb1, 0xba, 0x06, 0xa3, 0xc4,
	0x43, 0x5e, 0x83, 0xb0, 0x2b, 0x70, 0x32, 0xd9, 0x5e, 0x14, 0xff, 0x4d, 0xa6, 0xa3, 0x0b, 0xdd,
	0xe2, 0x37, 0xc2, 0xfb, 0xd3, 0xc7, 0x9b, 0x6e, 0xce, 0x4b, 0x09, 0x75, 0x69, 0xd4, 0x9a, 0xf6,
	0x3c, 0x05, 0x0b, 0x09, 0x99, 0xee, 0xb2, 0xe0, 0x8f, 0x64, 0x2f, 0xd5, 0x9e, 0xbd, 0x07, 0x20,
	0x2b, 0x54, 0x91, 0xbf, 0x7e, 0xf7, 0xec, 0x84, 0x6f, 0x87, 0x67, 0xb0, 0x04, 0xb4, 0xac, 0x1d,
	0x90, 0x13, 0x63, 0x36, 0xde, 0xe3, 0xe6, 0x0c, 0x50, 0xcb, 0x74, 0xb9, 0x6e, 0x13, 0x79, 0x56,
	0xd3, 0xe7, 0x5a, 0xbf, 0xb5, 0xd0, 0x74, 0xd8, 0x16, 0x73, 0xa0, 0xfd, 0x3b, 0x0d, 0xb9, 0xa0,
	0x3f, 0xb8, 0x6e, 0x7f, 0xb3, 0x6a, 0x99, 0xbb, 0x9e, 0xdc, 0x57, 0xfd, 0x96, 0xde, 0xf2, 0x18,
	0x4d, 0x85, 0x8f, 0xd1, 0x6f, 0xc3, 0x84, 0x8b, 0x49, 0xa3, 0xea, 0x19, 0x82, 0x64, 0x69, 0x46,
	0xb2, 0xcb, 0x49, 0x24, 0xf3, 0xc3, 0x11, 0xf4, 0xca, 0x72, 0x65, 0xfe, 0xa4, 0xde, 0x97, 0xc6,
	0x06, 0x3c, 0x19, 0x85, 0xd9, 0x65, 0xf9, 0xc1, 0x1c, 0xbb, 0xae, 0xe3, 0x1a, 0x35, 0x4c, 0x08,
	0x32, 0x05, 0xd8, 0x7a, 0x96, 0x0d, 0x96, 0xf8, 0xd8, 0xe7, 0xb8, 0x03, 0x8b, 0xab, 0xc9, 0x6f,
	0x20, 0x8b, 0x49, 0xed, 0xde, 0xd6, 0xb4, 0x69, 0x7f, 0x4e, 0x81, 0x96, 0x9c, 0xd5, 0x43, 0x2e,
	0xbb, 0x75, 0xc8, 0xee, 0x58, 0x36, 0xaa, 0xfa, 0x49, 0x4a, 0xf5, 0x94, 0xa4, 0x0c, 0xd3, 0x15,
	0x39, 0x0a, 0xbe, 0x93, 0x06, 0x8d, 0xe2, 0xf4, 0x60, 0xdf, 0x49, 0x83, 0x1e, 0x71, 0xf0, 0x09,
	0xc5, 0x7f, 0x29, 0xea, 0xff, 0x72, 0x14, 0x85, 0xad, 0xb0, 0xb3, 0xf4, 0xd7, 0x49, 0x48, 0x97,
	0x88, 0xa9, 0x3e, 0x84, 0x63, 0xfe, 0x1b, 0x95, 0x96, 0xb4, 0xfe, 0xe0, 0x4f, 0x16, 0x72, 0x57,
	0x0f, 0x97, 0x91, 0xd8, 0x7f, 0x0f, 0xc6, 0x64, 0xad, 0x78, 0xa1, 0x83, 0x9e, 0x2f, 0x94, 0xfb,
	0x6a, 0x17, 0x42, 0xd2, 0x3a, 0x86, 0x4c, 0xf8, 0xe3, 0xe9, 0xe5, 0x0e, 0xba, 0x21, 0xb9, 0x5c,
	0xbe, 0x3b, 0x39, 0xe9, 0x66, 0x1b, 0x20, 0xf4, 0x15, 0xee, 0x52, 0x07, 0xed, 0x40, 0x2c, 0x77,
	0xbd, 0x2b, 0x31, 0xe9, 0xe3, 0x2d, 0x50, 0x63, 0xbe, 0x47, 0x75, 0x32, 0xd2, 0x2e, 0x9e, 0x7b,
	0xb1, 0x27, 0x71, 0xe9, 0xdb, 0x83, 0xe3, 0x6d, 0x9f, 0x7a, 0x3a, 0xe5, 0xa1, 0x55, 0x38, 0x77,
	0xab, 0x07, 0x61, 0xe9, 0xd5, 0x80, 0xf1, 0xe0, 0xeb, 0xc2, 0xc5, 0x0e, 0x16, 0xa4, 0x54, 0xee,
	0x5a, 0x37, 0x52, 0xd2, 0xc1, 0x1e, 0x4c, 0xb7, 0xf7, 0xa8, 0x0f, 0x37, 0x11, 0x92, 0xce, 0x7d,
	0xad, 0x17, 0x69, 0xe9, 0x78, 0x17, 0xb2, 0x91, 0x4e, 0xee, 0x95, 0x43, 0xad, 0x70, 0xc1, 0x5c,
	0xa1, 0x4b, 0x41, 0xe9, 0xe9, 0x27, 0x0a, 0x9c, 0x8c, 0xef, 0x86, 0xde, 0xe8, 0x44, 0xbf, 0x38,
	0x8d, 0xdc, 0x9d, 0x5e, 0x35, 0x22, 0x51, 0xc4, 0x37, 0x15, 0x6f, 0x1c, 0xba, 0xa0, 0x5e, 0xa2,
	0xe8, 0xdc, 0xc0, 0xfb, 0x99, 0x02, 0xb3, 0x09, 0xad, 0xb5, 0x9b, 0x9d, 0x4e, 0xac, 0x58, 0x95,
	0xdc, 0xdd, 0x9e, 0x55, 0x64, 0x20, 0x8f, 0x60, 0x22, 0xda, 0xa6, 0x5a, 0xec, 0x78, 0xde, 0x84,
	0x24, 0x73, 0x37, 0xba, 0x95, 0x94, 0xce, 0x6c, 0x98, 0x6c, 0x79, 0x25, 0xff, 0xca, 0xa1, 0x36,
	0xe4, 0x61, 0x7b, 0xb3, 0x6b, 0x51, 0xe9, 0xef, 0x6d, 0x05, 0x66, 0x62, 0xdf, 0x4d, 0x0e, 0xe7,
	0x6e, 0x54, 0x21, 0xf7, 0x52, 0x8f, 0x0a, 0x32, 0x84, 0x5f, 0x28, 0x70, 0x2a, 0xa9, 0x92, 0x5b,
	0x3a, 0xfc, 0x24, 0x6a, 0xd5, 0xc9, 0x15, 0x7b, 0xd7, 0xf1, 0x63, 0xc9, 0x8d, 0xbc, 0x4d, 0x6f,
	0xd6, 0x95, 0x57, 0x3e, 0x78, 0x32, 0xaf, 0x7c, 0xf8, 0x64, 0x5e, 0xf9, 0xf4, 0xc9, 0xbc, 0xf2,
	0xce, 0xd3, 0xf9, 0xa1, 0x0f, 0x9f, 0xce, 0x0f, 0xfd, 0xe7, 0xe9, 0xfc, 0xd0, 0x77, 0xc5, 0x87,
	0x7e, 0xe1, 0x62, 0xff, 0xe0, 0x2d, 0xf6, 0x37, 0xa5, 0x07, 0x75, 0x4c, 0x82, 0x02, 0x67, 0x7b,
	0x94, 0xbd, 0x80, 0xde, 0xfa, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x61, 0x15, 0x11, 0xfe, 0x84,
	0x2a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Deposit into a V2 vault
	Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error)
	// Withdraw from a V2 vault (flexible vaults only)
	Withdraw(ctx context.Context, in *MsgWithdraw, opts ...grpc.CallOption) (*MsgWithdrawResponse, error)
	// Request exit from a staked vault
	RequestExit(ctx context.Context, in *MsgRequestExit, opts ...grpc.CallOption) (*MsgRequestExitResponse, error)
	// Cancel a pending exit request
	CancelExit(ctx context.Context, in *MsgCancelExit, opts ...grpc.CallOption) (*MsgCancelExitResponse, error)
	// Set yield preference for a user's position
	SetYieldPreference(ctx context.Context, in *MsgSetYieldPreference, opts ...grpc.CallOption) (*MsgSetYieldPreferenceResponse, error)
	// Process exit queue (admin only)
	ProcessExitQueue(ctx context.Context, in *MsgProcessExitQueue, opts ...grpc.CallOption) (*MsgProcessExitQueueResponse, error)
	// Update NAV for a vault (authority only)
	UpdateNAV(ctx context.Context, in *MsgUpdateNAV, opts ...grpc.CallOption) (*MsgUpdateNAVResponse, error)
	// Update vault configuration (authority only)
	UpdateVaultConfig(ctx context.Context, in *MsgUpdateVaultConfig, opts ...grpc.CallOption) (*MsgUpdateVaultConfigResponse, error)
	// Update module parameters (authority only)
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// Create a new cross-chain route (authority only)
	CreateCrossChainRoute(ctx context.Context, in *MsgCreateCrossChainRoute, opts ...grpc.CallOption) (*MsgCreateCrossChainRouteResponse, error)
	// Update an existing cross-chain route (authority only)
	UpdateCrossChainRoute(ctx context.Context, in *MsgUpdateCrossChainRoute, opts ...grpc.CallOption) (*MsgUpdateCrossChainRouteResponse, error)
	// Disable a cross-chain route (authority only)
	DisableCrossChainRoute(ctx context.Context, in *MsgDisableCrossChainRoute, opts ...grpc.CallOption) (*MsgDisableCrossChainRouteResponse, error)
	// Initiate remote deposit to another chain
	RemoteDeposit(ctx context.Context, in *MsgRemoteDeposit, opts ...grpc.CallOption) (*MsgRemoteDepositResponse, error)
	// Initiate remote withdrawal from another chain
	RemoteWithdraw(ctx context.Context, in *MsgRemoteWithdraw, opts ...grpc.CallOption) (*MsgRemoteWithdrawResponse, error)
	// Update remote position status (relayer only)
	UpdateRemotePosition(ctx context.Context, in *MsgUpdateRemotePosition, opts ...grpc.CallOption) (*MsgUpdateRemotePositionResponse, error)
	// Process in-flight position (system operation)
	ProcessInFlightPosition(ctx context.Context, in *MsgProcessInFlightPosition, opts ...grpc.CallOption) (*MsgProcessInFlightPositionResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error) {
	out := new(MsgDepositResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/Deposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Withdraw(ctx context.Context, in *MsgWithdraw, opts ...grpc.CallOption) (*MsgWithdrawResponse, error) {
	out := new(MsgWithdrawResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/Withdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RequestExit(ctx context.Context, in *MsgRequestExit, opts ...grpc.CallOption) (*MsgRequestExitResponse, error) {
	out := new(MsgRequestExitResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/RequestExit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelExit(ctx context.Context, in *MsgCancelExit, opts ...grpc.CallOption) (*MsgCancelExitResponse, error) {
	out := new(MsgCancelExitResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/CancelExit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetYieldPreference(ctx context.Context, in *MsgSetYieldPreference, opts ...grpc.CallOption) (*MsgSetYieldPreferenceResponse, error) {
	out := new(MsgSetYieldPreferenceResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/SetYieldPreference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ProcessExitQueue(ctx context.Context, in *MsgProcessExitQueue, opts ...grpc.CallOption) (*MsgProcessExitQueueResponse, error) {
	out := new(MsgProcessExitQueueResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/ProcessExitQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateNAV(ctx context.Context, in *MsgUpdateNAV, opts ...grpc.CallOption) (*MsgUpdateNAVResponse, error) {
	out := new(MsgUpdateNAVResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateNAV", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateVaultConfig(ctx context.Context, in *MsgUpdateVaultConfig, opts ...grpc.CallOption) (*MsgUpdateVaultConfigResponse, error) {
	out := new(MsgUpdateVaultConfigResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateVaultConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateCrossChainRoute(ctx context.Context, in *MsgCreateCrossChainRoute, opts ...grpc.CallOption) (*MsgCreateCrossChainRouteResponse, error) {
	out := new(MsgCreateCrossChainRouteResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/CreateCrossChainRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateCrossChainRoute(ctx context.Context, in *MsgUpdateCrossChainRoute, opts ...grpc.CallOption) (*MsgUpdateCrossChainRouteResponse, error) {
	out := new(MsgUpdateCrossChainRouteResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateCrossChainRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DisableCrossChainRoute(ctx context.Context, in *MsgDisableCrossChainRoute, opts ...grpc.CallOption) (*MsgDisableCrossChainRouteResponse, error) {
	out := new(MsgDisableCrossChainRouteResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/DisableCrossChainRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoteDeposit(ctx context.Context, in *MsgRemoteDeposit, opts ...grpc.CallOption) (*MsgRemoteDepositResponse, error) {
	out := new(MsgRemoteDepositResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/RemoteDeposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoteWithdraw(ctx context.Context, in *MsgRemoteWithdraw, opts ...grpc.CallOption) (*MsgRemoteWithdrawResponse, error) {
	out := new(MsgRemoteWithdrawResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/RemoteWithdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateRemotePosition(ctx context.Context, in *MsgUpdateRemotePosition, opts ...grpc.CallOption) (*MsgUpdateRemotePositionResponse, error) {
	out := new(MsgUpdateRemotePositionResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateRemotePosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ProcessInFlightPosition(ctx context.Context, in *MsgProcessInFlightPosition, opts ...grpc.CallOption) (*MsgProcessInFlightPositionResponse, error) {
	out := new(MsgProcessInFlightPositionResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/ProcessInFlightPosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Deposit into a V2 vault
	Deposit(context.Context, *MsgDeposit) (*MsgDepositResponse, error)
	// Withdraw from a V2 vault (flexible vaults only)
	Withdraw(context.Context, *MsgWithdraw) (*MsgWithdrawResponse, error)
	// Request exit from a staked vault
	RequestExit(context.Context, *MsgRequestExit) (*MsgRequestExitResponse, error)
	// Cancel a pending exit request
	CancelExit(context.Context, *MsgCancelExit) (*MsgCancelExitResponse, error)
	// Set yield preference for a user's position
	SetYieldPreference(context.Context, *MsgSetYieldPreference) (*MsgSetYieldPreferenceResponse, error)
	// Process exit queue (admin only)
	ProcessExitQueue(context.Context, *MsgProcessExitQueue) (*MsgProcessExitQueueResponse, error)
	// Update NAV for a vault (authority only)
	UpdateNAV(context.Context, *MsgUpdateNAV) (*MsgUpdateNAVResponse, error)
	// Update vault configuration (authority only)
	UpdateVaultConfig(context.Context, *MsgUpdateVaultConfig) (*MsgUpdateVaultConfigResponse, error)
	// Update module parameters (authority only)
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// Create a new cross-chain route (authority only)
	CreateCrossChainRoute(context.Context, *MsgCreateCrossChainRoute) (*MsgCreateCrossChainRouteResponse, error)
	// Update an existing cross-chain route (authority only)
	UpdateCrossChainRoute(context.Context, *MsgUpdateCrossChainRoute) (*MsgUpdateCrossChainRouteResponse, error)
	// Disable a cross-chain route (authority only)
	DisableCrossChainRoute(context.Context, *MsgDisableCrossChainRoute) (*MsgDisableCrossChainRouteResponse, error)
	// Initiate remote deposit to another chain
	RemoteDeposit(context.Context, *MsgRemoteDeposit) (*MsgRemoteDepositResponse, error)
	// Initiate remote withdrawal from another chain
	RemoteWithdraw(context.Context, *MsgRemoteWithdraw) (*MsgRemoteWithdrawResponse, error)
	// Update remote position status (relayer only)
	UpdateRemotePosition(context.Context, *MsgUpdateRemotePosition) (*MsgUpdateRemotePositionResponse, error)
	// Process in-flight position (system operation)
	ProcessInFlightPosition(context.Context, *MsgProcessInFlightPosition) (*MsgProcessInFlightPositionResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Deposit(ctx context.Context, req *MsgDeposit) (*MsgDepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposit not implemented")
}
func (*UnimplementedMsgServer) Withdraw(ctx context.Context, req *MsgWithdraw) (*MsgWithdrawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Withdraw not implemented")
}
func (*UnimplementedMsgServer) RequestExit(ctx context.Context, req *MsgRequestExit) (*MsgRequestExitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestExit not implemented")
}
func (*UnimplementedMsgServer) CancelExit(ctx context.Context, req *MsgCancelExit) (*MsgCancelExitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelExit not implemented")
}
func (*UnimplementedMsgServer) SetYieldPreference(ctx context.Context, req *MsgSetYieldPreference) (*MsgSetYieldPreferenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetYieldPreference not implemented")
}
func (*UnimplementedMsgServer) ProcessExitQueue(ctx context.Context, req *MsgProcessExitQueue) (*MsgProcessExitQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessExitQueue not implemented")
}
func (*UnimplementedMsgServer) UpdateNAV(ctx context.Context, req *MsgUpdateNAV) (*MsgUpdateNAVResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNAV not implemented")
}
func (*UnimplementedMsgServer) UpdateVaultConfig(ctx context.Context, req *MsgUpdateVaultConfig) (*MsgUpdateVaultConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVaultConfig not implemented")
}
func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) CreateCrossChainRoute(ctx context.Context, req *MsgCreateCrossChainRoute) (*MsgCreateCrossChainRouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCrossChainRoute not implemented")
}
func (*UnimplementedMsgServer) UpdateCrossChainRoute(ctx context.Context, req *MsgUpdateCrossChainRoute) (*MsgUpdateCrossChainRouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCrossChainRoute not implemented")
}
func (*UnimplementedMsgServer) DisableCrossChainRoute(ctx context.Context, req *MsgDisableCrossChainRoute) (*MsgDisableCrossChainRouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableCrossChainRoute not implemented")
}
func (*UnimplementedMsgServer) RemoteDeposit(ctx context.Context, req *MsgRemoteDeposit) (*MsgRemoteDepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoteDeposit not implemented")
}
func (*UnimplementedMsgServer) RemoteWithdraw(ctx context.Context, req *MsgRemoteWithdraw) (*MsgRemoteWithdrawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoteWithdraw not implemented")
}
func (*UnimplementedMsgServer) UpdateRemotePosition(ctx context.Context, req *MsgUpdateRemotePosition) (*MsgUpdateRemotePositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRemotePosition not implemented")
}
func (*UnimplementedMsgServer) ProcessInFlightPosition(ctx context.Context, req *MsgProcessInFlightPosition) (*MsgProcessInFlightPositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessInFlightPosition not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Deposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Deposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/Deposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Deposit(ctx, req.(*MsgDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Withdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWithdraw)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Withdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/Withdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Withdraw(ctx, req.(*MsgWithdraw))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RequestExit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRequestExit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RequestExit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/RequestExit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RequestExit(ctx, req.(*MsgRequestExit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelExit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelExit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelExit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/CancelExit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelExit(ctx, req.(*MsgCancelExit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetYieldPreference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetYieldPreference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetYieldPreference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/SetYieldPreference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetYieldPreference(ctx, req.(*MsgSetYieldPreference))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ProcessExitQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProcessExitQueue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProcessExitQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/ProcessExitQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProcessExitQueue(ctx, req.(*MsgProcessExitQueue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateNAV_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateNAV)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateNAV(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateNAV",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateNAV(ctx, req.(*MsgUpdateNAV))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateVaultConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateVaultConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateVaultConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateVaultConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateVaultConfig(ctx, req.(*MsgUpdateVaultConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateCrossChainRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateCrossChainRoute)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateCrossChainRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/CreateCrossChainRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateCrossChainRoute(ctx, req.(*MsgCreateCrossChainRoute))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateCrossChainRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateCrossChainRoute)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateCrossChainRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateCrossChainRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateCrossChainRoute(ctx, req.(*MsgUpdateCrossChainRoute))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DisableCrossChainRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDisableCrossChainRoute)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DisableCrossChainRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/DisableCrossChainRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DisableCrossChainRoute(ctx, req.(*MsgDisableCrossChainRoute))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoteDeposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoteDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoteDeposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/RemoteDeposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoteDeposit(ctx, req.(*MsgRemoteDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoteWithdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoteWithdraw)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoteWithdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/RemoteWithdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoteWithdraw(ctx, req.(*MsgRemoteWithdraw))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateRemotePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateRemotePosition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateRemotePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateRemotePosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateRemotePosition(ctx, req.(*MsgUpdateRemotePosition))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ProcessInFlightPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProcessInFlightPosition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProcessInFlightPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/ProcessInFlightPosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProcessInFlightPosition(ctx, req.(*MsgProcessInFlightPosition))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "noble.dollar.vaults.v2.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deposit",
			Handler:    _Msg_Deposit_Handler,
		},
		{
			MethodName: "Withdraw",
			Handler:    _Msg_Withdraw_Handler,
		},
		{
			MethodName: "RequestExit",
			Handler:    _Msg_RequestExit_Handler,
		},
		{
			MethodName: "CancelExit",
			Handler:    _Msg_CancelExit_Handler,
		},
		{
			MethodName: "SetYieldPreference",
			Handler:    _Msg_SetYieldPreference_Handler,
		},
		{
			MethodName: "ProcessExitQueue",
			Handler:    _Msg_ProcessExitQueue_Handler,
		},
		{
			MethodName: "UpdateNAV",
			Handler:    _Msg_UpdateNAV_Handler,
		},
		{
			MethodName: "UpdateVaultConfig",
			Handler:    _Msg_UpdateVaultConfig_Handler,
		},
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "CreateCrossChainRoute",
			Handler:    _Msg_CreateCrossChainRoute_Handler,
		},
		{
			MethodName: "UpdateCrossChainRoute",
			Handler:    _Msg_UpdateCrossChainRoute_Handler,
		},
		{
			MethodName: "DisableCrossChainRoute",
			Handler:    _Msg_DisableCrossChainRoute_Handler,
		},
		{
			MethodName: "RemoteDeposit",
			Handler:    _Msg_RemoteDeposit_Handler,
		},
		{
			MethodName: "RemoteWithdraw",
			Handler:    _Msg_RemoteWithdraw_Handler,
		},
		{
			MethodName: "UpdateRemotePosition",
			Handler:    _Msg_UpdateRemotePosition_Handler,
		},
		{
			MethodName: "ProcessInFlightPosition",
			Handler:    _Msg_ProcessInFlightPosition_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "noble/dollar/vaults/v2/tx.proto",
}

func (m *MsgDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinShares.Size()
		i -= size
		if _, err := m.MinShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ReceiveYield {
		i--
		if m.ReceiveYield {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Depositor) > 0 {
		i -= len(m.Depositor)
		copy(dAtA[i:], m.Depositor)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Depositor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.FeesPaid.Size()
		i -= size
		if _, err := m.FeesPaid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.AmountDeposited.Size()
		i -= size
		if _, err := m.AmountDeposited.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.SharesReceived.Size()
		i -= size
		if _, err := m.SharesReceived.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinAmount.Size()
		i -= size
		if _, err := m.MinAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Withdrawer) > 0 {
		i -= len(m.Withdrawer)
		copy(dAtA[i:], m.Withdrawer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Withdrawer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.FeesPaid.Size()
		i -= size
		if _, err := m.FeesPaid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SharesRedeemed.Size()
		i -= size
		if _, err := m.SharesRedeemed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.AmountWithdrawn.Size()
		i -= size
		if _, err := m.AmountWithdrawn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgRequestExit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestExit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestExit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRequestExitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestExitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestExitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.EstimatedAmount.Size()
		i -= size
		if _, err := m.EstimatedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedUnlockTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedUnlockTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintTx(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x1a
	{
		size := m.SharesToExit.Size()
		i -= size
		if _, err := m.SharesToExit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ExitRequestId) > 0 {
		i -= len(m.ExitRequestId)
		copy(dAtA[i:], m.ExitRequestId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ExitRequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelExit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelExit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelExit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExitRequestId) > 0 {
		i -= len(m.ExitRequestId)
		copy(dAtA[i:], m.ExitRequestId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ExitRequestId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelExitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelExitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelExitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CancelledExitRequestId) > 0 {
		i -= len(m.CancelledExitRequestId)
		copy(dAtA[i:], m.CancelledExitRequestId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CancelledExitRequestId)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.SharesReturned.Size()
		i -= size
		if _, err := m.SharesReturned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetYieldPreference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetYieldPreference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetYieldPreference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReceiveYield {
		i--
		if m.ReceiveYield {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTx(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetYieldPreferenceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetYieldPreferenceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetYieldPreferenceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewPreference {
		i--
		if m.NewPreference {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.PreviousPreference {
		i--
		if m.PreviousPreference {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgProcessExitQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProcessExitQueue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProcessExitQueue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxRequests != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MaxRequests))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProcessExitQueueResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProcessExitQueueResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProcessExitQueueResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemainingRequests != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RemainingRequests))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.TotalAmountDistributed.Size()
		i -= size
		if _, err := m.TotalAmountDistributed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalSharesProcessed.Size()
		i -= size
		if _, err := m.TotalSharesProcessed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.RequestsProcessed != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RequestsProcessed))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateNAV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateNAV) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateNAV) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.NewNav.Size()
		i -= size
		if _, err := m.NewNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateNAVResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateNAVResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateNAVResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NewSharePrice.Size()
		i -= size
		if _, err := m.NewSharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ChangeBps != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChangeBps))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.NewNav.Size()
		i -= size
		if _, err := m.NewNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.PreviousNav.Size()
		i -= size
		if _, err := m.PreviousNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateVaultConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateVaultConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateVaultConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateVaultConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateVaultConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateVaultConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewConfig) > 0 {
		i -= len(m.NewConfig)
		copy(dAtA[i:], m.NewConfig)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewConfig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousConfig) > 0 {
		i -= len(m.PreviousConfig)
		copy(dAtA[i:], m.PreviousConfig)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PreviousConfig)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewParams) > 0 {
		i -= len(m.NewParams)
		copy(dAtA[i:], m.NewParams)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewParams)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousParams) > 0 {
		i -= len(m.PreviousParams)
		copy(dAtA[i:], m.PreviousParams)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PreviousParams)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateCrossChainRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCrossChainRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCrossChainRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateCrossChainRouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCrossChainRouteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCrossChainRouteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RouteConfig) > 0 {
		i -= len(m.RouteConfig)
		copy(dAtA[i:], m.RouteConfig)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RouteConfig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCrossChainRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCrossChainRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCrossChainRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCrossChainRouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCrossChainRouteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCrossChainRouteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewConfig) > 0 {
		i -= len(m.NewConfig)
		copy(dAtA[i:], m.NewConfig)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewConfig)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PreviousConfig) > 0 {
		i -= len(m.PreviousConfig)
		copy(dAtA[i:], m.PreviousConfig)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PreviousConfig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisableCrossChainRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisableCrossChainRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisableCrossChainRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisableCrossChainRouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisableCrossChainRouteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisableCrossChainRouteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AffectedPositions != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.AffectedPositions))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoteDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoteDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoteDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.GasPrice.Size()
		i -= size
		if _, err := m.GasPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.GasLimit != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.GasLimit))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.MinShares.Size()
		i -= size
		if _, err := m.MinShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.RemoteAddress) > 0 {
		i -= len(m.RemoteAddress)
		copy(dAtA[i:], m.RemoteAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RemoteAddress)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Depositor) > 0 {
		i -= len(m.Depositor)
		copy(dAtA[i:], m.Depositor)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Depositor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoteDepositResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoteDepositResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoteDepositResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProviderTracking != nil {
		{
			size, err := m.ProviderTracking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedCompletion, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedCompletion):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintTx(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x2a
	{
		size := m.AmountSent.Size()
		i -= size
		if _, err := m.AmountSent.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.SharesAllocated.Size()
		i -= size
		if _, err := m.SharesAllocated.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoteWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoteWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoteWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.GasPrice.Size()
		i -= size
		if _, err := m.GasPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.GasLimit != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.GasLimit))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.MinAmount.Size()
		i -= size
		if _, err := m.MinAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Withdrawer) > 0 {
		i -= len(m.Withdrawer)
		copy(dAtA[i:], m.Withdrawer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Withdrawer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoteWithdrawResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoteWithdrawResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoteWithdrawResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProviderTracking != nil {
		{
			size, err := m.ProviderTracking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	n9, err9 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedCompletion, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedCompletion):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintTx(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x2a
	{
		size := m.ExpectedAmount.Size()
		i -= size
		if _, err := m.ExpectedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.SharesWithdrawn.Size()
		i -= size
		if _, err := m.SharesWithdrawn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateRemotePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateRemotePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateRemotePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.ProviderTracking != nil {
		{
			size, err := m.ProviderTracking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Confirmations != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Confirmations))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.RemoteValue.Size()
		i -= size
		if _, err := m.RemoteValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.UserAddress) > 0 {
		i -= len(m.UserAddress)
		copy(dAtA[i:], m.UserAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.UserAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateRemotePositionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateRemotePositionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateRemotePositionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ConservativeValue.Size()
		i -= size
		if _, err := m.ConservativeValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.NewValue.Size()
		i -= size
		if _, err := m.NewValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.PreviousValue.Size()
		i -= size
		if _, err := m.PreviousValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.UserAddress) > 0 {
		i -= len(m.UserAddress)
		copy(dAtA[i:], m.UserAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.UserAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProcessInFlightPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProcessInFlightPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProcessInFlightPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProviderTracking != nil {
		{
			size, err := m.ProviderTracking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.ResultAmount.Size()
		i -= size
		if _, err := m.ResultAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ResultStatus != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ResultStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.Nonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProcessInFlightPositionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProcessInFlightPositionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProcessInFlightPositionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SharesAffected.Size()
		i -= size
		if _, err := m.SharesAffected.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.AmountProcessed.Size()
		i -= size
		if _, err := m.AmountProcessed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.FinalStatus != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.FinalStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.ReceiveYield {
		n += 2
	}
	l = m.MinShares.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDepositResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SharesReceived.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.AmountDeposited.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.FeesPaid.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.SharePrice.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Withdrawer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Shares.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgWithdrawResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AmountWithdrawn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.SharesRedeemed.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.FeesPaid.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.SharePrice.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRequestExit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Shares.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRequestExitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExitRequestId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.SharesToExit.Size()
	n += 1 + l + sovTx(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedUnlockTime)
	n += 1 + l + sovTx(uint64(l))
	l = m.EstimatedAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCancelExit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ExitRequestId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelExitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SharesReturned.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.CancelledExitRequestId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetYieldPreference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ReceiveYield {
		n += 2
	}
	return n
}

func (m *MsgSetYieldPreferenceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreviousPreference {
		n += 2
	}
	if m.NewPreference {
		n += 2
	}
	return n
}

func (m *MsgProcessExitQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MaxRequests != 0 {
		n += 1 + sovTx(uint64(m.MaxRequests))
	}
	return n
}

func (m *MsgProcessExitQueueResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestsProcessed != 0 {
		n += 1 + sovTx(uint64(m.RequestsProcessed))
	}
	l = m.TotalSharesProcessed.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TotalAmountDistributed.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.RemainingRequests != 0 {
		n += 1 + sovTx(uint64(m.RemainingRequests))
	}
	return n
}

func (m *MsgUpdateNAV) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.NewNav.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateNAVResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PreviousNav.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.NewNav.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.ChangeBps != 0 {
		n += 1 + sovTx(uint64(m.ChangeBps))
	}
	l = m.NewSharePrice.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateVaultConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Config.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateVaultConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousConfig)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewConfig)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousParams)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewParams)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateCrossChainRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Route.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateCrossChainRouteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RouteConfig)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateCrossChainRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Route.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateCrossChainRouteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PreviousConfig)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewConfig)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDisableCrossChainRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDisableCrossChainRouteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.AffectedPositions != 0 {
		n += 1 + sovTx(uint64(m.AffectedPositions))
	}
	return n
}

func (m *MsgRemoteDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.RemoteAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MinShares.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.GasLimit != 0 {
		n += 1 + sovTx(uint64(m.GasLimit))
	}
	l = m.GasPrice.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRemoteDepositResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovTx(uint64(m.Nonce))
	}
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.SharesAllocated.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.AmountSent.Size()
	n += 1 + l + sovTx(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedCompletion)
	n += 1 + l + sovTx(uint64(l))
	if m.ProviderTracking != nil {
		l = m.ProviderTracking.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRemoteWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Withdrawer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Shares.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.GasLimit != 0 {
		n += 1 + sovTx(uint64(m.GasLimit))
	}
	l = m.GasPrice.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRemoteWithdrawResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovTx(uint64(m.Nonce))
	}
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.SharesWithdrawn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.ExpectedAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedCompletion)
	n += 1 + l + sovTx(uint64(l))
	if m.ProviderTracking != nil {
		l = m.ProviderTracking.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateRemotePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.UserAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.RemoteValue.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.Confirmations != 0 {
		n += 1 + sovTx(uint64(m.Confirmations))
	}
	if m.ProviderTracking != nil {
		l = m.ProviderTracking.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTx(uint64(m.Status))
	}
	return n
}

func (m *MsgUpdateRemotePositionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.UserAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.PreviousValue.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.NewValue.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.ConservativeValue.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgProcessInFlightPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovTx(uint64(m.Nonce))
	}
	if m.ResultStatus != 0 {
		n += 1 + sovTx(uint64(m.ResultStatus))
	}
	l = m.ResultAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ProviderTracking != nil {
		l = m.ProviderTracking.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgProcessInFlightPositionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovTx(uint64(m.Nonce))
	}
	if m.FinalStatus != 0 {
		n += 1 + sovTx(uint64(m.FinalStatus))
	}
	l = m.AmountProcessed.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.SharesAffected.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveYield", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReceiveYield = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesReceived.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountDeposited", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountDeposited.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeesPaid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeesPaid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdrawer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Withdrawer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesRedeemed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesRedeemed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeesPaid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeesPaid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestExit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestExit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestExit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestExitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestExitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestExitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitRequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExitRequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesToExit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesToExit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedUnlockTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedUnlockTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EstimatedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelExit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelExit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelExit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitRequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExitRequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelExitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelExitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelExitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesReturned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesReturned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledExitRequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelledExitRequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetYieldPreference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetYieldPreference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetYieldPreference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveYield", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReceiveYield = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetYieldPreferenceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetYieldPreferenceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetYieldPreferenceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousPreference", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreviousPreference = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPreference", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewPreference = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProcessExitQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProcessExitQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProcessExitQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequests", wireType)
			}
			m.MaxRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequests |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProcessExitQueueResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProcessExitQueueResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProcessExitQueueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestsProcessed", wireType)
			}
			m.RequestsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestsProcessed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSharesProcessed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSharesProcessed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmountDistributed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmountDistributed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingRequests", wireType)
			}
			m.RemainingRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainingRequests |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateNAV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateNAV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateNAV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateNAVResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateNAVResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateNAVResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PreviousNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeBps", wireType)
			}
			m.ChangeBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeBps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewSharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateVaultConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateVaultConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateVaultConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateVaultConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateVaultConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateVaultConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousParams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousParams = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewParams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewParams = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCrossChainRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCrossChainRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCrossChainRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCrossChainRouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCrossChainRouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCrossChainRouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCrossChainRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCrossChainRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCrossChainRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCrossChainRouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCrossChainRouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCrossChainRouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisableCrossChainRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisableCrossChainRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisableCrossChainRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisableCrossChainRouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisableCrossChainRouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisableCrossChainRouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedPositions", wireType)
			}
			m.AffectedPositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedPositions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoteDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoteDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoteDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
			}
			m.GasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoteDepositResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoteDepositResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoteDepositResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesAllocated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesAllocated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountSent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountSent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedCompletion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedCompletion, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderTracking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderTracking == nil {
				m.ProviderTracking = &ProviderTrackingInfo{}
			}
			if err := m.ProviderTracking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoteWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoteWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoteWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdrawer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Withdrawer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
			}
			m.GasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoteWithdrawResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoteWithdrawResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoteWithdrawResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpectedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedCompletion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedCompletion, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderTracking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderTracking == nil {
				m.ProviderTracking = &ProviderTrackingInfo{}
			}
			if err := m.ProviderTracking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateRemotePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateRemotePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateRemotePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAddress = append(m.UserAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.UserAddress == nil {
				m.UserAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoteValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirmations", wireType)
			}
			m.Confirmations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Confirmations |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderTracking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderTracking == nil {
				m.ProviderTracking = &ProviderTrackingInfo{}
			}
			if err := m.ProviderTracking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RemotePositionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateRemotePositionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateRemotePositionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateRemotePositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAddress = append(m.UserAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.UserAddress == nil {
				m.UserAddress = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PreviousValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConservativeValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConservativeValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProcessInFlightPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProcessInFlightPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProcessInFlightPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultStatus", wireType)
			}
			m.ResultStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResultStatus |= InFlightStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResultAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderTracking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderTracking == nil {
				m.ProviderTracking = &ProviderTrackingInfo{}
			}
			if err := m.ProviderTracking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProcessInFlightPositionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProcessInFlightPositionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProcessInFlightPositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalStatus", wireType)
			}
			m.FinalStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalStatus |= InFlightStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountProcessed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountProcessed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesAffected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesAffected.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
