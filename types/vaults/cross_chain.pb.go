// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v1/cross_chain.proto

package vaults

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RemotePositionStatus represents the status of a remote position
type RemotePositionStatus int32

const (
	// Position is active and being tracked
	REMOTE_POSITION_ACTIVE RemotePositionStatus = 0
	// Position update is pending
	REMOTE_POSITION_PENDING_UPDATE RemotePositionStatus = 1
	// Position has exceeded drift limits
	REMOTE_POSITION_DRIFT_EXCEEDED RemotePositionStatus = 2
	// Position is being liquidated
	REMOTE_POSITION_LIQUIDATING RemotePositionStatus = 3
	// Position has been closed
	REMOTE_POSITION_CLOSED RemotePositionStatus = 4
	// Position is in error state
	REMOTE_POSITION_ERROR RemotePositionStatus = 5
)

var RemotePositionStatus_name = map[int32]string{
	0: "REMOTE_POSITION_ACTIVE",
	1: "REMOTE_POSITION_PENDING_UPDATE",
	2: "REMOTE_POSITION_DRIFT_EXCEEDED",
	3: "REMOTE_POSITION_LIQUIDATING",
	4: "REMOTE_POSITION_CLOSED",
	5: "REMOTE_POSITION_ERROR",
}

var RemotePositionStatus_value = map[string]int32{
	"REMOTE_POSITION_ACTIVE":         0,
	"REMOTE_POSITION_PENDING_UPDATE": 1,
	"REMOTE_POSITION_DRIFT_EXCEEDED": 2,
	"REMOTE_POSITION_LIQUIDATING":    3,
	"REMOTE_POSITION_CLOSED":         4,
	"REMOTE_POSITION_ERROR":          5,
}

func (x RemotePositionStatus) String() string {
	return proto.EnumName(RemotePositionStatus_name, int32(x))
}

func (RemotePositionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cf7203d3ee36358b, []int{0}
}

// InFlightOperationType defines the type of cross-chain operation
type InFlightOperationType int32

const (
	// Position deposit to remote chain
	OPERATION_REMOTE_DEPOSIT InFlightOperationType = 0
	// Position withdrawal from remote chain
	OPERATION_REMOTE_WITHDRAW InFlightOperationType = 1
	// Position rebalancing
	OPERATION_REBALANCE InFlightOperationType = 2
	// Position liquidation
	OPERATION_LIQUIDATE InFlightOperationType = 3
)

var InFlightOperationType_name = map[int32]string{
	0: "OPERATION_REMOTE_DEPOSIT",
	1: "OPERATION_REMOTE_WITHDRAW",
	2: "OPERATION_REBALANCE",
	3: "OPERATION_LIQUIDATE",
}

var InFlightOperationType_value = map[string]int32{
	"OPERATION_REMOTE_DEPOSIT":  0,
	"OPERATION_REMOTE_WITHDRAW": 1,
	"OPERATION_REBALANCE":       2,
	"OPERATION_LIQUIDATE":       3,
}

func (x InFlightOperationType) String() string {
	return proto.EnumName(InFlightOperationType_name, int32(x))
}

func (InFlightOperationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cf7203d3ee36358b, []int{1}
}

// InFlightStatus represents the status of an in-flight operation
type InFlightStatus int32

const (
	// Operation is pending
	INFLIGHT_PENDING InFlightStatus = 0
	// Operation is being processed
	INFLIGHT_PROCESSING InFlightStatus = 1
	// Operation completed successfully
	INFLIGHT_COMPLETED InFlightStatus = 2
	// Operation failed
	INFLIGHT_FAILED InFlightStatus = 3
	// Operation timed out
	INFLIGHT_TIMEOUT InFlightStatus = 4
	// Operation was cancelled
	INFLIGHT_CANCELLED InFlightStatus = 5
)

var InFlightStatus_name = map[int32]string{
	0: "INFLIGHT_PENDING",
	1: "INFLIGHT_PROCESSING",
	2: "INFLIGHT_COMPLETED",
	3: "INFLIGHT_FAILED",
	4: "INFLIGHT_TIMEOUT",
	5: "INFLIGHT_CANCELLED",
}

var InFlightStatus_value = map[string]int32{
	"INFLIGHT_PENDING":    0,
	"INFLIGHT_PROCESSING": 1,
	"INFLIGHT_COMPLETED":  2,
	"INFLIGHT_FAILED":     3,
	"INFLIGHT_TIMEOUT":    4,
	"INFLIGHT_CANCELLED":  5,
}

func (x InFlightStatus) String() string {
	return proto.EnumName(InFlightStatus_name, int32(x))
}

func (InFlightStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cf7203d3ee36358b, []int{2}
}

// CrossChainRoute defines a route for cross-chain operations
type CrossChainRoute struct {
	// Unique identifier for the route
	RouteId string `protobuf:"bytes,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Source chain identifier
	SourceChain string `protobuf:"bytes,2,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// Destination chain identifier
	DestinationChain string `protobuf:"bytes,3,opt,name=destination_chain,json=destinationChain,proto3" json:"destination_chain,omitempty"`
	// IBC channel for communication
	IbcChannel string `protobuf:"bytes,4,opt,name=ibc_channel,json=ibcChannel,proto3" json:"ibc_channel,omitempty"`
	// Whether this route is active
	Active bool `protobuf:"varint,5,opt,name=active,proto3" json:"active,omitempty"`
	// Maximum position value allowed for this route
	MaxPositionValue cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=max_position_value,json=maxPositionValue,proto3,customtype=cosmossdk.io/math.Int" json:"max_position_value"`
	// Risk parameters for this route
	RiskParams *CrossChainRiskParams `protobuf:"bytes,7,opt,name=risk_params,json=riskParams,proto3" json:"risk_params,omitempty"`
}

func (m *CrossChainRoute) Reset()         { *m = CrossChainRoute{} }
func (m *CrossChainRoute) String() string { return proto.CompactTextString(m) }
func (*CrossChainRoute) ProtoMessage()    {}
func (*CrossChainRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf7203d3ee36358b, []int{0}
}
func (m *CrossChainRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainRoute.Merge(m, src)
}
func (m *CrossChainRoute) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainRoute.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainRoute proto.InternalMessageInfo

func (m *CrossChainRoute) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *CrossChainRoute) GetSourceChain() string {
	if m != nil {
		return m.SourceChain
	}
	return ""
}

func (m *CrossChainRoute) GetDestinationChain() string {
	if m != nil {
		return m.DestinationChain
	}
	return ""
}

func (m *CrossChainRoute) GetIbcChannel() string {
	if m != nil {
		return m.IbcChannel
	}
	return ""
}

func (m *CrossChainRoute) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *CrossChainRoute) GetRiskParams() *CrossChainRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// CrossChainRiskParams defines risk management parameters for cross-chain operations
type CrossChainRiskParams struct {
	// Haircut percentage applied to remote positions (basis points)
	PositionHaircut int32 `protobuf:"varint,1,opt,name=position_haircut,json=positionHaircut,proto3" json:"position_haircut,omitempty"`
	// Maximum drift allowed before position revaluation (basis points)
	MaxDriftThreshold int32 `protobuf:"varint,2,opt,name=max_drift_threshold,json=maxDriftThreshold,proto3" json:"max_drift_threshold,omitempty"`
	// Timeout for cross-chain operations (seconds)
	OperationTimeout int64 `protobuf:"varint,3,opt,name=operation_timeout,json=operationTimeout,proto3" json:"operation_timeout,omitempty"`
	// Maximum number of retries for failed operations
	MaxRetries int32 `protobuf:"varint,4,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
	// Conservative valuation discount (basis points)
	ConservativeDiscount int32 `protobuf:"varint,5,opt,name=conservative_discount,json=conservativeDiscount,proto3" json:"conservative_discount,omitempty"`
}

func (m *CrossChainRiskParams) Reset()         { *m = CrossChainRiskParams{} }
func (m *CrossChainRiskParams) String() string { return proto.CompactTextString(m) }
func (*CrossChainRiskParams) ProtoMessage()    {}
func (*CrossChainRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf7203d3ee36358b, []int{1}
}
func (m *CrossChainRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainRiskParams.Merge(m, src)
}
func (m *CrossChainRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainRiskParams proto.InternalMessageInfo

func (m *CrossChainRiskParams) GetPositionHaircut() int32 {
	if m != nil {
		return m.PositionHaircut
	}
	return 0
}

func (m *CrossChainRiskParams) GetMaxDriftThreshold() int32 {
	if m != nil {
		return m.MaxDriftThreshold
	}
	return 0
}

func (m *CrossChainRiskParams) GetOperationTimeout() int64 {
	if m != nil {
		return m.OperationTimeout
	}
	return 0
}

func (m *CrossChainRiskParams) GetMaxRetries() int32 {
	if m != nil {
		return m.MaxRetries
	}
	return 0
}

func (m *CrossChainRiskParams) GetConservativeDiscount() int32 {
	if m != nil {
		return m.ConservativeDiscount
	}
	return 0
}

// RemotePosition represents a position on another chain
type RemotePosition struct {
	// Route used for this position
	RouteId string `protobuf:"bytes,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// User address on the remote chain
	RemoteAddress string `protobuf:"bytes,2,opt,name=remote_address,json=remoteAddress,proto3" json:"remote_address,omitempty"`
	// Local user address (Noble chain)
	LocalAddress []byte `protobuf:"bytes,3,opt,name=local_address,json=localAddress,proto3" json:"local_address,omitempty"`
	// Position value on remote chain
	RemoteValue cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=remote_value,json=remoteValue,proto3,customtype=cosmossdk.io/math.Int" json:"remote_value"`
	// Conservative valuation (with haircut applied)
	ConservativeValue cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=conservative_value,json=conservativeValue,proto3,customtype=cosmossdk.io/math.Int" json:"conservative_value"`
	// Last update timestamp
	LastUpdate time.Time `protobuf:"bytes,6,opt,name=last_update,json=lastUpdate,proto3,stdtime" json:"last_update"`
	// Current drift from expected value (basis points)
	CurrentDrift int32 `protobuf:"varint,7,opt,name=current_drift,json=currentDrift,proto3" json:"current_drift,omitempty"`
	// Position status
	Status RemotePositionStatus `protobuf:"varint,8,opt,name=status,proto3,enum=noble.dollar.vaults.v1.RemotePositionStatus" json:"status,omitempty"`
	// Shares allocated for this remote position
	AllocatedShares cosmossdk_io_math.Int `protobuf:"bytes,9,opt,name=allocated_shares,json=allocatedShares,proto3,customtype=cosmossdk.io/math.Int" json:"allocated_shares"`
}

func (m *RemotePosition) Reset()         { *m = RemotePosition{} }
func (m *RemotePosition) String() string { return proto.CompactTextString(m) }
func (*RemotePosition) ProtoMessage()    {}
func (*RemotePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf7203d3ee36358b, []int{2}
}
func (m *RemotePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemotePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemotePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemotePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemotePosition.Merge(m, src)
}
func (m *RemotePosition) XXX_Size() int {
	return m.Size()
}
func (m *RemotePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_RemotePosition.DiscardUnknown(m)
}

var xxx_messageInfo_RemotePosition proto.InternalMessageInfo

func (m *RemotePosition) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *RemotePosition) GetRemoteAddress() string {
	if m != nil {
		return m.RemoteAddress
	}
	return ""
}

func (m *RemotePosition) GetLocalAddress() []byte {
	if m != nil {
		return m.LocalAddress
	}
	return nil
}

func (m *RemotePosition) GetLastUpdate() time.Time {
	if m != nil {
		return m.LastUpdate
	}
	return time.Time{}
}

func (m *RemotePosition) GetCurrentDrift() int32 {
	if m != nil {
		return m.CurrentDrift
	}
	return 0
}

func (m *RemotePosition) GetStatus() RemotePositionStatus {
	if m != nil {
		return m.Status
	}
	return REMOTE_POSITION_ACTIVE
}

// InFlightPosition represents a position operation in progress
type InFlightPosition struct {
	// Unique nonce for this operation
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Route being used
	RouteId string `protobuf:"bytes,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Local user address
	UserAddress []byte `protobuf:"bytes,3,opt,name=user_address,json=userAddress,proto3" json:"user_address,omitempty"`
	// Operation type
	OperationType InFlightOperationType `protobuf:"varint,4,opt,name=operation_type,json=operationType,proto3,enum=noble.dollar.vaults.v1.InFlightOperationType" json:"operation_type,omitempty"`
	// Amount involved in the operation
	Amount cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// Shares involved (for withdrawals)
	Shares cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=shares,proto3,customtype=cosmossdk.io/math.Int" json:"shares"`
	// Operation initiated timestamp
	InitiatedAt time.Time `protobuf:"bytes,7,opt,name=initiated_at,json=initiatedAt,proto3,stdtime" json:"initiated_at"`
	// Expected completion timestamp
	ExpectedCompletion time.Time `protobuf:"bytes,8,opt,name=expected_completion,json=expectedCompletion,proto3,stdtime" json:"expected_completion"`
	// Current retry count
	RetryCount int32 `protobuf:"varint,9,opt,name=retry_count,json=retryCount,proto3" json:"retry_count,omitempty"`
	// Operation status
	Status InFlightStatus `protobuf:"varint,10,opt,name=status,proto3,enum=noble.dollar.vaults.v1.InFlightStatus" json:"status,omitempty"`
	// Error message if operation failed
	ErrorMessage string `protobuf:"bytes,11,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *InFlightPosition) Reset()         { *m = InFlightPosition{} }
func (m *InFlightPosition) String() string { return proto.CompactTextString(m) }
func (*InFlightPosition) ProtoMessage()    {}
func (*InFlightPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf7203d3ee36358b, []int{3}
}
func (m *InFlightPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InFlightPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InFlightPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InFlightPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InFlightPosition.Merge(m, src)
}
func (m *InFlightPosition) XXX_Size() int {
	return m.Size()
}
func (m *InFlightPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_InFlightPosition.DiscardUnknown(m)
}

var xxx_messageInfo_InFlightPosition proto.InternalMessageInfo

func (m *InFlightPosition) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *InFlightPosition) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *InFlightPosition) GetUserAddress() []byte {
	if m != nil {
		return m.UserAddress
	}
	return nil
}

func (m *InFlightPosition) GetOperationType() InFlightOperationType {
	if m != nil {
		return m.OperationType
	}
	return OPERATION_REMOTE_DEPOSIT
}

func (m *InFlightPosition) GetInitiatedAt() time.Time {
	if m != nil {
		return m.InitiatedAt
	}
	return time.Time{}
}

func (m *InFlightPosition) GetExpectedCompletion() time.Time {
	if m != nil {
		return m.ExpectedCompletion
	}
	return time.Time{}
}

func (m *InFlightPosition) GetRetryCount() int32 {
	if m != nil {
		return m.RetryCount
	}
	return 0
}

func (m *InFlightPosition) GetStatus() InFlightStatus {
	if m != nil {
		return m.Status
	}
	return INFLIGHT_PENDING
}

func (m *InFlightPosition) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// CrossChainPositionSnapshot provides a snapshot of all cross-chain positions
type CrossChainPositionSnapshot struct {
	// Total remote value (sum of all remote positions)
	TotalRemoteValue cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_remote_value,json=totalRemoteValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_remote_value"`
	// Total conservative value (with haircuts applied)
	TotalConservativeValue cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_conservative_value,json=totalConservativeValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_conservative_value"`
	// Number of active remote positions
	ActivePositions int64 `protobuf:"varint,3,opt,name=active_positions,json=activePositions,proto3" json:"active_positions,omitempty"`
	// Number of positions with drift issues
	DriftExceededPositions int64 `protobuf:"varint,4,opt,name=drift_exceeded_positions,json=driftExceededPositions,proto3" json:"drift_exceeded_positions,omitempty"`
	// Snapshot timestamp
	Timestamp time.Time `protobuf:"bytes,5,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Total shares allocated to remote positions
	TotalRemoteShares cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=total_remote_shares,json=totalRemoteShares,proto3,customtype=cosmossdk.io/math.Int" json:"total_remote_shares"`
}

func (m *CrossChainPositionSnapshot) Reset()         { *m = CrossChainPositionSnapshot{} }
func (m *CrossChainPositionSnapshot) String() string { return proto.CompactTextString(m) }
func (*CrossChainPositionSnapshot) ProtoMessage()    {}
func (*CrossChainPositionSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf7203d3ee36358b, []int{4}
}
func (m *CrossChainPositionSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainPositionSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainPositionSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainPositionSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainPositionSnapshot.Merge(m, src)
}
func (m *CrossChainPositionSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainPositionSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainPositionSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainPositionSnapshot proto.InternalMessageInfo

func (m *CrossChainPositionSnapshot) GetActivePositions() int64 {
	if m != nil {
		return m.ActivePositions
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetDriftExceededPositions() int64 {
	if m != nil {
		return m.DriftExceededPositions
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

// DriftAlert represents an alert when a position exceeds drift limits
type DriftAlert struct {
	// Position route ID
	RouteId string `protobuf:"bytes,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// User address
	UserAddress []byte `protobuf:"bytes,2,opt,name=user_address,json=userAddress,proto3" json:"user_address,omitempty"`
	// Current drift percentage (basis points)
	CurrentDrift int32 `protobuf:"varint,3,opt,name=current_drift,json=currentDrift,proto3" json:"current_drift,omitempty"`
	// Threshold that was exceeded (basis points)
	ThresholdExceeded int32 `protobuf:"varint,4,opt,name=threshold_exceeded,json=thresholdExceeded,proto3" json:"threshold_exceeded,omitempty"`
	// Alert timestamp
	Timestamp time.Time `protobuf:"bytes,5,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Recommended action
	RecommendedAction string `protobuf:"bytes,6,opt,name=recommended_action,json=recommendedAction,proto3" json:"recommended_action,omitempty"`
}

func (m *DriftAlert) Reset()         { *m = DriftAlert{} }
func (m *DriftAlert) String() string { return proto.CompactTextString(m) }
func (*DriftAlert) ProtoMessage()    {}
func (*DriftAlert) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf7203d3ee36358b, []int{5}
}
func (m *DriftAlert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DriftAlert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DriftAlert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DriftAlert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DriftAlert.Merge(m, src)
}
func (m *DriftAlert) XXX_Size() int {
	return m.Size()
}
func (m *DriftAlert) XXX_DiscardUnknown() {
	xxx_messageInfo_DriftAlert.DiscardUnknown(m)
}

var xxx_messageInfo_DriftAlert proto.InternalMessageInfo

func (m *DriftAlert) GetRouteId() string {
	if m != nil {
		return m.RouteId
	}
	return ""
}

func (m *DriftAlert) GetUserAddress() []byte {
	if m != nil {
		return m.UserAddress
	}
	return nil
}

func (m *DriftAlert) GetCurrentDrift() int32 {
	if m != nil {
		return m.CurrentDrift
	}
	return 0
}

func (m *DriftAlert) GetThresholdExceeded() int32 {
	if m != nil {
		return m.ThresholdExceeded
	}
	return 0
}

func (m *DriftAlert) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *DriftAlert) GetRecommendedAction() string {
	if m != nil {
		return m.RecommendedAction
	}
	return ""
}

// CrossChainConfig defines global configuration for cross-chain operations
type CrossChainConfig struct {
	// Global position haircut (basis points)
	GlobalHaircut int32 `protobuf:"varint,1,opt,name=global_haircut,json=globalHaircut,proto3" json:"global_haircut,omitempty"`
	// Maximum total remote position value as percentage of vault (basis points)
	MaxRemoteExposure int32 `protobuf:"varint,2,opt,name=max_remote_exposure,json=maxRemoteExposure,proto3" json:"max_remote_exposure,omitempty"`
	// Default operation timeout (seconds)
	DefaultTimeout int64 `protobuf:"varint,3,opt,name=default_timeout,json=defaultTimeout,proto3" json:"default_timeout,omitempty"`
	// Position update frequency (seconds)
	UpdateFrequency int64 `protobuf:"varint,4,opt,name=update_frequency,json=updateFrequency,proto3" json:"update_frequency,omitempty"`
	// Emergency liquidation threshold (basis points)
	EmergencyLiquidationThreshold int32 `protobuf:"varint,5,opt,name=emergency_liquidation_threshold,json=emergencyLiquidationThreshold,proto3" json:"emergency_liquidation_threshold,omitempty"`
	// Whether cross-chain operations are enabled
	Enabled bool `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *CrossChainConfig) Reset()         { *m = CrossChainConfig{} }
func (m *CrossChainConfig) String() string { return proto.CompactTextString(m) }
func (*CrossChainConfig) ProtoMessage()    {}
func (*CrossChainConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf7203d3ee36358b, []int{6}
}
func (m *CrossChainConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainConfig.Merge(m, src)
}
func (m *CrossChainConfig) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainConfig proto.InternalMessageInfo

func (m *CrossChainConfig) GetGlobalHaircut() int32 {
	if m != nil {
		return m.GlobalHaircut
	}
	return 0
}

func (m *CrossChainConfig) GetMaxRemoteExposure() int32 {
	if m != nil {
		return m.MaxRemoteExposure
	}
	return 0
}

func (m *CrossChainConfig) GetDefaultTimeout() int64 {
	if m != nil {
		return m.DefaultTimeout
	}
	return 0
}

func (m *CrossChainConfig) GetUpdateFrequency() int64 {
	if m != nil {
		return m.UpdateFrequency
	}
	return 0
}

func (m *CrossChainConfig) GetEmergencyLiquidationThreshold() int32 {
	if m != nil {
		return m.EmergencyLiquidationThreshold
	}
	return 0
}

func (m *CrossChainConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func init() {
	proto.RegisterEnum("noble.dollar.vaults.v1.RemotePositionStatus", RemotePositionStatus_name, RemotePositionStatus_value)
	proto.RegisterEnum("noble.dollar.vaults.v1.InFlightOperationType", InFlightOperationType_name, InFlightOperationType_value)
	proto.RegisterEnum("noble.dollar.vaults.v1.InFlightStatus", InFlightStatus_name, InFlightStatus_value)
	proto.RegisterType((*CrossChainRoute)(nil), "noble.dollar.vaults.v1.CrossChainRoute")
	proto.RegisterType((*CrossChainRiskParams)(nil), "noble.dollar.vaults.v1.CrossChainRiskParams")
	proto.RegisterType((*RemotePosition)(nil), "noble.dollar.vaults.v1.RemotePosition")
	proto.RegisterType((*InFlightPosition)(nil), "noble.dollar.vaults.v1.InFlightPosition")
	proto.RegisterType((*CrossChainPositionSnapshot)(nil), "noble.dollar.vaults.v1.CrossChainPositionSnapshot")
	proto.RegisterType((*DriftAlert)(nil), "noble.dollar.vaults.v1.DriftAlert")
	proto.RegisterType((*CrossChainConfig)(nil), "noble.dollar.vaults.v1.CrossChainConfig")
}

func init() {
	proto.RegisterFile("noble/dollar/vaults/v1/cross_chain.proto", fileDescriptor_cf7203d3ee36358b)
}

var fileDescriptor_cf7203d3ee36358b = []byte{
	// 1487 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4d, 0x6f, 0x1b, 0xc7,
	0x19, 0xe6, 0x52, 0xa4, 0x2c, 0xbd, 0xd4, 0xc7, 0x6a, 0xf4, 0x51, 0x4a, 0xad, 0x29, 0x55, 0x46,
	0x5b, 0xd9, 0xad, 0xc8, 0x5a, 0xbe, 0x14, 0x3d, 0x14, 0xa0, 0xc8, 0x95, 0xb4, 0x00, 0x25, 0xaa,
	0x2b, 0xca, 0x2e, 0x5a, 0xa0, 0xdb, 0xd1, 0xee, 0x88, 0xdc, 0x7a, 0x77, 0x87, 0xde, 0x19, 0x0a,
	0x54, 0x7e, 0x41, 0x0e, 0x39, 0x38, 0xbf, 0x20, 0x01, 0x72, 0xc9, 0x31, 0x87, 0x1c, 0xf3, 0x03,
	0x7c, 0x34, 0x72, 0x32, 0x72, 0x70, 0x02, 0x3b, 0x40, 0x7e, 0x40, 0x82, 0x9c, 0x83, 0x99, 0xd9,
	0x5d, 0x91, 0x14, 0x1d, 0x1b, 0x4a, 0x2e, 0x02, 0xe7, 0xfd, 0x78, 0x76, 0xe6, 0x79, 0x9f, 0x79,
	0xdf, 0x11, 0x6c, 0x85, 0xf4, 0xcc, 0x27, 0x15, 0x97, 0xfa, 0x3e, 0x8e, 0x2a, 0x17, 0xb8, 0xe7,
	0x73, 0x56, 0xb9, 0xb8, 0x5f, 0x71, 0x22, 0xca, 0x98, 0xed, 0x74, 0xb0, 0x17, 0x96, 0xbb, 0x11,
	0xe5, 0x14, 0xad, 0xc8, 0xc8, 0xb2, 0x8a, 0x2c, 0xab, 0xc8, 0xf2, 0xc5, 0xfd, 0xb5, 0x05, 0x1c,
	0x78, 0x21, 0xad, 0xc8, 0xbf, 0x2a, 0x74, 0x6d, 0xd5, 0xa1, 0x2c, 0xa0, 0xcc, 0x96, 0xab, 0x8a,
	0x5a, 0xc4, 0xae, 0xa5, 0x36, 0x6d, 0x53, 0x65, 0x17, 0xbf, 0x62, 0xeb, 0x7a, 0x9b, 0xd2, 0xb6,
	0x4f, 0x2a, 0x72, 0x75, 0xd6, 0x3b, 0xaf, 0x70, 0x2f, 0x20, 0x8c, 0xe3, 0xa0, 0xab, 0x02, 0x36,
	0xbf, 0xcd, 0xc2, 0x7c, 0x4d, 0x6c, 0xa9, 0x26, 0x76, 0x64, 0xd1, 0x1e, 0x27, 0x68, 0x15, 0xa6,
	0x22, 0xf1, 0xc3, 0xf6, 0xdc, 0xa2, 0xb6, 0xa1, 0x6d, 0x4d, 0x5b, 0xb7, 0xe4, 0xda, 0x74, 0xd1,
	0xef, 0x61, 0x86, 0xd1, 0x5e, 0xe4, 0x10, 0x75, 0x82, 0x62, 0x56, 0xba, 0x0b, 0xca, 0x26, 0x21,
	0xd0, 0x9f, 0x61, 0xc1, 0x25, 0x8c, 0x7b, 0x21, 0xe6, 0x1e, 0x0d, 0xe3, 0xb8, 0x09, 0x19, 0xa7,
	0x0f, 0x38, 0x54, 0xf0, 0x3a, 0x14, 0xbc, 0x33, 0x47, 0x04, 0x85, 0x21, 0xf1, 0x8b, 0x39, 0x19,
	0x06, 0xde, 0x99, 0x53, 0x53, 0x16, 0xb4, 0x02, 0x93, 0xd8, 0xe1, 0xde, 0x05, 0x29, 0xe6, 0x37,
	0xb4, 0xad, 0x29, 0x2b, 0x5e, 0xa1, 0xff, 0x02, 0x0a, 0x70, 0xdf, 0xee, 0x52, 0xe6, 0xc9, 0xcf,
	0x5c, 0x60, 0xbf, 0x47, 0x8a, 0x93, 0x22, 0x7f, 0xf7, 0xaf, 0xcf, 0x5e, 0xae, 0x67, 0xbe, 0x7a,
	0xb9, 0xbe, 0xac, 0x08, 0x62, 0xee, 0xe3, 0xb2, 0x47, 0x2b, 0x01, 0xe6, 0x9d, 0xb2, 0x19, 0xf2,
	0x2f, 0x3f, 0xdf, 0x86, 0x98, 0x39, 0x33, 0xe4, 0x9f, 0x7e, 0xf7, 0xd9, 0x3d, 0xcd, 0xd2, 0x03,
	0xdc, 0x3f, 0x8e, 0xa1, 0x1e, 0x0a, 0x24, 0x74, 0x08, 0x85, 0xc8, 0x63, 0x8f, 0xed, 0x2e, 0x8e,
	0x70, 0xc0, 0x8a, 0xb7, 0x36, 0xb4, 0xad, 0xc2, 0xce, 0x5f, 0xca, 0xe3, 0x4b, 0x55, 0x1e, 0x60,
	0xd0, 0x63, 0x8f, 0x8f, 0x65, 0x8e, 0x05, 0x51, 0xfa, 0x7b, 0xf3, 0x07, 0x0d, 0x96, 0xc6, 0x05,
	0xa1, 0xbb, 0xa0, 0xa7, 0x67, 0xe8, 0x60, 0x2f, 0x72, 0x7a, 0x5c, 0x72, 0x9e, 0xb7, 0xe6, 0x13,
	0xfb, 0x81, 0x32, 0xa3, 0x32, 0x2c, 0x8a, 0x23, 0xbb, 0x91, 0x77, 0xce, 0x6d, 0xde, 0x89, 0x08,
	0xeb, 0x50, 0xdf, 0x95, 0x25, 0xc8, 0x5b, 0x0b, 0x01, 0xee, 0xd7, 0x85, 0xa7, 0x95, 0x38, 0x44,
	0x21, 0x68, 0x97, 0x44, 0xaa, 0x0c, 0xa2, 0xee, 0xb4, 0xc7, 0x65, 0x21, 0x26, 0x2c, 0x3d, 0x75,
	0xb4, 0x94, 0x5d, 0x14, 0x42, 0x80, 0x47, 0x84, 0x47, 0x1e, 0x61, 0xb2, 0x10, 0x79, 0x0b, 0x02,
	0xdc, 0xb7, 0x94, 0x05, 0x3d, 0x80, 0x65, 0x87, 0x86, 0x8c, 0x44, 0x17, 0x58, 0x14, 0xc0, 0x76,
	0x3d, 0xe6, 0xd0, 0x5e, 0xc8, 0x65, 0x5d, 0xf2, 0xd6, 0xd2, 0xa0, 0xb3, 0x1e, 0xfb, 0x36, 0xbf,
	0xc8, 0xc1, 0x9c, 0x45, 0x02, 0xca, 0x49, 0xc2, 0xee, 0xcf, 0x89, 0xeb, 0x0f, 0x30, 0x17, 0xc9,
	0x60, 0x1b, 0xbb, 0x6e, 0x44, 0x18, 0x8b, 0xe5, 0x35, 0xab, 0xac, 0x55, 0x65, 0x44, 0x77, 0x60,
	0xd6, 0xa7, 0x0e, 0xf6, 0xd3, 0x28, 0x71, 0xa6, 0x19, 0x6b, 0x46, 0x1a, 0x93, 0xa0, 0x13, 0x98,
	0x89, 0xb1, 0x94, 0x32, 0x72, 0x37, 0x54, 0x46, 0x41, 0xa1, 0x28, 0x51, 0xd8, 0x80, 0x86, 0x38,
	0x50, 0xd0, 0xf9, 0x1b, 0x42, 0x2f, 0x0c, 0x62, 0xa9, 0x0f, 0x18, 0x50, 0xf0, 0x31, 0xe3, 0x76,
	0xaf, 0xeb, 0x62, 0xae, 0xe4, 0x5c, 0xd8, 0x59, 0x2b, 0xab, 0x4b, 0x5c, 0x4e, 0x2e, 0x71, 0xb9,
	0x95, 0x5c, 0xe2, 0xdd, 0x29, 0xf1, 0xd5, 0xa7, 0x5f, 0xaf, 0x6b, 0x16, 0x88, 0xc4, 0x53, 0x99,
	0x27, 0x18, 0x72, 0x7a, 0x51, 0x44, 0x42, 0xae, 0xd4, 0x22, 0xe5, 0x9b, 0xb7, 0x66, 0x62, 0xa3,
	0xd4, 0x09, 0xaa, 0xc3, 0x24, 0xe3, 0x98, 0xf7, 0x58, 0x71, 0x6a, 0x43, 0xdb, 0x9a, 0x7b, 0xb3,
	0xb8, 0x87, 0x0b, 0x78, 0x22, 0x73, 0xac, 0x38, 0x17, 0xfd, 0x07, 0x74, 0xec, 0x0b, 0xe6, 0x39,
	0x71, 0x6d, 0xd6, 0xc1, 0x11, 0x61, 0xc5, 0xe9, 0x1b, 0x12, 0x32, 0x9f, 0x22, 0x9d, 0x48, 0xa0,
	0xcd, 0x1f, 0x73, 0xa0, 0x9b, 0xe1, 0x9e, 0xef, 0xb5, 0x3b, 0x3c, 0x15, 0xd0, 0x12, 0xe4, 0x43,
	0x1a, 0x3a, 0x44, 0xaa, 0x27, 0x67, 0xa9, 0xc5, 0x90, 0xac, 0xb2, 0xd7, 0x7a, 0x56, 0x8f, 0x91,
	0x68, 0x44, 0x2e, 0x05, 0x61, 0x4b, 0xd4, 0xd2, 0x82, 0xb9, 0x81, 0xab, 0x72, 0xd9, 0x55, 0x7a,
	0x99, 0xdb, 0xd9, 0x7e, 0x13, 0x27, 0xc9, 0xae, 0x9a, 0xe9, 0x3d, 0xba, 0xec, 0x12, 0x6b, 0x96,
	0x0e, 0x2e, 0xd1, 0x01, 0x4c, 0xe2, 0x20, 0xbd, 0x23, 0x37, 0x61, 0x24, 0xce, 0x17, 0x48, 0x31,
	0xb7, 0x37, 0xed, 0x70, 0x71, 0x3e, 0xda, 0x87, 0x19, 0x2f, 0xf4, 0xb8, 0x27, 0xeb, 0x85, 0x79,
	0xdc, 0xd8, 0xde, 0x4d, 0x62, 0x85, 0x34, 0xb3, 0xca, 0xd1, 0x29, 0x2c, 0x92, 0x7e, 0x97, 0x38,
	0x02, 0xc7, 0xa1, 0x41, 0xd7, 0x27, 0xe2, 0xdc, 0x52, 0x4b, 0xef, 0x8a, 0x87, 0x12, 0x80, 0x5a,
	0x9a, 0x2f, 0xfa, 0x90, 0xe8, 0x41, 0x97, 0xb6, 0x6a, 0x2e, 0xd3, 0xaa, 0x0f, 0x49, 0x53, 0x4d,
	0x52, 0xf1, 0x8f, 0x54, 0xb6, 0x20, 0x4b, 0xf4, 0xc7, 0xb7, 0x95, 0x68, 0x44, 0xb0, 0x77, 0x60,
	0x96, 0x44, 0x11, 0x8d, 0xec, 0x80, 0x30, 0x86, 0xdb, 0xa4, 0x58, 0x90, 0x6a, 0x99, 0x91, 0xc6,
	0x43, 0x65, 0xdb, 0xfc, 0x7e, 0x02, 0xd6, 0xae, 0xda, 0x75, 0x2a, 0xfd, 0x10, 0x77, 0x59, 0x87,
	0x72, 0x31, 0x7c, 0x38, 0xe5, 0xd8, 0xb7, 0x87, 0x5a, 0x8c, 0x76, 0xd3, 0xe1, 0x23, 0xb1, 0xac,
	0x81, 0x3e, 0xf3, 0x7f, 0x28, 0x2a, 0xfc, 0x31, 0xdd, 0x26, 0x7b, 0xc3, 0xaf, 0xac, 0x48, 0xc4,
	0xda, 0xb5, 0x96, 0x73, 0x17, 0x74, 0x35, 0x52, 0xd3, 0x59, 0xca, 0xe2, 0x21, 0x31, 0xaf, 0xec,
	0xc9, 0xe9, 0x19, 0xfa, 0x1b, 0x14, 0xd5, 0xf0, 0x21, 0x7d, 0x87, 0x10, 0x97, 0xb8, 0x03, 0x29,
	0x39, 0x99, 0xb2, 0x22, 0xfd, 0x46, 0xec, 0xbe, 0xca, 0xdc, 0x85, 0xe9, 0xf4, 0xe1, 0x21, 0x2f,
	0xc3, 0xbb, 0x4a, 0xe4, 0x2a, 0x0d, 0xfd, 0x0f, 0x16, 0x87, 0x48, 0xff, 0x85, 0x17, 0x62, 0x61,
	0x80, 0xf5, 0xb8, 0xdd, 0x7c, 0x98, 0x05, 0x90, 0xbd, 0xb1, 0xea, 0x93, 0x88, 0xbf, 0xe5, 0x19,
	0x34, 0xd4, 0x52, 0xb2, 0xd7, 0x5b, 0xca, 0xb5, 0x1e, 0x3c, 0x31, 0xa6, 0x07, 0x6f, 0x03, 0x4a,
	0x07, 0x79, 0xca, 0x6a, 0x3c, 0x7c, 0x17, 0x52, 0x4f, 0xc2, 0xe7, 0xaf, 0x42, 0xe3, 0x36, 0xa0,
	0x88, 0x38, 0x34, 0x08, 0x48, 0x28, 0x2a, 0x28, 0x6a, 0x4c, 0x43, 0xc5, 0xa2, 0xb5, 0x30, 0xe0,
	0xa9, 0x4a, 0xc7, 0xe6, 0x47, 0x59, 0xd0, 0xaf, 0x6e, 0x42, 0x8d, 0x86, 0xe7, 0x5e, 0x5b, 0x0c,
	0xea, 0xb6, 0x4f, 0xcf, 0xb0, 0x3f, 0xf2, 0x64, 0x99, 0x55, 0xd6, 0x91, 0x07, 0x4b, 0x5c, 0x2f,
	0xd2, 0xef, 0x52, 0xd6, 0x8b, 0xc8, 0xc0, 0x83, 0x45, 0xb1, 0x6f, 0xc4, 0x0e, 0xf4, 0x27, 0x98,
	0x77, 0xc9, 0xb9, 0xb8, 0xc0, 0x23, 0xcf, 0x95, 0xb9, 0xd8, 0x9c, 0x3c, 0x56, 0xee, 0x82, 0xae,
	0x26, 0xa4, 0x7d, 0x1e, 0x91, 0x27, 0x3d, 0x12, 0x3a, 0x97, 0xb1, 0x00, 0xe7, 0x95, 0x7d, 0x2f,
	0x31, 0xa3, 0x3d, 0x58, 0x27, 0x01, 0x89, 0xda, 0x62, 0x61, 0xfb, 0xde, 0x93, 0x9e, 0xe7, 0xc6,
	0x5d, 0x3e, 0x7d, 0x40, 0xa9, 0x07, 0xcc, 0xed, 0x34, 0xac, 0x71, 0x15, 0x75, 0xf5, 0x98, 0x2a,
	0xc2, 0x2d, 0x12, 0xe2, 0x33, 0x9f, 0xb8, 0x92, 0xab, 0x29, 0x2b, 0x59, 0xde, 0x7b, 0xa1, 0xc1,
	0xd2, 0xb8, 0x11, 0x89, 0xd6, 0x60, 0xc5, 0x32, 0x0e, 0x9b, 0x2d, 0xc3, 0x3e, 0x6e, 0x9e, 0x98,
	0x2d, 0xb3, 0x79, 0x64, 0x57, 0x6b, 0x2d, 0xf3, 0xa1, 0xa1, 0x67, 0xd0, 0x26, 0x94, 0x46, 0x7d,
	0xc7, 0xc6, 0x51, 0xdd, 0x3c, 0xda, 0xb7, 0x4f, 0x8f, 0xeb, 0xd5, 0x96, 0xa1, 0x6b, 0xe3, 0x62,
	0xea, 0x96, 0xb9, 0xd7, 0xb2, 0x8d, 0x7f, 0xd5, 0x0c, 0xa3, 0x6e, 0xd4, 0xf5, 0x2c, 0x5a, 0x87,
	0xdf, 0x8e, 0xc6, 0x34, 0xcc, 0x7f, 0x9e, 0x9a, 0xf5, 0x6a, 0xcb, 0x3c, 0xda, 0xd7, 0x27, 0xc6,
	0x6d, 0xa2, 0xd6, 0x68, 0x9e, 0x18, 0x75, 0x3d, 0x87, 0x56, 0x61, 0x79, 0xd4, 0x67, 0x58, 0x56,
	0xd3, 0xd2, 0xf3, 0x6b, 0xb9, 0xf7, 0x3f, 0x29, 0x65, 0xee, 0x7d, 0xa0, 0xc1, 0xf2, 0xd8, 0x49,
	0x87, 0x7e, 0x07, 0xc5, 0xe6, 0xb1, 0x61, 0x55, 0x65, 0x52, 0x0c, 0x52, 0x37, 0x24, 0x8c, 0x9e,
	0x41, 0xb7, 0x61, 0xf5, 0x9a, 0xf7, 0x91, 0xd9, 0x3a, 0xa8, 0x5b, 0xd5, 0x47, 0xba, 0x86, 0x7e,
	0x03, 0x8b, 0x83, 0xee, 0xdd, 0x6a, 0xa3, 0x7a, 0x54, 0x33, 0xf4, 0xec, 0xb0, 0x23, 0x39, 0x87,
	0xa1, 0x4f, 0xc4, 0xdb, 0xf9, 0x58, 0x83, 0xb9, 0xe1, 0xae, 0x8e, 0x96, 0x40, 0x37, 0x8f, 0xf6,
	0x1a, 0xe6, 0xfe, 0x41, 0x2b, 0x21, 0x50, 0xcf, 0x08, 0x9c, 0x2b, 0xab, 0xd5, 0xac, 0x19, 0x27,
	0x27, 0xc2, 0xa1, 0xa1, 0x15, 0x40, 0xa9, 0xa3, 0xd6, 0x3c, 0x3c, 0x6e, 0x18, 0x2d, 0x49, 0xe3,
	0x22, 0xcc, 0xa7, 0xf6, 0xbd, 0xaa, 0xd9, 0x30, 0xea, 0xfa, 0xc4, 0x10, 0x76, 0xcb, 0x3c, 0x34,
	0x9a, 0xa7, 0x2d, 0x3d, 0x37, 0x0c, 0x21, 0xf6, 0xdd, 0x10, 0xd1, 0x31, 0x63, 0xbb, 0x7f, 0x7f,
	0xf6, 0xaa, 0xa4, 0x3d, 0x7f, 0x55, 0xd2, 0xbe, 0x79, 0x55, 0xd2, 0x9e, 0xbe, 0x2e, 0x65, 0x9e,
	0xbf, 0x2e, 0x65, 0x5e, 0xbc, 0x2e, 0x65, 0xfe, 0xbd, 0x11, 0x0f, 0x28, 0x35, 0xad, 0xfa, 0x97,
	0xef, 0x55, 0x2e, 0x76, 0x2a, 0xe2, 0xa9, 0xc1, 0xe2, 0x7f, 0x0e, 0xcf, 0x26, 0xe5, 0x15, 0x7e,
	0xf0, 0x53, 0x00, 0x00, 0x00, 0xff, 0xff, 0x69, 0x2c, 0x0c, 0xaa, 0x3a, 0x0e, 0x00, 0x00,
}

func (m *CrossChainRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RiskParams != nil {
		{
			size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.MaxPositionValue.Size()
		i -= size
		if _, err := m.MaxPositionValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.IbcChannel) > 0 {
		i -= len(m.IbcChannel)
		copy(dAtA[i:], m.IbcChannel)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.IbcChannel)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DestinationChain) > 0 {
		i -= len(m.DestinationChain)
		copy(dAtA[i:], m.DestinationChain)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.DestinationChain)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceChain) > 0 {
		i -= len(m.SourceChain)
		copy(dAtA[i:], m.SourceChain)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.SourceChain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConservativeDiscount != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.ConservativeDiscount))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxRetries != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxRetries))
		i--
		dAtA[i] = 0x20
	}
	if m.OperationTimeout != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.OperationTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxDriftThreshold != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxDriftThreshold))
		i--
		dAtA[i] = 0x10
	}
	if m.PositionHaircut != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.PositionHaircut))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemotePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemotePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemotePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AllocatedShares.Size()
		i -= size
		if _, err := m.AllocatedShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.Status != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x40
	}
	if m.CurrentDrift != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.CurrentDrift))
		i--
		dAtA[i] = 0x38
	}
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastUpdate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdate):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintCrossChain(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x32
	{
		size := m.ConservativeValue.Size()
		i -= size
		if _, err := m.ConservativeValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.RemoteValue.Size()
		i -= size
		if _, err := m.RemoteValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.LocalAddress) > 0 {
		i -= len(m.LocalAddress)
		copy(dAtA[i:], m.LocalAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.LocalAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RemoteAddress) > 0 {
		i -= len(m.RemoteAddress)
		copy(dAtA[i:], m.RemoteAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.RemoteAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InFlightPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InFlightPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InFlightPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Status != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.RetryCount != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.RetryCount))
		i--
		dAtA[i] = 0x48
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedCompletion, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedCompletion):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintCrossChain(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x42
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.InitiatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.InitiatedAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintCrossChain(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x3a
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.OperationType != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.OperationType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.UserAddress) > 0 {
		i -= len(m.UserAddress)
		copy(dAtA[i:], m.UserAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.UserAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainPositionSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainPositionSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainPositionSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalRemoteShares.Size()
		i -= size
		if _, err := m.TotalRemoteShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintCrossChain(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x2a
	if m.DriftExceededPositions != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.DriftExceededPositions))
		i--
		dAtA[i] = 0x20
	}
	if m.ActivePositions != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.ActivePositions))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.TotalConservativeValue.Size()
		i -= size
		if _, err := m.TotalConservativeValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalRemoteValue.Size()
		i -= size
		if _, err := m.TotalRemoteValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DriftAlert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DriftAlert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DriftAlert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RecommendedAction) > 0 {
		i -= len(m.RecommendedAction)
		copy(dAtA[i:], m.RecommendedAction)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.RecommendedAction)))
		i--
		dAtA[i] = 0x32
	}
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintCrossChain(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x2a
	if m.ThresholdExceeded != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.ThresholdExceeded))
		i--
		dAtA[i] = 0x20
	}
	if m.CurrentDrift != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.CurrentDrift))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UserAddress) > 0 {
		i -= len(m.UserAddress)
		copy(dAtA[i:], m.UserAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.UserAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RouteId) > 0 {
		i -= len(m.RouteId)
		copy(dAtA[i:], m.RouteId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.RouteId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.EmergencyLiquidationThreshold != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.EmergencyLiquidationThreshold))
		i--
		dAtA[i] = 0x28
	}
	if m.UpdateFrequency != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.UpdateFrequency))
		i--
		dAtA[i] = 0x20
	}
	if m.DefaultTimeout != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.DefaultTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxRemoteExposure != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxRemoteExposure))
		i--
		dAtA[i] = 0x10
	}
	if m.GlobalHaircut != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.GlobalHaircut))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCrossChain(dAtA []byte, offset int, v uint64) int {
	offset -= sovCrossChain(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CrossChainRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.SourceChain)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.DestinationChain)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.IbcChannel)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.Active {
		n += 2
	}
	l = m.MaxPositionValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if m.RiskParams != nil {
		l = m.RiskParams.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}

func (m *CrossChainRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionHaircut != 0 {
		n += 1 + sovCrossChain(uint64(m.PositionHaircut))
	}
	if m.MaxDriftThreshold != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxDriftThreshold))
	}
	if m.OperationTimeout != 0 {
		n += 1 + sovCrossChain(uint64(m.OperationTimeout))
	}
	if m.MaxRetries != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxRetries))
	}
	if m.ConservativeDiscount != 0 {
		n += 1 + sovCrossChain(uint64(m.ConservativeDiscount))
	}
	return n
}

func (m *RemotePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.RemoteAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.LocalAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = m.RemoteValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.ConservativeValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdate)
	n += 1 + l + sovCrossChain(uint64(l))
	if m.CurrentDrift != 0 {
		n += 1 + sovCrossChain(uint64(m.CurrentDrift))
	}
	if m.Status != 0 {
		n += 1 + sovCrossChain(uint64(m.Status))
	}
	l = m.AllocatedShares.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	return n
}

func (m *InFlightPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovCrossChain(uint64(m.Nonce))
	}
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.UserAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.OperationType != 0 {
		n += 1 + sovCrossChain(uint64(m.OperationType))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.Shares.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.InitiatedAt)
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedCompletion)
	n += 1 + l + sovCrossChain(uint64(l))
	if m.RetryCount != 0 {
		n += 1 + sovCrossChain(uint64(m.RetryCount))
	}
	if m.Status != 0 {
		n += 1 + sovCrossChain(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}

func (m *CrossChainPositionSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalRemoteValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.TotalConservativeValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if m.ActivePositions != 0 {
		n += 1 + sovCrossChain(uint64(m.ActivePositions))
	}
	if m.DriftExceededPositions != 0 {
		n += 1 + sovCrossChain(uint64(m.DriftExceededPositions))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.TotalRemoteShares.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	return n
}

func (m *DriftAlert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.UserAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.CurrentDrift != 0 {
		n += 1 + sovCrossChain(uint64(m.CurrentDrift))
	}
	if m.ThresholdExceeded != 0 {
		n += 1 + sovCrossChain(uint64(m.ThresholdExceeded))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovCrossChain(uint64(l))
	l = len(m.RecommendedAction)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}

func (m *CrossChainConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GlobalHaircut != 0 {
		n += 1 + sovCrossChain(uint64(m.GlobalHaircut))
	}
	if m.MaxRemoteExposure != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxRemoteExposure))
	}
	if m.DefaultTimeout != 0 {
		n += 1 + sovCrossChain(uint64(m.DefaultTimeout))
	}
	if m.UpdateFrequency != 0 {
		n += 1 + sovCrossChain(uint64(m.UpdateFrequency))
	}
	if m.EmergencyLiquidationThreshold != 0 {
		n += 1 + sovCrossChain(uint64(m.EmergencyLiquidationThreshold))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func sovCrossChain(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCrossChain(x uint64) (n int) {
	return sovCrossChain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CrossChainRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IbcChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPositionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxPositionValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RiskParams == nil {
				m.RiskParams = &CrossChainRiskParams{}
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionHaircut", wireType)
			}
			m.PositionHaircut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionHaircut |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDriftThreshold", wireType)
			}
			m.MaxDriftThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDriftThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationTimeout", wireType)
			}
			m.OperationTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
			}
			m.MaxRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConservativeDiscount", wireType)
			}
			m.ConservativeDiscount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConservativeDiscount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemotePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemotePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemotePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalAddress = append(m.LocalAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.LocalAddress == nil {
				m.LocalAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoteValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConservativeValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConservativeValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastUpdate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentDrift", wireType)
			}
			m.CurrentDrift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentDrift |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RemotePositionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocatedShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InFlightPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InFlightPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InFlightPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAddress = append(m.UserAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.UserAddress == nil {
				m.UserAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationType", wireType)
			}
			m.OperationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationType |= InFlightOperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.InitiatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedCompletion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedCompletion, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryCount", wireType)
			}
			m.RetryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= InFlightStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainPositionSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainPositionSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainPositionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRemoteValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRemoteValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalConservativeValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalConservativeValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePositions", wireType)
			}
			m.ActivePositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivePositions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriftExceededPositions", wireType)
			}
			m.DriftExceededPositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DriftExceededPositions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRemoteShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRemoteShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DriftAlert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DriftAlert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DriftAlert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAddress = append(m.UserAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.UserAddress == nil {
				m.UserAddress = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentDrift", wireType)
			}
			m.CurrentDrift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentDrift |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdExceeded", wireType)
			}
			m.ThresholdExceeded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThresholdExceeded |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendedAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecommendedAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalHaircut", wireType)
			}
			m.GlobalHaircut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalHaircut |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRemoteExposure", wireType)
			}
			m.MaxRemoteExposure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRemoteExposure |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTimeout", wireType)
			}
			m.DefaultTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateFrequency", wireType)
			}
			m.UpdateFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateFrequency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmergencyLiquidationThreshold", wireType)
			}
			m.EmergencyLiquidationThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmergencyLiquidationThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCrossChain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCrossChain
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCrossChain
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCrossChain
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCrossChain        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCrossChain          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCrossChain = fmt.Errorf("proto: unexpected end of group")
)
