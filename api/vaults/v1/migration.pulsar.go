// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package vaultsv1

import (
	_ "cosmossdk.io/api/amino"
	_ "cosmossdk.io/api/cosmos/msg/v1"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	reflect "reflect"
	sync "sync"
)

var (
	md_MsgMigratePosition             protoreflect.MessageDescriptor
	fd_MsgMigratePosition_signer      protoreflect.FieldDescriptor
	fd_MsgMigratePosition_vault_type  protoreflect.FieldDescriptor
	fd_MsgMigratePosition_amount      protoreflect.FieldDescriptor
	fd_MsgMigratePosition_forgo_yield protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_MsgMigratePosition = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("MsgMigratePosition")
	fd_MsgMigratePosition_signer = md_MsgMigratePosition.Fields().ByName("signer")
	fd_MsgMigratePosition_vault_type = md_MsgMigratePosition.Fields().ByName("vault_type")
	fd_MsgMigratePosition_amount = md_MsgMigratePosition.Fields().ByName("amount")
	fd_MsgMigratePosition_forgo_yield = md_MsgMigratePosition.Fields().ByName("forgo_yield")
}

var _ protoreflect.Message = (*fastReflection_MsgMigratePosition)(nil)

type fastReflection_MsgMigratePosition MsgMigratePosition

func (x *MsgMigratePosition) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgMigratePosition)(x)
}

func (x *MsgMigratePosition) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgMigratePosition_messageType fastReflection_MsgMigratePosition_messageType
var _ protoreflect.MessageType = fastReflection_MsgMigratePosition_messageType{}

type fastReflection_MsgMigratePosition_messageType struct{}

func (x fastReflection_MsgMigratePosition_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgMigratePosition)(nil)
}
func (x fastReflection_MsgMigratePosition_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgMigratePosition)
}
func (x fastReflection_MsgMigratePosition_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgMigratePosition
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgMigratePosition) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgMigratePosition
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgMigratePosition) Type() protoreflect.MessageType {
	return _fastReflection_MsgMigratePosition_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgMigratePosition) New() protoreflect.Message {
	return new(fastReflection_MsgMigratePosition)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgMigratePosition) Interface() protoreflect.ProtoMessage {
	return (*MsgMigratePosition)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgMigratePosition) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Signer != "" {
		value := protoreflect.ValueOfString(x.Signer)
		if !f(fd_MsgMigratePosition_signer, value) {
			return
		}
	}
	if x.VaultType != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.VaultType))
		if !f(fd_MsgMigratePosition_vault_type, value) {
			return
		}
	}
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_MsgMigratePosition_amount, value) {
			return
		}
	}
	if x.ForgoYield != false {
		value := protoreflect.ValueOfBool(x.ForgoYield)
		if !f(fd_MsgMigratePosition_forgo_yield, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgMigratePosition) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgMigratePosition.signer":
		return x.Signer != ""
	case "noble.dollar.vaults.v1.MsgMigratePosition.vault_type":
		return x.VaultType != 0
	case "noble.dollar.vaults.v1.MsgMigratePosition.amount":
		return x.Amount != ""
	case "noble.dollar.vaults.v1.MsgMigratePosition.forgo_yield":
		return x.ForgoYield != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgMigratePosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgMigratePosition does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMigratePosition) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgMigratePosition.signer":
		x.Signer = ""
	case "noble.dollar.vaults.v1.MsgMigratePosition.vault_type":
		x.VaultType = 0
	case "noble.dollar.vaults.v1.MsgMigratePosition.amount":
		x.Amount = ""
	case "noble.dollar.vaults.v1.MsgMigratePosition.forgo_yield":
		x.ForgoYield = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgMigratePosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgMigratePosition does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgMigratePosition) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.MsgMigratePosition.signer":
		value := x.Signer
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MsgMigratePosition.vault_type":
		value := x.VaultType
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "noble.dollar.vaults.v1.MsgMigratePosition.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MsgMigratePosition.forgo_yield":
		value := x.ForgoYield
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgMigratePosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgMigratePosition does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMigratePosition) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgMigratePosition.signer":
		x.Signer = value.Interface().(string)
	case "noble.dollar.vaults.v1.MsgMigratePosition.vault_type":
		x.VaultType = (VaultType)(value.Enum())
	case "noble.dollar.vaults.v1.MsgMigratePosition.amount":
		x.Amount = value.Interface().(string)
	case "noble.dollar.vaults.v1.MsgMigratePosition.forgo_yield":
		x.ForgoYield = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgMigratePosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgMigratePosition does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMigratePosition) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgMigratePosition.signer":
		panic(fmt.Errorf("field signer of message noble.dollar.vaults.v1.MsgMigratePosition is not mutable"))
	case "noble.dollar.vaults.v1.MsgMigratePosition.vault_type":
		panic(fmt.Errorf("field vault_type of message noble.dollar.vaults.v1.MsgMigratePosition is not mutable"))
	case "noble.dollar.vaults.v1.MsgMigratePosition.amount":
		panic(fmt.Errorf("field amount of message noble.dollar.vaults.v1.MsgMigratePosition is not mutable"))
	case "noble.dollar.vaults.v1.MsgMigratePosition.forgo_yield":
		panic(fmt.Errorf("field forgo_yield of message noble.dollar.vaults.v1.MsgMigratePosition is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgMigratePosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgMigratePosition does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgMigratePosition) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgMigratePosition.signer":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MsgMigratePosition.vault_type":
		return protoreflect.ValueOfEnum(0)
	case "noble.dollar.vaults.v1.MsgMigratePosition.amount":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MsgMigratePosition.forgo_yield":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgMigratePosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgMigratePosition does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgMigratePosition) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.MsgMigratePosition", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgMigratePosition) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMigratePosition) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgMigratePosition) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgMigratePosition) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgMigratePosition)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Signer)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.VaultType != 0 {
			n += 1 + runtime.Sov(uint64(x.VaultType))
		}
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ForgoYield {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgMigratePosition)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ForgoYield {
			i--
			if x.ForgoYield {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x20
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0x1a
		}
		if x.VaultType != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.VaultType))
			i--
			dAtA[i] = 0x10
		}
		if len(x.Signer) > 0 {
			i -= len(x.Signer)
			copy(dAtA[i:], x.Signer)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Signer)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgMigratePosition)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgMigratePosition: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgMigratePosition: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Signer = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
				}
				x.VaultType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.VaultType |= VaultType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ForgoYield", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.ForgoYield = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgMigratePositionResponse                    protoreflect.MessageDescriptor
	fd_MsgMigratePositionResponse_shares_received    protoreflect.FieldDescriptor
	fd_MsgMigratePositionResponse_principal_migrated protoreflect.FieldDescriptor
	fd_MsgMigratePositionResponse_rewards_migrated   protoreflect.FieldDescriptor
	fd_MsgMigratePositionResponse_migration_tx_hash  protoreflect.FieldDescriptor
	fd_MsgMigratePositionResponse_gas_used           protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_MsgMigratePositionResponse = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("MsgMigratePositionResponse")
	fd_MsgMigratePositionResponse_shares_received = md_MsgMigratePositionResponse.Fields().ByName("shares_received")
	fd_MsgMigratePositionResponse_principal_migrated = md_MsgMigratePositionResponse.Fields().ByName("principal_migrated")
	fd_MsgMigratePositionResponse_rewards_migrated = md_MsgMigratePositionResponse.Fields().ByName("rewards_migrated")
	fd_MsgMigratePositionResponse_migration_tx_hash = md_MsgMigratePositionResponse.Fields().ByName("migration_tx_hash")
	fd_MsgMigratePositionResponse_gas_used = md_MsgMigratePositionResponse.Fields().ByName("gas_used")
}

var _ protoreflect.Message = (*fastReflection_MsgMigratePositionResponse)(nil)

type fastReflection_MsgMigratePositionResponse MsgMigratePositionResponse

func (x *MsgMigratePositionResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgMigratePositionResponse)(x)
}

func (x *MsgMigratePositionResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgMigratePositionResponse_messageType fastReflection_MsgMigratePositionResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgMigratePositionResponse_messageType{}

type fastReflection_MsgMigratePositionResponse_messageType struct{}

func (x fastReflection_MsgMigratePositionResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgMigratePositionResponse)(nil)
}
func (x fastReflection_MsgMigratePositionResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgMigratePositionResponse)
}
func (x fastReflection_MsgMigratePositionResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgMigratePositionResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgMigratePositionResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgMigratePositionResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgMigratePositionResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgMigratePositionResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgMigratePositionResponse) New() protoreflect.Message {
	return new(fastReflection_MsgMigratePositionResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgMigratePositionResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgMigratePositionResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgMigratePositionResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.SharesReceived != "" {
		value := protoreflect.ValueOfString(x.SharesReceived)
		if !f(fd_MsgMigratePositionResponse_shares_received, value) {
			return
		}
	}
	if x.PrincipalMigrated != "" {
		value := protoreflect.ValueOfString(x.PrincipalMigrated)
		if !f(fd_MsgMigratePositionResponse_principal_migrated, value) {
			return
		}
	}
	if x.RewardsMigrated != "" {
		value := protoreflect.ValueOfString(x.RewardsMigrated)
		if !f(fd_MsgMigratePositionResponse_rewards_migrated, value) {
			return
		}
	}
	if x.MigrationTxHash != "" {
		value := protoreflect.ValueOfString(x.MigrationTxHash)
		if !f(fd_MsgMigratePositionResponse_migration_tx_hash, value) {
			return
		}
	}
	if x.GasUsed != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasUsed)
		if !f(fd_MsgMigratePositionResponse_gas_used, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgMigratePositionResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.shares_received":
		return x.SharesReceived != ""
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.principal_migrated":
		return x.PrincipalMigrated != ""
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.rewards_migrated":
		return x.RewardsMigrated != ""
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.migration_tx_hash":
		return x.MigrationTxHash != ""
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.gas_used":
		return x.GasUsed != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgMigratePositionResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgMigratePositionResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMigratePositionResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.shares_received":
		x.SharesReceived = ""
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.principal_migrated":
		x.PrincipalMigrated = ""
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.rewards_migrated":
		x.RewardsMigrated = ""
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.migration_tx_hash":
		x.MigrationTxHash = ""
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.gas_used":
		x.GasUsed = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgMigratePositionResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgMigratePositionResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgMigratePositionResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.shares_received":
		value := x.SharesReceived
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.principal_migrated":
		value := x.PrincipalMigrated
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.rewards_migrated":
		value := x.RewardsMigrated
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.migration_tx_hash":
		value := x.MigrationTxHash
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.gas_used":
		value := x.GasUsed
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgMigratePositionResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgMigratePositionResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMigratePositionResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.shares_received":
		x.SharesReceived = value.Interface().(string)
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.principal_migrated":
		x.PrincipalMigrated = value.Interface().(string)
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.rewards_migrated":
		x.RewardsMigrated = value.Interface().(string)
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.migration_tx_hash":
		x.MigrationTxHash = value.Interface().(string)
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.gas_used":
		x.GasUsed = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgMigratePositionResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgMigratePositionResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMigratePositionResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.shares_received":
		panic(fmt.Errorf("field shares_received of message noble.dollar.vaults.v1.MsgMigratePositionResponse is not mutable"))
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.principal_migrated":
		panic(fmt.Errorf("field principal_migrated of message noble.dollar.vaults.v1.MsgMigratePositionResponse is not mutable"))
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.rewards_migrated":
		panic(fmt.Errorf("field rewards_migrated of message noble.dollar.vaults.v1.MsgMigratePositionResponse is not mutable"))
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.migration_tx_hash":
		panic(fmt.Errorf("field migration_tx_hash of message noble.dollar.vaults.v1.MsgMigratePositionResponse is not mutable"))
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.gas_used":
		panic(fmt.Errorf("field gas_used of message noble.dollar.vaults.v1.MsgMigratePositionResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgMigratePositionResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgMigratePositionResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgMigratePositionResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.shares_received":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.principal_migrated":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.rewards_migrated":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.migration_tx_hash":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MsgMigratePositionResponse.gas_used":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgMigratePositionResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgMigratePositionResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgMigratePositionResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.MsgMigratePositionResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgMigratePositionResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMigratePositionResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgMigratePositionResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgMigratePositionResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgMigratePositionResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.SharesReceived)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PrincipalMigrated)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RewardsMigrated)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MigrationTxHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.GasUsed != 0 {
			n += 1 + runtime.Sov(uint64(x.GasUsed))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgMigratePositionResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.GasUsed != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasUsed))
			i--
			dAtA[i] = 0x28
		}
		if len(x.MigrationTxHash) > 0 {
			i -= len(x.MigrationTxHash)
			copy(dAtA[i:], x.MigrationTxHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MigrationTxHash)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.RewardsMigrated) > 0 {
			i -= len(x.RewardsMigrated)
			copy(dAtA[i:], x.RewardsMigrated)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RewardsMigrated)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PrincipalMigrated) > 0 {
			i -= len(x.PrincipalMigrated)
			copy(dAtA[i:], x.PrincipalMigrated)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrincipalMigrated)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.SharesReceived) > 0 {
			i -= len(x.SharesReceived)
			copy(dAtA[i:], x.SharesReceived)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SharesReceived)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgMigratePositionResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgMigratePositionResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgMigratePositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SharesReceived", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SharesReceived = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrincipalMigrated", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrincipalMigrated = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RewardsMigrated", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RewardsMigrated = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MigrationTxHash", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MigrationTxHash = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
				}
				x.GasUsed = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasUsed |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_MsgEmergencyWithdrawLegacy_3_list)(nil)

type _MsgEmergencyWithdrawLegacy_3_list struct {
	list *[]int64
}

func (x *_MsgEmergencyWithdrawLegacy_3_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MsgEmergencyWithdrawLegacy_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfInt64((*x.list)[i])
}

func (x *_MsgEmergencyWithdrawLegacy_3_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Int()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_MsgEmergencyWithdrawLegacy_3_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Int()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_MsgEmergencyWithdrawLegacy_3_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message MsgEmergencyWithdrawLegacy at list field PositionIndices as it is not of Message kind"))
}

func (x *_MsgEmergencyWithdrawLegacy_3_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_MsgEmergencyWithdrawLegacy_3_list) NewElement() protoreflect.Value {
	v := int64(0)
	return protoreflect.ValueOfInt64(v)
}

func (x *_MsgEmergencyWithdrawLegacy_3_list) IsValid() bool {
	return x.list != nil
}

var (
	md_MsgEmergencyWithdrawLegacy                  protoreflect.MessageDescriptor
	fd_MsgEmergencyWithdrawLegacy_signer           protoreflect.FieldDescriptor
	fd_MsgEmergencyWithdrawLegacy_vault_type       protoreflect.FieldDescriptor
	fd_MsgEmergencyWithdrawLegacy_position_indices protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_MsgEmergencyWithdrawLegacy = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("MsgEmergencyWithdrawLegacy")
	fd_MsgEmergencyWithdrawLegacy_signer = md_MsgEmergencyWithdrawLegacy.Fields().ByName("signer")
	fd_MsgEmergencyWithdrawLegacy_vault_type = md_MsgEmergencyWithdrawLegacy.Fields().ByName("vault_type")
	fd_MsgEmergencyWithdrawLegacy_position_indices = md_MsgEmergencyWithdrawLegacy.Fields().ByName("position_indices")
}

var _ protoreflect.Message = (*fastReflection_MsgEmergencyWithdrawLegacy)(nil)

type fastReflection_MsgEmergencyWithdrawLegacy MsgEmergencyWithdrawLegacy

func (x *MsgEmergencyWithdrawLegacy) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgEmergencyWithdrawLegacy)(x)
}

func (x *MsgEmergencyWithdrawLegacy) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgEmergencyWithdrawLegacy_messageType fastReflection_MsgEmergencyWithdrawLegacy_messageType
var _ protoreflect.MessageType = fastReflection_MsgEmergencyWithdrawLegacy_messageType{}

type fastReflection_MsgEmergencyWithdrawLegacy_messageType struct{}

func (x fastReflection_MsgEmergencyWithdrawLegacy_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgEmergencyWithdrawLegacy)(nil)
}
func (x fastReflection_MsgEmergencyWithdrawLegacy_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgEmergencyWithdrawLegacy)
}
func (x fastReflection_MsgEmergencyWithdrawLegacy_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgEmergencyWithdrawLegacy
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgEmergencyWithdrawLegacy
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) Type() protoreflect.MessageType {
	return _fastReflection_MsgEmergencyWithdrawLegacy_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) New() protoreflect.Message {
	return new(fastReflection_MsgEmergencyWithdrawLegacy)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) Interface() protoreflect.ProtoMessage {
	return (*MsgEmergencyWithdrawLegacy)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Signer != "" {
		value := protoreflect.ValueOfString(x.Signer)
		if !f(fd_MsgEmergencyWithdrawLegacy_signer, value) {
			return
		}
	}
	if x.VaultType != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.VaultType))
		if !f(fd_MsgEmergencyWithdrawLegacy_vault_type, value) {
			return
		}
	}
	if len(x.PositionIndices) != 0 {
		value := protoreflect.ValueOfList(&_MsgEmergencyWithdrawLegacy_3_list{list: &x.PositionIndices})
		if !f(fd_MsgEmergencyWithdrawLegacy_position_indices, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.signer":
		return x.Signer != ""
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.vault_type":
		return x.VaultType != 0
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.position_indices":
		return len(x.PositionIndices) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.signer":
		x.Signer = ""
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.vault_type":
		x.VaultType = 0
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.position_indices":
		x.PositionIndices = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.signer":
		value := x.Signer
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.vault_type":
		value := x.VaultType
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.position_indices":
		if len(x.PositionIndices) == 0 {
			return protoreflect.ValueOfList(&_MsgEmergencyWithdrawLegacy_3_list{})
		}
		listValue := &_MsgEmergencyWithdrawLegacy_3_list{list: &x.PositionIndices}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.signer":
		x.Signer = value.Interface().(string)
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.vault_type":
		x.VaultType = (VaultType)(value.Enum())
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.position_indices":
		lv := value.List()
		clv := lv.(*_MsgEmergencyWithdrawLegacy_3_list)
		x.PositionIndices = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.position_indices":
		if x.PositionIndices == nil {
			x.PositionIndices = []int64{}
		}
		value := &_MsgEmergencyWithdrawLegacy_3_list{list: &x.PositionIndices}
		return protoreflect.ValueOfList(value)
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.signer":
		panic(fmt.Errorf("field signer of message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy is not mutable"))
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.vault_type":
		panic(fmt.Errorf("field vault_type of message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.signer":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.vault_type":
		return protoreflect.ValueOfEnum(0)
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.position_indices":
		list := []int64{}
		return protoreflect.ValueOfList(&_MsgEmergencyWithdrawLegacy_3_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgEmergencyWithdrawLegacy) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgEmergencyWithdrawLegacy)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Signer)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.VaultType != 0 {
			n += 1 + runtime.Sov(uint64(x.VaultType))
		}
		if len(x.PositionIndices) > 0 {
			l = 0
			for _, e := range x.PositionIndices {
				l += runtime.Sov(uint64(e))
			}
			n += 1 + runtime.Sov(uint64(l)) + l
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgEmergencyWithdrawLegacy)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.PositionIndices) > 0 {
			var pksize2 int
			for _, num := range x.PositionIndices {
				pksize2 += runtime.Sov(uint64(num))
			}
			i -= pksize2
			j1 := i
			for _, num1 := range x.PositionIndices {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
			i = runtime.EncodeVarint(dAtA, i, uint64(pksize2))
			i--
			dAtA[i] = 0x1a
		}
		if x.VaultType != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.VaultType))
			i--
			dAtA[i] = 0x10
		}
		if len(x.Signer) > 0 {
			i -= len(x.Signer)
			copy(dAtA[i:], x.Signer)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Signer)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgEmergencyWithdrawLegacy)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgEmergencyWithdrawLegacy: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgEmergencyWithdrawLegacy: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Signer = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
				}
				x.VaultType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.VaultType |= VaultType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType == 0 {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					x.PositionIndices = append(x.PositionIndices, v)
				} else if wireType == 2 {
					var packedLen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						packedLen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if packedLen < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					postIndex := iNdEx + packedLen
					if postIndex < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					if postIndex > l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					var elementCount int
					var count int
					for _, integer := range dAtA[iNdEx:postIndex] {
						if integer < 128 {
							count++
						}
					}
					elementCount = count
					if elementCount != 0 && len(x.PositionIndices) == 0 {
						x.PositionIndices = make([]int64, 0, elementCount)
					}
					for iNdEx < postIndex {
						var v int64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							v |= int64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						x.PositionIndices = append(x.PositionIndices, v)
					}
				} else {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PositionIndices", wireType)
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgEmergencyWithdrawLegacyResponse                     protoreflect.MessageDescriptor
	fd_MsgEmergencyWithdrawLegacyResponse_amount_withdrawn    protoreflect.FieldDescriptor
	fd_MsgEmergencyWithdrawLegacyResponse_positions_withdrawn protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_MsgEmergencyWithdrawLegacyResponse = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("MsgEmergencyWithdrawLegacyResponse")
	fd_MsgEmergencyWithdrawLegacyResponse_amount_withdrawn = md_MsgEmergencyWithdrawLegacyResponse.Fields().ByName("amount_withdrawn")
	fd_MsgEmergencyWithdrawLegacyResponse_positions_withdrawn = md_MsgEmergencyWithdrawLegacyResponse.Fields().ByName("positions_withdrawn")
}

var _ protoreflect.Message = (*fastReflection_MsgEmergencyWithdrawLegacyResponse)(nil)

type fastReflection_MsgEmergencyWithdrawLegacyResponse MsgEmergencyWithdrawLegacyResponse

func (x *MsgEmergencyWithdrawLegacyResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgEmergencyWithdrawLegacyResponse)(x)
}

func (x *MsgEmergencyWithdrawLegacyResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgEmergencyWithdrawLegacyResponse_messageType fastReflection_MsgEmergencyWithdrawLegacyResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgEmergencyWithdrawLegacyResponse_messageType{}

type fastReflection_MsgEmergencyWithdrawLegacyResponse_messageType struct{}

func (x fastReflection_MsgEmergencyWithdrawLegacyResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgEmergencyWithdrawLegacyResponse)(nil)
}
func (x fastReflection_MsgEmergencyWithdrawLegacyResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgEmergencyWithdrawLegacyResponse)
}
func (x fastReflection_MsgEmergencyWithdrawLegacyResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgEmergencyWithdrawLegacyResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgEmergencyWithdrawLegacyResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgEmergencyWithdrawLegacyResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) New() protoreflect.Message {
	return new(fastReflection_MsgEmergencyWithdrawLegacyResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgEmergencyWithdrawLegacyResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.AmountWithdrawn != "" {
		value := protoreflect.ValueOfString(x.AmountWithdrawn)
		if !f(fd_MsgEmergencyWithdrawLegacyResponse_amount_withdrawn, value) {
			return
		}
	}
	if x.PositionsWithdrawn != int64(0) {
		value := protoreflect.ValueOfInt64(x.PositionsWithdrawn)
		if !f(fd_MsgEmergencyWithdrawLegacyResponse_positions_withdrawn, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse.amount_withdrawn":
		return x.AmountWithdrawn != ""
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse.positions_withdrawn":
		return x.PositionsWithdrawn != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse.amount_withdrawn":
		x.AmountWithdrawn = ""
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse.positions_withdrawn":
		x.PositionsWithdrawn = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse.amount_withdrawn":
		value := x.AmountWithdrawn
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse.positions_withdrawn":
		value := x.PositionsWithdrawn
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse.amount_withdrawn":
		x.AmountWithdrawn = value.Interface().(string)
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse.positions_withdrawn":
		x.PositionsWithdrawn = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse.amount_withdrawn":
		panic(fmt.Errorf("field amount_withdrawn of message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse is not mutable"))
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse.positions_withdrawn":
		panic(fmt.Errorf("field positions_withdrawn of message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse.amount_withdrawn":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse.positions_withdrawn":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgEmergencyWithdrawLegacyResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgEmergencyWithdrawLegacyResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.AmountWithdrawn)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.PositionsWithdrawn != 0 {
			n += 1 + runtime.Sov(uint64(x.PositionsWithdrawn))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgEmergencyWithdrawLegacyResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.PositionsWithdrawn != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PositionsWithdrawn))
			i--
			dAtA[i] = 0x10
		}
		if len(x.AmountWithdrawn) > 0 {
			i -= len(x.AmountWithdrawn)
			copy(dAtA[i:], x.AmountWithdrawn)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AmountWithdrawn)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgEmergencyWithdrawLegacyResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgEmergencyWithdrawLegacyResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgEmergencyWithdrawLegacyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AmountWithdrawn", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AmountWithdrawn = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PositionsWithdrawn", wireType)
				}
				x.PositionsWithdrawn = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PositionsWithdrawn |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgUpdateMigrationState           protoreflect.MessageDescriptor
	fd_MsgUpdateMigrationState_authority protoreflect.FieldDescriptor
	fd_MsgUpdateMigrationState_new_state protoreflect.FieldDescriptor
	fd_MsgUpdateMigrationState_reason    protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_MsgUpdateMigrationState = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("MsgUpdateMigrationState")
	fd_MsgUpdateMigrationState_authority = md_MsgUpdateMigrationState.Fields().ByName("authority")
	fd_MsgUpdateMigrationState_new_state = md_MsgUpdateMigrationState.Fields().ByName("new_state")
	fd_MsgUpdateMigrationState_reason = md_MsgUpdateMigrationState.Fields().ByName("reason")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateMigrationState)(nil)

type fastReflection_MsgUpdateMigrationState MsgUpdateMigrationState

func (x *MsgUpdateMigrationState) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateMigrationState)(x)
}

func (x *MsgUpdateMigrationState) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateMigrationState_messageType fastReflection_MsgUpdateMigrationState_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateMigrationState_messageType{}

type fastReflection_MsgUpdateMigrationState_messageType struct{}

func (x fastReflection_MsgUpdateMigrationState_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateMigrationState)(nil)
}
func (x fastReflection_MsgUpdateMigrationState_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateMigrationState)
}
func (x fastReflection_MsgUpdateMigrationState_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateMigrationState
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateMigrationState) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateMigrationState
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateMigrationState) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateMigrationState_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateMigrationState) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateMigrationState)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateMigrationState) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateMigrationState)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateMigrationState) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Authority != "" {
		value := protoreflect.ValueOfString(x.Authority)
		if !f(fd_MsgUpdateMigrationState_authority, value) {
			return
		}
	}
	if x.NewState != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.NewState))
		if !f(fd_MsgUpdateMigrationState_new_state, value) {
			return
		}
	}
	if x.Reason != "" {
		value := protoreflect.ValueOfString(x.Reason)
		if !f(fd_MsgUpdateMigrationState_reason, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateMigrationState) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.authority":
		return x.Authority != ""
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.new_state":
		return x.NewState != 0
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.reason":
		return x.Reason != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgUpdateMigrationState"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgUpdateMigrationState does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMigrationState) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.authority":
		x.Authority = ""
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.new_state":
		x.NewState = 0
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.reason":
		x.Reason = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgUpdateMigrationState"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgUpdateMigrationState does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateMigrationState) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.authority":
		value := x.Authority
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.new_state":
		value := x.NewState
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.reason":
		value := x.Reason
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgUpdateMigrationState"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgUpdateMigrationState does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMigrationState) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.authority":
		x.Authority = value.Interface().(string)
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.new_state":
		x.NewState = (MigrationState)(value.Enum())
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.reason":
		x.Reason = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgUpdateMigrationState"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgUpdateMigrationState does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMigrationState) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.authority":
		panic(fmt.Errorf("field authority of message noble.dollar.vaults.v1.MsgUpdateMigrationState is not mutable"))
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.new_state":
		panic(fmt.Errorf("field new_state of message noble.dollar.vaults.v1.MsgUpdateMigrationState is not mutable"))
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.reason":
		panic(fmt.Errorf("field reason of message noble.dollar.vaults.v1.MsgUpdateMigrationState is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgUpdateMigrationState"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgUpdateMigrationState does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateMigrationState) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.authority":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.new_state":
		return protoreflect.ValueOfEnum(0)
	case "noble.dollar.vaults.v1.MsgUpdateMigrationState.reason":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgUpdateMigrationState"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgUpdateMigrationState does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateMigrationState) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.MsgUpdateMigrationState", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateMigrationState) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMigrationState) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateMigrationState) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateMigrationState) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateMigrationState)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Authority)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.NewState != 0 {
			n += 1 + runtime.Sov(uint64(x.NewState))
		}
		l = len(x.Reason)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateMigrationState)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Reason) > 0 {
			i -= len(x.Reason)
			copy(dAtA[i:], x.Reason)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Reason)))
			i--
			dAtA[i] = 0x1a
		}
		if x.NewState != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NewState))
			i--
			dAtA[i] = 0x10
		}
		if len(x.Authority) > 0 {
			i -= len(x.Authority)
			copy(dAtA[i:], x.Authority)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Authority)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateMigrationState)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateMigrationState: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateMigrationState: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Authority = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NewState", wireType)
				}
				x.NewState = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NewState |= MigrationState(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Reason = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgUpdateMigrationStateResponse                protoreflect.MessageDescriptor
	fd_MsgUpdateMigrationStateResponse_previous_state protoreflect.FieldDescriptor
	fd_MsgUpdateMigrationStateResponse_new_state      protoreflect.FieldDescriptor
	fd_MsgUpdateMigrationStateResponse_updated_at     protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_MsgUpdateMigrationStateResponse = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("MsgUpdateMigrationStateResponse")
	fd_MsgUpdateMigrationStateResponse_previous_state = md_MsgUpdateMigrationStateResponse.Fields().ByName("previous_state")
	fd_MsgUpdateMigrationStateResponse_new_state = md_MsgUpdateMigrationStateResponse.Fields().ByName("new_state")
	fd_MsgUpdateMigrationStateResponse_updated_at = md_MsgUpdateMigrationStateResponse.Fields().ByName("updated_at")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateMigrationStateResponse)(nil)

type fastReflection_MsgUpdateMigrationStateResponse MsgUpdateMigrationStateResponse

func (x *MsgUpdateMigrationStateResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateMigrationStateResponse)(x)
}

func (x *MsgUpdateMigrationStateResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateMigrationStateResponse_messageType fastReflection_MsgUpdateMigrationStateResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateMigrationStateResponse_messageType{}

type fastReflection_MsgUpdateMigrationStateResponse_messageType struct{}

func (x fastReflection_MsgUpdateMigrationStateResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateMigrationStateResponse)(nil)
}
func (x fastReflection_MsgUpdateMigrationStateResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateMigrationStateResponse)
}
func (x fastReflection_MsgUpdateMigrationStateResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateMigrationStateResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateMigrationStateResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateMigrationStateResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateMigrationStateResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateMigrationStateResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateMigrationStateResponse) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateMigrationStateResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateMigrationStateResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateMigrationStateResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateMigrationStateResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PreviousState != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.PreviousState))
		if !f(fd_MsgUpdateMigrationStateResponse_previous_state, value) {
			return
		}
	}
	if x.NewState != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.NewState))
		if !f(fd_MsgUpdateMigrationStateResponse_new_state, value) {
			return
		}
	}
	if x.UpdatedAt != nil {
		value := protoreflect.ValueOfMessage(x.UpdatedAt.ProtoReflect())
		if !f(fd_MsgUpdateMigrationStateResponse_updated_at, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateMigrationStateResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.previous_state":
		return x.PreviousState != 0
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.new_state":
		return x.NewState != 0
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.updated_at":
		return x.UpdatedAt != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMigrationStateResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.previous_state":
		x.PreviousState = 0
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.new_state":
		x.NewState = 0
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.updated_at":
		x.UpdatedAt = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateMigrationStateResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.previous_state":
		value := x.PreviousState
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.new_state":
		value := x.NewState
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.updated_at":
		value := x.UpdatedAt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMigrationStateResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.previous_state":
		x.PreviousState = (MigrationState)(value.Enum())
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.new_state":
		x.NewState = (MigrationState)(value.Enum())
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.updated_at":
		x.UpdatedAt = value.Message().Interface().(*timestamppb.Timestamp)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMigrationStateResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.updated_at":
		if x.UpdatedAt == nil {
			x.UpdatedAt = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.UpdatedAt.ProtoReflect())
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.previous_state":
		panic(fmt.Errorf("field previous_state of message noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse is not mutable"))
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.new_state":
		panic(fmt.Errorf("field new_state of message noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateMigrationStateResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.previous_state":
		return protoreflect.ValueOfEnum(0)
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.new_state":
		return protoreflect.ValueOfEnum(0)
	case "noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.updated_at":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateMigrationStateResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateMigrationStateResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMigrationStateResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateMigrationStateResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateMigrationStateResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateMigrationStateResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.PreviousState != 0 {
			n += 1 + runtime.Sov(uint64(x.PreviousState))
		}
		if x.NewState != 0 {
			n += 1 + runtime.Sov(uint64(x.NewState))
		}
		if x.UpdatedAt != nil {
			l = options.Size(x.UpdatedAt)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateMigrationStateResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.UpdatedAt != nil {
			encoded, err := options.Marshal(x.UpdatedAt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if x.NewState != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NewState))
			i--
			dAtA[i] = 0x10
		}
		if x.PreviousState != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PreviousState))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateMigrationStateResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateMigrationStateResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateMigrationStateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PreviousState", wireType)
				}
				x.PreviousState = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PreviousState |= MigrationState(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NewState", wireType)
				}
				x.NewState = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NewState |= MigrationState(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.UpdatedAt == nil {
					x.UpdatedAt = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.UpdatedAt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MigrationConfig                         protoreflect.MessageDescriptor
	fd_MigrationConfig_start_time              protoreflect.FieldDescriptor
	fd_MigrationConfig_closing_time            protoreflect.FieldDescriptor
	fd_MigrationConfig_final_deadline          protoreflect.FieldDescriptor
	fd_MigrationConfig_max_migration_per_block protoreflect.FieldDescriptor
	fd_MigrationConfig_min_migration_amount    protoreflect.FieldDescriptor
	fd_MigrationConfig_require_full_migration  protoreflect.FieldDescriptor
	fd_MigrationConfig_migration_enabled       protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_MigrationConfig = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("MigrationConfig")
	fd_MigrationConfig_start_time = md_MigrationConfig.Fields().ByName("start_time")
	fd_MigrationConfig_closing_time = md_MigrationConfig.Fields().ByName("closing_time")
	fd_MigrationConfig_final_deadline = md_MigrationConfig.Fields().ByName("final_deadline")
	fd_MigrationConfig_max_migration_per_block = md_MigrationConfig.Fields().ByName("max_migration_per_block")
	fd_MigrationConfig_min_migration_amount = md_MigrationConfig.Fields().ByName("min_migration_amount")
	fd_MigrationConfig_require_full_migration = md_MigrationConfig.Fields().ByName("require_full_migration")
	fd_MigrationConfig_migration_enabled = md_MigrationConfig.Fields().ByName("migration_enabled")
}

var _ protoreflect.Message = (*fastReflection_MigrationConfig)(nil)

type fastReflection_MigrationConfig MigrationConfig

func (x *MigrationConfig) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MigrationConfig)(x)
}

func (x *MigrationConfig) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MigrationConfig_messageType fastReflection_MigrationConfig_messageType
var _ protoreflect.MessageType = fastReflection_MigrationConfig_messageType{}

type fastReflection_MigrationConfig_messageType struct{}

func (x fastReflection_MigrationConfig_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MigrationConfig)(nil)
}
func (x fastReflection_MigrationConfig_messageType) New() protoreflect.Message {
	return new(fastReflection_MigrationConfig)
}
func (x fastReflection_MigrationConfig_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MigrationConfig
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MigrationConfig) Descriptor() protoreflect.MessageDescriptor {
	return md_MigrationConfig
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MigrationConfig) Type() protoreflect.MessageType {
	return _fastReflection_MigrationConfig_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MigrationConfig) New() protoreflect.Message {
	return new(fastReflection_MigrationConfig)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MigrationConfig) Interface() protoreflect.ProtoMessage {
	return (*MigrationConfig)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MigrationConfig) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.StartTime != nil {
		value := protoreflect.ValueOfMessage(x.StartTime.ProtoReflect())
		if !f(fd_MigrationConfig_start_time, value) {
			return
		}
	}
	if x.ClosingTime != nil {
		value := protoreflect.ValueOfMessage(x.ClosingTime.ProtoReflect())
		if !f(fd_MigrationConfig_closing_time, value) {
			return
		}
	}
	if x.FinalDeadline != nil {
		value := protoreflect.ValueOfMessage(x.FinalDeadline.ProtoReflect())
		if !f(fd_MigrationConfig_final_deadline, value) {
			return
		}
	}
	if x.MaxMigrationPerBlock != int64(0) {
		value := protoreflect.ValueOfInt64(x.MaxMigrationPerBlock)
		if !f(fd_MigrationConfig_max_migration_per_block, value) {
			return
		}
	}
	if x.MinMigrationAmount != "" {
		value := protoreflect.ValueOfString(x.MinMigrationAmount)
		if !f(fd_MigrationConfig_min_migration_amount, value) {
			return
		}
	}
	if x.RequireFullMigration != false {
		value := protoreflect.ValueOfBool(x.RequireFullMigration)
		if !f(fd_MigrationConfig_require_full_migration, value) {
			return
		}
	}
	if x.MigrationEnabled != false {
		value := protoreflect.ValueOfBool(x.MigrationEnabled)
		if !f(fd_MigrationConfig_migration_enabled, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MigrationConfig) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationConfig.start_time":
		return x.StartTime != nil
	case "noble.dollar.vaults.v1.MigrationConfig.closing_time":
		return x.ClosingTime != nil
	case "noble.dollar.vaults.v1.MigrationConfig.final_deadline":
		return x.FinalDeadline != nil
	case "noble.dollar.vaults.v1.MigrationConfig.max_migration_per_block":
		return x.MaxMigrationPerBlock != int64(0)
	case "noble.dollar.vaults.v1.MigrationConfig.min_migration_amount":
		return x.MinMigrationAmount != ""
	case "noble.dollar.vaults.v1.MigrationConfig.require_full_migration":
		return x.RequireFullMigration != false
	case "noble.dollar.vaults.v1.MigrationConfig.migration_enabled":
		return x.MigrationEnabled != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationConfig does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationConfig) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationConfig.start_time":
		x.StartTime = nil
	case "noble.dollar.vaults.v1.MigrationConfig.closing_time":
		x.ClosingTime = nil
	case "noble.dollar.vaults.v1.MigrationConfig.final_deadline":
		x.FinalDeadline = nil
	case "noble.dollar.vaults.v1.MigrationConfig.max_migration_per_block":
		x.MaxMigrationPerBlock = int64(0)
	case "noble.dollar.vaults.v1.MigrationConfig.min_migration_amount":
		x.MinMigrationAmount = ""
	case "noble.dollar.vaults.v1.MigrationConfig.require_full_migration":
		x.RequireFullMigration = false
	case "noble.dollar.vaults.v1.MigrationConfig.migration_enabled":
		x.MigrationEnabled = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationConfig does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MigrationConfig) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.MigrationConfig.start_time":
		value := x.StartTime
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationConfig.closing_time":
		value := x.ClosingTime
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationConfig.final_deadline":
		value := x.FinalDeadline
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationConfig.max_migration_per_block":
		value := x.MaxMigrationPerBlock
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v1.MigrationConfig.min_migration_amount":
		value := x.MinMigrationAmount
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MigrationConfig.require_full_migration":
		value := x.RequireFullMigration
		return protoreflect.ValueOfBool(value)
	case "noble.dollar.vaults.v1.MigrationConfig.migration_enabled":
		value := x.MigrationEnabled
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationConfig does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationConfig) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationConfig.start_time":
		x.StartTime = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v1.MigrationConfig.closing_time":
		x.ClosingTime = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v1.MigrationConfig.final_deadline":
		x.FinalDeadline = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v1.MigrationConfig.max_migration_per_block":
		x.MaxMigrationPerBlock = value.Int()
	case "noble.dollar.vaults.v1.MigrationConfig.min_migration_amount":
		x.MinMigrationAmount = value.Interface().(string)
	case "noble.dollar.vaults.v1.MigrationConfig.require_full_migration":
		x.RequireFullMigration = value.Bool()
	case "noble.dollar.vaults.v1.MigrationConfig.migration_enabled":
		x.MigrationEnabled = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationConfig does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationConfig) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationConfig.start_time":
		if x.StartTime == nil {
			x.StartTime = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.StartTime.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationConfig.closing_time":
		if x.ClosingTime == nil {
			x.ClosingTime = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.ClosingTime.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationConfig.final_deadline":
		if x.FinalDeadline == nil {
			x.FinalDeadline = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.FinalDeadline.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationConfig.max_migration_per_block":
		panic(fmt.Errorf("field max_migration_per_block of message noble.dollar.vaults.v1.MigrationConfig is not mutable"))
	case "noble.dollar.vaults.v1.MigrationConfig.min_migration_amount":
		panic(fmt.Errorf("field min_migration_amount of message noble.dollar.vaults.v1.MigrationConfig is not mutable"))
	case "noble.dollar.vaults.v1.MigrationConfig.require_full_migration":
		panic(fmt.Errorf("field require_full_migration of message noble.dollar.vaults.v1.MigrationConfig is not mutable"))
	case "noble.dollar.vaults.v1.MigrationConfig.migration_enabled":
		panic(fmt.Errorf("field migration_enabled of message noble.dollar.vaults.v1.MigrationConfig is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationConfig does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MigrationConfig) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationConfig.start_time":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationConfig.closing_time":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationConfig.final_deadline":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationConfig.max_migration_per_block":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v1.MigrationConfig.min_migration_amount":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MigrationConfig.require_full_migration":
		return protoreflect.ValueOfBool(false)
	case "noble.dollar.vaults.v1.MigrationConfig.migration_enabled":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationConfig does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MigrationConfig) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.MigrationConfig", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MigrationConfig) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationConfig) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MigrationConfig) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MigrationConfig) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MigrationConfig)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.StartTime != nil {
			l = options.Size(x.StartTime)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ClosingTime != nil {
			l = options.Size(x.ClosingTime)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.FinalDeadline != nil {
			l = options.Size(x.FinalDeadline)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.MaxMigrationPerBlock != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxMigrationPerBlock))
		}
		l = len(x.MinMigrationAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RequireFullMigration {
			n += 2
		}
		if x.MigrationEnabled {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MigrationConfig)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.MigrationEnabled {
			i--
			if x.MigrationEnabled {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x38
		}
		if x.RequireFullMigration {
			i--
			if x.RequireFullMigration {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x30
		}
		if len(x.MinMigrationAmount) > 0 {
			i -= len(x.MinMigrationAmount)
			copy(dAtA[i:], x.MinMigrationAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MinMigrationAmount)))
			i--
			dAtA[i] = 0x2a
		}
		if x.MaxMigrationPerBlock != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxMigrationPerBlock))
			i--
			dAtA[i] = 0x20
		}
		if x.FinalDeadline != nil {
			encoded, err := options.Marshal(x.FinalDeadline)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if x.ClosingTime != nil {
			encoded, err := options.Marshal(x.ClosingTime)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if x.StartTime != nil {
			encoded, err := options.Marshal(x.StartTime)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MigrationConfig)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MigrationConfig: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MigrationConfig: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.StartTime == nil {
					x.StartTime = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.StartTime); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ClosingTime", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ClosingTime == nil {
					x.ClosingTime = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ClosingTime); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FinalDeadline", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.FinalDeadline == nil {
					x.FinalDeadline = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.FinalDeadline); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxMigrationPerBlock", wireType)
				}
				x.MaxMigrationPerBlock = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxMigrationPerBlock |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MinMigrationAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MinMigrationAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequireFullMigration", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.RequireFullMigration = bool(v != 0)
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MigrationEnabled", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.MigrationEnabled = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_UserMigrationRecord                       protoreflect.MessageDescriptor
	fd_UserMigrationRecord_migrated_at           protoreflect.FieldDescriptor
	fd_UserMigrationRecord_from_vault_type       protoreflect.FieldDescriptor
	fd_UserMigrationRecord_legacy_position_count protoreflect.FieldDescriptor
	fd_UserMigrationRecord_principal_migrated    protoreflect.FieldDescriptor
	fd_UserMigrationRecord_rewards_migrated      protoreflect.FieldDescriptor
	fd_UserMigrationRecord_shares_received       protoreflect.FieldDescriptor
	fd_UserMigrationRecord_migration_tx_hash     protoreflect.FieldDescriptor
	fd_UserMigrationRecord_gas_used              protoreflect.FieldDescriptor
	fd_UserMigrationRecord_yield_forgone         protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_UserMigrationRecord = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("UserMigrationRecord")
	fd_UserMigrationRecord_migrated_at = md_UserMigrationRecord.Fields().ByName("migrated_at")
	fd_UserMigrationRecord_from_vault_type = md_UserMigrationRecord.Fields().ByName("from_vault_type")
	fd_UserMigrationRecord_legacy_position_count = md_UserMigrationRecord.Fields().ByName("legacy_position_count")
	fd_UserMigrationRecord_principal_migrated = md_UserMigrationRecord.Fields().ByName("principal_migrated")
	fd_UserMigrationRecord_rewards_migrated = md_UserMigrationRecord.Fields().ByName("rewards_migrated")
	fd_UserMigrationRecord_shares_received = md_UserMigrationRecord.Fields().ByName("shares_received")
	fd_UserMigrationRecord_migration_tx_hash = md_UserMigrationRecord.Fields().ByName("migration_tx_hash")
	fd_UserMigrationRecord_gas_used = md_UserMigrationRecord.Fields().ByName("gas_used")
	fd_UserMigrationRecord_yield_forgone = md_UserMigrationRecord.Fields().ByName("yield_forgone")
}

var _ protoreflect.Message = (*fastReflection_UserMigrationRecord)(nil)

type fastReflection_UserMigrationRecord UserMigrationRecord

func (x *UserMigrationRecord) ProtoReflect() protoreflect.Message {
	return (*fastReflection_UserMigrationRecord)(x)
}

func (x *UserMigrationRecord) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_UserMigrationRecord_messageType fastReflection_UserMigrationRecord_messageType
var _ protoreflect.MessageType = fastReflection_UserMigrationRecord_messageType{}

type fastReflection_UserMigrationRecord_messageType struct{}

func (x fastReflection_UserMigrationRecord_messageType) Zero() protoreflect.Message {
	return (*fastReflection_UserMigrationRecord)(nil)
}
func (x fastReflection_UserMigrationRecord_messageType) New() protoreflect.Message {
	return new(fastReflection_UserMigrationRecord)
}
func (x fastReflection_UserMigrationRecord_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_UserMigrationRecord
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_UserMigrationRecord) Descriptor() protoreflect.MessageDescriptor {
	return md_UserMigrationRecord
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_UserMigrationRecord) Type() protoreflect.MessageType {
	return _fastReflection_UserMigrationRecord_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_UserMigrationRecord) New() protoreflect.Message {
	return new(fastReflection_UserMigrationRecord)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_UserMigrationRecord) Interface() protoreflect.ProtoMessage {
	return (*UserMigrationRecord)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_UserMigrationRecord) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.MigratedAt != nil {
		value := protoreflect.ValueOfMessage(x.MigratedAt.ProtoReflect())
		if !f(fd_UserMigrationRecord_migrated_at, value) {
			return
		}
	}
	if x.FromVaultType != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.FromVaultType))
		if !f(fd_UserMigrationRecord_from_vault_type, value) {
			return
		}
	}
	if x.LegacyPositionCount != int64(0) {
		value := protoreflect.ValueOfInt64(x.LegacyPositionCount)
		if !f(fd_UserMigrationRecord_legacy_position_count, value) {
			return
		}
	}
	if x.PrincipalMigrated != "" {
		value := protoreflect.ValueOfString(x.PrincipalMigrated)
		if !f(fd_UserMigrationRecord_principal_migrated, value) {
			return
		}
	}
	if x.RewardsMigrated != "" {
		value := protoreflect.ValueOfString(x.RewardsMigrated)
		if !f(fd_UserMigrationRecord_rewards_migrated, value) {
			return
		}
	}
	if x.SharesReceived != "" {
		value := protoreflect.ValueOfString(x.SharesReceived)
		if !f(fd_UserMigrationRecord_shares_received, value) {
			return
		}
	}
	if x.MigrationTxHash != "" {
		value := protoreflect.ValueOfString(x.MigrationTxHash)
		if !f(fd_UserMigrationRecord_migration_tx_hash, value) {
			return
		}
	}
	if x.GasUsed != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasUsed)
		if !f(fd_UserMigrationRecord_gas_used, value) {
			return
		}
	}
	if x.YieldForgone != false {
		value := protoreflect.ValueOfBool(x.YieldForgone)
		if !f(fd_UserMigrationRecord_yield_forgone, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_UserMigrationRecord) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.UserMigrationRecord.migrated_at":
		return x.MigratedAt != nil
	case "noble.dollar.vaults.v1.UserMigrationRecord.from_vault_type":
		return x.FromVaultType != 0
	case "noble.dollar.vaults.v1.UserMigrationRecord.legacy_position_count":
		return x.LegacyPositionCount != int64(0)
	case "noble.dollar.vaults.v1.UserMigrationRecord.principal_migrated":
		return x.PrincipalMigrated != ""
	case "noble.dollar.vaults.v1.UserMigrationRecord.rewards_migrated":
		return x.RewardsMigrated != ""
	case "noble.dollar.vaults.v1.UserMigrationRecord.shares_received":
		return x.SharesReceived != ""
	case "noble.dollar.vaults.v1.UserMigrationRecord.migration_tx_hash":
		return x.MigrationTxHash != ""
	case "noble.dollar.vaults.v1.UserMigrationRecord.gas_used":
		return x.GasUsed != uint64(0)
	case "noble.dollar.vaults.v1.UserMigrationRecord.yield_forgone":
		return x.YieldForgone != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.UserMigrationRecord"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.UserMigrationRecord does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserMigrationRecord) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.UserMigrationRecord.migrated_at":
		x.MigratedAt = nil
	case "noble.dollar.vaults.v1.UserMigrationRecord.from_vault_type":
		x.FromVaultType = 0
	case "noble.dollar.vaults.v1.UserMigrationRecord.legacy_position_count":
		x.LegacyPositionCount = int64(0)
	case "noble.dollar.vaults.v1.UserMigrationRecord.principal_migrated":
		x.PrincipalMigrated = ""
	case "noble.dollar.vaults.v1.UserMigrationRecord.rewards_migrated":
		x.RewardsMigrated = ""
	case "noble.dollar.vaults.v1.UserMigrationRecord.shares_received":
		x.SharesReceived = ""
	case "noble.dollar.vaults.v1.UserMigrationRecord.migration_tx_hash":
		x.MigrationTxHash = ""
	case "noble.dollar.vaults.v1.UserMigrationRecord.gas_used":
		x.GasUsed = uint64(0)
	case "noble.dollar.vaults.v1.UserMigrationRecord.yield_forgone":
		x.YieldForgone = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.UserMigrationRecord"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.UserMigrationRecord does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_UserMigrationRecord) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.UserMigrationRecord.migrated_at":
		value := x.MigratedAt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v1.UserMigrationRecord.from_vault_type":
		value := x.FromVaultType
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "noble.dollar.vaults.v1.UserMigrationRecord.legacy_position_count":
		value := x.LegacyPositionCount
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v1.UserMigrationRecord.principal_migrated":
		value := x.PrincipalMigrated
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.UserMigrationRecord.rewards_migrated":
		value := x.RewardsMigrated
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.UserMigrationRecord.shares_received":
		value := x.SharesReceived
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.UserMigrationRecord.migration_tx_hash":
		value := x.MigrationTxHash
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.UserMigrationRecord.gas_used":
		value := x.GasUsed
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v1.UserMigrationRecord.yield_forgone":
		value := x.YieldForgone
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.UserMigrationRecord"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.UserMigrationRecord does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserMigrationRecord) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.UserMigrationRecord.migrated_at":
		x.MigratedAt = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v1.UserMigrationRecord.from_vault_type":
		x.FromVaultType = (VaultType)(value.Enum())
	case "noble.dollar.vaults.v1.UserMigrationRecord.legacy_position_count":
		x.LegacyPositionCount = value.Int()
	case "noble.dollar.vaults.v1.UserMigrationRecord.principal_migrated":
		x.PrincipalMigrated = value.Interface().(string)
	case "noble.dollar.vaults.v1.UserMigrationRecord.rewards_migrated":
		x.RewardsMigrated = value.Interface().(string)
	case "noble.dollar.vaults.v1.UserMigrationRecord.shares_received":
		x.SharesReceived = value.Interface().(string)
	case "noble.dollar.vaults.v1.UserMigrationRecord.migration_tx_hash":
		x.MigrationTxHash = value.Interface().(string)
	case "noble.dollar.vaults.v1.UserMigrationRecord.gas_used":
		x.GasUsed = value.Uint()
	case "noble.dollar.vaults.v1.UserMigrationRecord.yield_forgone":
		x.YieldForgone = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.UserMigrationRecord"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.UserMigrationRecord does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserMigrationRecord) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.UserMigrationRecord.migrated_at":
		if x.MigratedAt == nil {
			x.MigratedAt = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.MigratedAt.ProtoReflect())
	case "noble.dollar.vaults.v1.UserMigrationRecord.from_vault_type":
		panic(fmt.Errorf("field from_vault_type of message noble.dollar.vaults.v1.UserMigrationRecord is not mutable"))
	case "noble.dollar.vaults.v1.UserMigrationRecord.legacy_position_count":
		panic(fmt.Errorf("field legacy_position_count of message noble.dollar.vaults.v1.UserMigrationRecord is not mutable"))
	case "noble.dollar.vaults.v1.UserMigrationRecord.principal_migrated":
		panic(fmt.Errorf("field principal_migrated of message noble.dollar.vaults.v1.UserMigrationRecord is not mutable"))
	case "noble.dollar.vaults.v1.UserMigrationRecord.rewards_migrated":
		panic(fmt.Errorf("field rewards_migrated of message noble.dollar.vaults.v1.UserMigrationRecord is not mutable"))
	case "noble.dollar.vaults.v1.UserMigrationRecord.shares_received":
		panic(fmt.Errorf("field shares_received of message noble.dollar.vaults.v1.UserMigrationRecord is not mutable"))
	case "noble.dollar.vaults.v1.UserMigrationRecord.migration_tx_hash":
		panic(fmt.Errorf("field migration_tx_hash of message noble.dollar.vaults.v1.UserMigrationRecord is not mutable"))
	case "noble.dollar.vaults.v1.UserMigrationRecord.gas_used":
		panic(fmt.Errorf("field gas_used of message noble.dollar.vaults.v1.UserMigrationRecord is not mutable"))
	case "noble.dollar.vaults.v1.UserMigrationRecord.yield_forgone":
		panic(fmt.Errorf("field yield_forgone of message noble.dollar.vaults.v1.UserMigrationRecord is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.UserMigrationRecord"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.UserMigrationRecord does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_UserMigrationRecord) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.UserMigrationRecord.migrated_at":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v1.UserMigrationRecord.from_vault_type":
		return protoreflect.ValueOfEnum(0)
	case "noble.dollar.vaults.v1.UserMigrationRecord.legacy_position_count":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v1.UserMigrationRecord.principal_migrated":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.UserMigrationRecord.rewards_migrated":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.UserMigrationRecord.shares_received":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.UserMigrationRecord.migration_tx_hash":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.UserMigrationRecord.gas_used":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v1.UserMigrationRecord.yield_forgone":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.UserMigrationRecord"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.UserMigrationRecord does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_UserMigrationRecord) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.UserMigrationRecord", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_UserMigrationRecord) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserMigrationRecord) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_UserMigrationRecord) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_UserMigrationRecord) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*UserMigrationRecord)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.MigratedAt != nil {
			l = options.Size(x.MigratedAt)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.FromVaultType != 0 {
			n += 1 + runtime.Sov(uint64(x.FromVaultType))
		}
		if x.LegacyPositionCount != 0 {
			n += 1 + runtime.Sov(uint64(x.LegacyPositionCount))
		}
		l = len(x.PrincipalMigrated)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RewardsMigrated)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SharesReceived)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MigrationTxHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.GasUsed != 0 {
			n += 1 + runtime.Sov(uint64(x.GasUsed))
		}
		if x.YieldForgone {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*UserMigrationRecord)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.YieldForgone {
			i--
			if x.YieldForgone {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x48
		}
		if x.GasUsed != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasUsed))
			i--
			dAtA[i] = 0x40
		}
		if len(x.MigrationTxHash) > 0 {
			i -= len(x.MigrationTxHash)
			copy(dAtA[i:], x.MigrationTxHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MigrationTxHash)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.SharesReceived) > 0 {
			i -= len(x.SharesReceived)
			copy(dAtA[i:], x.SharesReceived)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SharesReceived)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.RewardsMigrated) > 0 {
			i -= len(x.RewardsMigrated)
			copy(dAtA[i:], x.RewardsMigrated)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RewardsMigrated)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.PrincipalMigrated) > 0 {
			i -= len(x.PrincipalMigrated)
			copy(dAtA[i:], x.PrincipalMigrated)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrincipalMigrated)))
			i--
			dAtA[i] = 0x22
		}
		if x.LegacyPositionCount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.LegacyPositionCount))
			i--
			dAtA[i] = 0x18
		}
		if x.FromVaultType != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.FromVaultType))
			i--
			dAtA[i] = 0x10
		}
		if x.MigratedAt != nil {
			encoded, err := options.Marshal(x.MigratedAt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*UserMigrationRecord)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: UserMigrationRecord: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: UserMigrationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MigratedAt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.MigratedAt == nil {
					x.MigratedAt = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MigratedAt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FromVaultType", wireType)
				}
				x.FromVaultType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.FromVaultType |= VaultType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LegacyPositionCount", wireType)
				}
				x.LegacyPositionCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.LegacyPositionCount |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrincipalMigrated", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrincipalMigrated = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RewardsMigrated", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RewardsMigrated = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SharesReceived", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SharesReceived = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MigrationTxHash", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MigrationTxHash = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
				}
				x.GasUsed = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasUsed |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field YieldForgone", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.YieldForgone = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MigrationStats                           protoreflect.MessageDescriptor
	fd_MigrationStats_total_users               protoreflect.FieldDescriptor
	fd_MigrationStats_users_migrated            protoreflect.FieldDescriptor
	fd_MigrationStats_total_value_locked        protoreflect.FieldDescriptor
	fd_MigrationStats_value_migrated            protoreflect.FieldDescriptor
	fd_MigrationStats_total_shares_issued       protoreflect.FieldDescriptor
	fd_MigrationStats_last_migration_time       protoreflect.FieldDescriptor
	fd_MigrationStats_average_gas_per_migration protoreflect.FieldDescriptor
	fd_MigrationStats_completion_percentage     protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_MigrationStats = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("MigrationStats")
	fd_MigrationStats_total_users = md_MigrationStats.Fields().ByName("total_users")
	fd_MigrationStats_users_migrated = md_MigrationStats.Fields().ByName("users_migrated")
	fd_MigrationStats_total_value_locked = md_MigrationStats.Fields().ByName("total_value_locked")
	fd_MigrationStats_value_migrated = md_MigrationStats.Fields().ByName("value_migrated")
	fd_MigrationStats_total_shares_issued = md_MigrationStats.Fields().ByName("total_shares_issued")
	fd_MigrationStats_last_migration_time = md_MigrationStats.Fields().ByName("last_migration_time")
	fd_MigrationStats_average_gas_per_migration = md_MigrationStats.Fields().ByName("average_gas_per_migration")
	fd_MigrationStats_completion_percentage = md_MigrationStats.Fields().ByName("completion_percentage")
}

var _ protoreflect.Message = (*fastReflection_MigrationStats)(nil)

type fastReflection_MigrationStats MigrationStats

func (x *MigrationStats) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MigrationStats)(x)
}

func (x *MigrationStats) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MigrationStats_messageType fastReflection_MigrationStats_messageType
var _ protoreflect.MessageType = fastReflection_MigrationStats_messageType{}

type fastReflection_MigrationStats_messageType struct{}

func (x fastReflection_MigrationStats_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MigrationStats)(nil)
}
func (x fastReflection_MigrationStats_messageType) New() protoreflect.Message {
	return new(fastReflection_MigrationStats)
}
func (x fastReflection_MigrationStats_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MigrationStats
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MigrationStats) Descriptor() protoreflect.MessageDescriptor {
	return md_MigrationStats
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MigrationStats) Type() protoreflect.MessageType {
	return _fastReflection_MigrationStats_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MigrationStats) New() protoreflect.Message {
	return new(fastReflection_MigrationStats)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MigrationStats) Interface() protoreflect.ProtoMessage {
	return (*MigrationStats)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MigrationStats) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TotalUsers != uint64(0) {
		value := protoreflect.ValueOfUint64(x.TotalUsers)
		if !f(fd_MigrationStats_total_users, value) {
			return
		}
	}
	if x.UsersMigrated != uint64(0) {
		value := protoreflect.ValueOfUint64(x.UsersMigrated)
		if !f(fd_MigrationStats_users_migrated, value) {
			return
		}
	}
	if x.TotalValueLocked != "" {
		value := protoreflect.ValueOfString(x.TotalValueLocked)
		if !f(fd_MigrationStats_total_value_locked, value) {
			return
		}
	}
	if x.ValueMigrated != "" {
		value := protoreflect.ValueOfString(x.ValueMigrated)
		if !f(fd_MigrationStats_value_migrated, value) {
			return
		}
	}
	if x.TotalSharesIssued != "" {
		value := protoreflect.ValueOfString(x.TotalSharesIssued)
		if !f(fd_MigrationStats_total_shares_issued, value) {
			return
		}
	}
	if x.LastMigrationTime != nil {
		value := protoreflect.ValueOfMessage(x.LastMigrationTime.ProtoReflect())
		if !f(fd_MigrationStats_last_migration_time, value) {
			return
		}
	}
	if x.AverageGasPerMigration != uint64(0) {
		value := protoreflect.ValueOfUint64(x.AverageGasPerMigration)
		if !f(fd_MigrationStats_average_gas_per_migration, value) {
			return
		}
	}
	if x.CompletionPercentage != int32(0) {
		value := protoreflect.ValueOfInt32(x.CompletionPercentage)
		if !f(fd_MigrationStats_completion_percentage, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MigrationStats) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationStats.total_users":
		return x.TotalUsers != uint64(0)
	case "noble.dollar.vaults.v1.MigrationStats.users_migrated":
		return x.UsersMigrated != uint64(0)
	case "noble.dollar.vaults.v1.MigrationStats.total_value_locked":
		return x.TotalValueLocked != ""
	case "noble.dollar.vaults.v1.MigrationStats.value_migrated":
		return x.ValueMigrated != ""
	case "noble.dollar.vaults.v1.MigrationStats.total_shares_issued":
		return x.TotalSharesIssued != ""
	case "noble.dollar.vaults.v1.MigrationStats.last_migration_time":
		return x.LastMigrationTime != nil
	case "noble.dollar.vaults.v1.MigrationStats.average_gas_per_migration":
		return x.AverageGasPerMigration != uint64(0)
	case "noble.dollar.vaults.v1.MigrationStats.completion_percentage":
		return x.CompletionPercentage != int32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationStats"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationStats does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationStats) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationStats.total_users":
		x.TotalUsers = uint64(0)
	case "noble.dollar.vaults.v1.MigrationStats.users_migrated":
		x.UsersMigrated = uint64(0)
	case "noble.dollar.vaults.v1.MigrationStats.total_value_locked":
		x.TotalValueLocked = ""
	case "noble.dollar.vaults.v1.MigrationStats.value_migrated":
		x.ValueMigrated = ""
	case "noble.dollar.vaults.v1.MigrationStats.total_shares_issued":
		x.TotalSharesIssued = ""
	case "noble.dollar.vaults.v1.MigrationStats.last_migration_time":
		x.LastMigrationTime = nil
	case "noble.dollar.vaults.v1.MigrationStats.average_gas_per_migration":
		x.AverageGasPerMigration = uint64(0)
	case "noble.dollar.vaults.v1.MigrationStats.completion_percentage":
		x.CompletionPercentage = int32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationStats"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationStats does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MigrationStats) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.MigrationStats.total_users":
		value := x.TotalUsers
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v1.MigrationStats.users_migrated":
		value := x.UsersMigrated
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v1.MigrationStats.total_value_locked":
		value := x.TotalValueLocked
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MigrationStats.value_migrated":
		value := x.ValueMigrated
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MigrationStats.total_shares_issued":
		value := x.TotalSharesIssued
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MigrationStats.last_migration_time":
		value := x.LastMigrationTime
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationStats.average_gas_per_migration":
		value := x.AverageGasPerMigration
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v1.MigrationStats.completion_percentage":
		value := x.CompletionPercentage
		return protoreflect.ValueOfInt32(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationStats"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationStats does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationStats) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationStats.total_users":
		x.TotalUsers = value.Uint()
	case "noble.dollar.vaults.v1.MigrationStats.users_migrated":
		x.UsersMigrated = value.Uint()
	case "noble.dollar.vaults.v1.MigrationStats.total_value_locked":
		x.TotalValueLocked = value.Interface().(string)
	case "noble.dollar.vaults.v1.MigrationStats.value_migrated":
		x.ValueMigrated = value.Interface().(string)
	case "noble.dollar.vaults.v1.MigrationStats.total_shares_issued":
		x.TotalSharesIssued = value.Interface().(string)
	case "noble.dollar.vaults.v1.MigrationStats.last_migration_time":
		x.LastMigrationTime = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v1.MigrationStats.average_gas_per_migration":
		x.AverageGasPerMigration = value.Uint()
	case "noble.dollar.vaults.v1.MigrationStats.completion_percentage":
		x.CompletionPercentage = int32(value.Int())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationStats"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationStats does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationStats) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationStats.last_migration_time":
		if x.LastMigrationTime == nil {
			x.LastMigrationTime = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.LastMigrationTime.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationStats.total_users":
		panic(fmt.Errorf("field total_users of message noble.dollar.vaults.v1.MigrationStats is not mutable"))
	case "noble.dollar.vaults.v1.MigrationStats.users_migrated":
		panic(fmt.Errorf("field users_migrated of message noble.dollar.vaults.v1.MigrationStats is not mutable"))
	case "noble.dollar.vaults.v1.MigrationStats.total_value_locked":
		panic(fmt.Errorf("field total_value_locked of message noble.dollar.vaults.v1.MigrationStats is not mutable"))
	case "noble.dollar.vaults.v1.MigrationStats.value_migrated":
		panic(fmt.Errorf("field value_migrated of message noble.dollar.vaults.v1.MigrationStats is not mutable"))
	case "noble.dollar.vaults.v1.MigrationStats.total_shares_issued":
		panic(fmt.Errorf("field total_shares_issued of message noble.dollar.vaults.v1.MigrationStats is not mutable"))
	case "noble.dollar.vaults.v1.MigrationStats.average_gas_per_migration":
		panic(fmt.Errorf("field average_gas_per_migration of message noble.dollar.vaults.v1.MigrationStats is not mutable"))
	case "noble.dollar.vaults.v1.MigrationStats.completion_percentage":
		panic(fmt.Errorf("field completion_percentage of message noble.dollar.vaults.v1.MigrationStats is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationStats"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationStats does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MigrationStats) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationStats.total_users":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v1.MigrationStats.users_migrated":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v1.MigrationStats.total_value_locked":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MigrationStats.value_migrated":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MigrationStats.total_shares_issued":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MigrationStats.last_migration_time":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationStats.average_gas_per_migration":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v1.MigrationStats.completion_percentage":
		return protoreflect.ValueOfInt32(int32(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationStats"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationStats does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MigrationStats) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.MigrationStats", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MigrationStats) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationStats) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MigrationStats) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MigrationStats) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MigrationStats)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.TotalUsers != 0 {
			n += 1 + runtime.Sov(uint64(x.TotalUsers))
		}
		if x.UsersMigrated != 0 {
			n += 1 + runtime.Sov(uint64(x.UsersMigrated))
		}
		l = len(x.TotalValueLocked)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ValueMigrated)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalSharesIssued)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.LastMigrationTime != nil {
			l = options.Size(x.LastMigrationTime)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.AverageGasPerMigration != 0 {
			n += 1 + runtime.Sov(uint64(x.AverageGasPerMigration))
		}
		if x.CompletionPercentage != 0 {
			n += 1 + runtime.Sov(uint64(x.CompletionPercentage))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MigrationStats)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.CompletionPercentage != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CompletionPercentage))
			i--
			dAtA[i] = 0x40
		}
		if x.AverageGasPerMigration != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.AverageGasPerMigration))
			i--
			dAtA[i] = 0x38
		}
		if x.LastMigrationTime != nil {
			encoded, err := options.Marshal(x.LastMigrationTime)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.TotalSharesIssued) > 0 {
			i -= len(x.TotalSharesIssued)
			copy(dAtA[i:], x.TotalSharesIssued)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalSharesIssued)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.ValueMigrated) > 0 {
			i -= len(x.ValueMigrated)
			copy(dAtA[i:], x.ValueMigrated)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ValueMigrated)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.TotalValueLocked) > 0 {
			i -= len(x.TotalValueLocked)
			copy(dAtA[i:], x.TotalValueLocked)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalValueLocked)))
			i--
			dAtA[i] = 0x1a
		}
		if x.UsersMigrated != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.UsersMigrated))
			i--
			dAtA[i] = 0x10
		}
		if x.TotalUsers != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.TotalUsers))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MigrationStats)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MigrationStats: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MigrationStats: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalUsers", wireType)
				}
				x.TotalUsers = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.TotalUsers |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UsersMigrated", wireType)
				}
				x.UsersMigrated = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.UsersMigrated |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalValueLocked", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalValueLocked = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ValueMigrated", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ValueMigrated = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalSharesIssued", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalSharesIssued = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastMigrationTime", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.LastMigrationTime == nil {
					x.LastMigrationTime = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LastMigrationTime); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AverageGasPerMigration", wireType)
				}
				x.AverageGasPerMigration = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.AverageGasPerMigration |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CompletionPercentage", wireType)
				}
				x.CompletionPercentage = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CompletionPercentage |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_LockedLegacyPosition                protoreflect.MessageDescriptor
	fd_LockedLegacyPosition_position       protoreflect.FieldDescriptor
	fd_LockedLegacyPosition_locked_at      protoreflect.FieldDescriptor
	fd_LockedLegacyPosition_migrated_to    protoreflect.FieldDescriptor
	fd_LockedLegacyPosition_migration_id   protoreflect.FieldDescriptor
	fd_LockedLegacyPosition_unlock_enabled protoreflect.FieldDescriptor
	fd_LockedLegacyPosition_lock_reason    protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_LockedLegacyPosition = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("LockedLegacyPosition")
	fd_LockedLegacyPosition_position = md_LockedLegacyPosition.Fields().ByName("position")
	fd_LockedLegacyPosition_locked_at = md_LockedLegacyPosition.Fields().ByName("locked_at")
	fd_LockedLegacyPosition_migrated_to = md_LockedLegacyPosition.Fields().ByName("migrated_to")
	fd_LockedLegacyPosition_migration_id = md_LockedLegacyPosition.Fields().ByName("migration_id")
	fd_LockedLegacyPosition_unlock_enabled = md_LockedLegacyPosition.Fields().ByName("unlock_enabled")
	fd_LockedLegacyPosition_lock_reason = md_LockedLegacyPosition.Fields().ByName("lock_reason")
}

var _ protoreflect.Message = (*fastReflection_LockedLegacyPosition)(nil)

type fastReflection_LockedLegacyPosition LockedLegacyPosition

func (x *LockedLegacyPosition) ProtoReflect() protoreflect.Message {
	return (*fastReflection_LockedLegacyPosition)(x)
}

func (x *LockedLegacyPosition) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_LockedLegacyPosition_messageType fastReflection_LockedLegacyPosition_messageType
var _ protoreflect.MessageType = fastReflection_LockedLegacyPosition_messageType{}

type fastReflection_LockedLegacyPosition_messageType struct{}

func (x fastReflection_LockedLegacyPosition_messageType) Zero() protoreflect.Message {
	return (*fastReflection_LockedLegacyPosition)(nil)
}
func (x fastReflection_LockedLegacyPosition_messageType) New() protoreflect.Message {
	return new(fastReflection_LockedLegacyPosition)
}
func (x fastReflection_LockedLegacyPosition_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_LockedLegacyPosition
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_LockedLegacyPosition) Descriptor() protoreflect.MessageDescriptor {
	return md_LockedLegacyPosition
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_LockedLegacyPosition) Type() protoreflect.MessageType {
	return _fastReflection_LockedLegacyPosition_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_LockedLegacyPosition) New() protoreflect.Message {
	return new(fastReflection_LockedLegacyPosition)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_LockedLegacyPosition) Interface() protoreflect.ProtoMessage {
	return (*LockedLegacyPosition)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_LockedLegacyPosition) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Position != nil {
		value := protoreflect.ValueOfMessage(x.Position.ProtoReflect())
		if !f(fd_LockedLegacyPosition_position, value) {
			return
		}
	}
	if x.LockedAt != nil {
		value := protoreflect.ValueOfMessage(x.LockedAt.ProtoReflect())
		if !f(fd_LockedLegacyPosition_locked_at, value) {
			return
		}
	}
	if len(x.MigratedTo) != 0 {
		value := protoreflect.ValueOfBytes(x.MigratedTo)
		if !f(fd_LockedLegacyPosition_migrated_to, value) {
			return
		}
	}
	if x.MigrationId != "" {
		value := protoreflect.ValueOfString(x.MigrationId)
		if !f(fd_LockedLegacyPosition_migration_id, value) {
			return
		}
	}
	if x.UnlockEnabled != false {
		value := protoreflect.ValueOfBool(x.UnlockEnabled)
		if !f(fd_LockedLegacyPosition_unlock_enabled, value) {
			return
		}
	}
	if x.LockReason != "" {
		value := protoreflect.ValueOfString(x.LockReason)
		if !f(fd_LockedLegacyPosition_lock_reason, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_LockedLegacyPosition) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.LockedLegacyPosition.position":
		return x.Position != nil
	case "noble.dollar.vaults.v1.LockedLegacyPosition.locked_at":
		return x.LockedAt != nil
	case "noble.dollar.vaults.v1.LockedLegacyPosition.migrated_to":
		return len(x.MigratedTo) != 0
	case "noble.dollar.vaults.v1.LockedLegacyPosition.migration_id":
		return x.MigrationId != ""
	case "noble.dollar.vaults.v1.LockedLegacyPosition.unlock_enabled":
		return x.UnlockEnabled != false
	case "noble.dollar.vaults.v1.LockedLegacyPosition.lock_reason":
		return x.LockReason != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.LockedLegacyPosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.LockedLegacyPosition does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LockedLegacyPosition) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.LockedLegacyPosition.position":
		x.Position = nil
	case "noble.dollar.vaults.v1.LockedLegacyPosition.locked_at":
		x.LockedAt = nil
	case "noble.dollar.vaults.v1.LockedLegacyPosition.migrated_to":
		x.MigratedTo = nil
	case "noble.dollar.vaults.v1.LockedLegacyPosition.migration_id":
		x.MigrationId = ""
	case "noble.dollar.vaults.v1.LockedLegacyPosition.unlock_enabled":
		x.UnlockEnabled = false
	case "noble.dollar.vaults.v1.LockedLegacyPosition.lock_reason":
		x.LockReason = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.LockedLegacyPosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.LockedLegacyPosition does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_LockedLegacyPosition) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.LockedLegacyPosition.position":
		value := x.Position
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v1.LockedLegacyPosition.locked_at":
		value := x.LockedAt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v1.LockedLegacyPosition.migrated_to":
		value := x.MigratedTo
		return protoreflect.ValueOfBytes(value)
	case "noble.dollar.vaults.v1.LockedLegacyPosition.migration_id":
		value := x.MigrationId
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.LockedLegacyPosition.unlock_enabled":
		value := x.UnlockEnabled
		return protoreflect.ValueOfBool(value)
	case "noble.dollar.vaults.v1.LockedLegacyPosition.lock_reason":
		value := x.LockReason
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.LockedLegacyPosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.LockedLegacyPosition does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LockedLegacyPosition) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.LockedLegacyPosition.position":
		x.Position = value.Message().Interface().(*Position)
	case "noble.dollar.vaults.v1.LockedLegacyPosition.locked_at":
		x.LockedAt = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v1.LockedLegacyPosition.migrated_to":
		x.MigratedTo = value.Bytes()
	case "noble.dollar.vaults.v1.LockedLegacyPosition.migration_id":
		x.MigrationId = value.Interface().(string)
	case "noble.dollar.vaults.v1.LockedLegacyPosition.unlock_enabled":
		x.UnlockEnabled = value.Bool()
	case "noble.dollar.vaults.v1.LockedLegacyPosition.lock_reason":
		x.LockReason = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.LockedLegacyPosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.LockedLegacyPosition does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LockedLegacyPosition) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.LockedLegacyPosition.position":
		if x.Position == nil {
			x.Position = new(Position)
		}
		return protoreflect.ValueOfMessage(x.Position.ProtoReflect())
	case "noble.dollar.vaults.v1.LockedLegacyPosition.locked_at":
		if x.LockedAt == nil {
			x.LockedAt = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.LockedAt.ProtoReflect())
	case "noble.dollar.vaults.v1.LockedLegacyPosition.migrated_to":
		panic(fmt.Errorf("field migrated_to of message noble.dollar.vaults.v1.LockedLegacyPosition is not mutable"))
	case "noble.dollar.vaults.v1.LockedLegacyPosition.migration_id":
		panic(fmt.Errorf("field migration_id of message noble.dollar.vaults.v1.LockedLegacyPosition is not mutable"))
	case "noble.dollar.vaults.v1.LockedLegacyPosition.unlock_enabled":
		panic(fmt.Errorf("field unlock_enabled of message noble.dollar.vaults.v1.LockedLegacyPosition is not mutable"))
	case "noble.dollar.vaults.v1.LockedLegacyPosition.lock_reason":
		panic(fmt.Errorf("field lock_reason of message noble.dollar.vaults.v1.LockedLegacyPosition is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.LockedLegacyPosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.LockedLegacyPosition does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_LockedLegacyPosition) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.LockedLegacyPosition.position":
		m := new(Position)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v1.LockedLegacyPosition.locked_at":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v1.LockedLegacyPosition.migrated_to":
		return protoreflect.ValueOfBytes(nil)
	case "noble.dollar.vaults.v1.LockedLegacyPosition.migration_id":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.LockedLegacyPosition.unlock_enabled":
		return protoreflect.ValueOfBool(false)
	case "noble.dollar.vaults.v1.LockedLegacyPosition.lock_reason":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.LockedLegacyPosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.LockedLegacyPosition does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_LockedLegacyPosition) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.LockedLegacyPosition", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_LockedLegacyPosition) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LockedLegacyPosition) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_LockedLegacyPosition) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_LockedLegacyPosition) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*LockedLegacyPosition)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Position != nil {
			l = options.Size(x.Position)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.LockedAt != nil {
			l = options.Size(x.LockedAt)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MigratedTo)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MigrationId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.UnlockEnabled {
			n += 2
		}
		l = len(x.LockReason)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*LockedLegacyPosition)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.LockReason) > 0 {
			i -= len(x.LockReason)
			copy(dAtA[i:], x.LockReason)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LockReason)))
			i--
			dAtA[i] = 0x32
		}
		if x.UnlockEnabled {
			i--
			if x.UnlockEnabled {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
		if len(x.MigrationId) > 0 {
			i -= len(x.MigrationId)
			copy(dAtA[i:], x.MigrationId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MigrationId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.MigratedTo) > 0 {
			i -= len(x.MigratedTo)
			copy(dAtA[i:], x.MigratedTo)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MigratedTo)))
			i--
			dAtA[i] = 0x1a
		}
		if x.LockedAt != nil {
			encoded, err := options.Marshal(x.LockedAt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if x.Position != nil {
			encoded, err := options.Marshal(x.Position)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*LockedLegacyPosition)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LockedLegacyPosition: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LockedLegacyPosition: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Position == nil {
					x.Position = &Position{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Position); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LockedAt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.LockedAt == nil {
					x.LockedAt = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LockedAt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MigratedTo", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MigratedTo = append(x.MigratedTo[:0], dAtA[iNdEx:postIndex]...)
				if x.MigratedTo == nil {
					x.MigratedTo = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MigrationId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MigrationId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UnlockEnabled", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UnlockEnabled = bool(v != 0)
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LockReason", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LockReason = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MigrationPreview                  protoreflect.MessageDescriptor
	fd_MigrationPreview_total_value      protoreflect.FieldDescriptor
	fd_MigrationPreview_principal_amount protoreflect.FieldDescriptor
	fd_MigrationPreview_accrued_rewards  protoreflect.FieldDescriptor
	fd_MigrationPreview_estimated_shares protoreflect.FieldDescriptor
	fd_MigrationPreview_current_nav      protoreflect.FieldDescriptor
	fd_MigrationPreview_position_count   protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_MigrationPreview = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("MigrationPreview")
	fd_MigrationPreview_total_value = md_MigrationPreview.Fields().ByName("total_value")
	fd_MigrationPreview_principal_amount = md_MigrationPreview.Fields().ByName("principal_amount")
	fd_MigrationPreview_accrued_rewards = md_MigrationPreview.Fields().ByName("accrued_rewards")
	fd_MigrationPreview_estimated_shares = md_MigrationPreview.Fields().ByName("estimated_shares")
	fd_MigrationPreview_current_nav = md_MigrationPreview.Fields().ByName("current_nav")
	fd_MigrationPreview_position_count = md_MigrationPreview.Fields().ByName("position_count")
}

var _ protoreflect.Message = (*fastReflection_MigrationPreview)(nil)

type fastReflection_MigrationPreview MigrationPreview

func (x *MigrationPreview) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MigrationPreview)(x)
}

func (x *MigrationPreview) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MigrationPreview_messageType fastReflection_MigrationPreview_messageType
var _ protoreflect.MessageType = fastReflection_MigrationPreview_messageType{}

type fastReflection_MigrationPreview_messageType struct{}

func (x fastReflection_MigrationPreview_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MigrationPreview)(nil)
}
func (x fastReflection_MigrationPreview_messageType) New() protoreflect.Message {
	return new(fastReflection_MigrationPreview)
}
func (x fastReflection_MigrationPreview_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MigrationPreview
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MigrationPreview) Descriptor() protoreflect.MessageDescriptor {
	return md_MigrationPreview
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MigrationPreview) Type() protoreflect.MessageType {
	return _fastReflection_MigrationPreview_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MigrationPreview) New() protoreflect.Message {
	return new(fastReflection_MigrationPreview)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MigrationPreview) Interface() protoreflect.ProtoMessage {
	return (*MigrationPreview)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MigrationPreview) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TotalValue != "" {
		value := protoreflect.ValueOfString(x.TotalValue)
		if !f(fd_MigrationPreview_total_value, value) {
			return
		}
	}
	if x.PrincipalAmount != "" {
		value := protoreflect.ValueOfString(x.PrincipalAmount)
		if !f(fd_MigrationPreview_principal_amount, value) {
			return
		}
	}
	if x.AccruedRewards != "" {
		value := protoreflect.ValueOfString(x.AccruedRewards)
		if !f(fd_MigrationPreview_accrued_rewards, value) {
			return
		}
	}
	if x.EstimatedShares != "" {
		value := protoreflect.ValueOfString(x.EstimatedShares)
		if !f(fd_MigrationPreview_estimated_shares, value) {
			return
		}
	}
	if x.CurrentNav != "" {
		value := protoreflect.ValueOfString(x.CurrentNav)
		if !f(fd_MigrationPreview_current_nav, value) {
			return
		}
	}
	if x.PositionCount != int64(0) {
		value := protoreflect.ValueOfInt64(x.PositionCount)
		if !f(fd_MigrationPreview_position_count, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MigrationPreview) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationPreview.total_value":
		return x.TotalValue != ""
	case "noble.dollar.vaults.v1.MigrationPreview.principal_amount":
		return x.PrincipalAmount != ""
	case "noble.dollar.vaults.v1.MigrationPreview.accrued_rewards":
		return x.AccruedRewards != ""
	case "noble.dollar.vaults.v1.MigrationPreview.estimated_shares":
		return x.EstimatedShares != ""
	case "noble.dollar.vaults.v1.MigrationPreview.current_nav":
		return x.CurrentNav != ""
	case "noble.dollar.vaults.v1.MigrationPreview.position_count":
		return x.PositionCount != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationPreview"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationPreview does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationPreview) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationPreview.total_value":
		x.TotalValue = ""
	case "noble.dollar.vaults.v1.MigrationPreview.principal_amount":
		x.PrincipalAmount = ""
	case "noble.dollar.vaults.v1.MigrationPreview.accrued_rewards":
		x.AccruedRewards = ""
	case "noble.dollar.vaults.v1.MigrationPreview.estimated_shares":
		x.EstimatedShares = ""
	case "noble.dollar.vaults.v1.MigrationPreview.current_nav":
		x.CurrentNav = ""
	case "noble.dollar.vaults.v1.MigrationPreview.position_count":
		x.PositionCount = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationPreview"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationPreview does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MigrationPreview) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.MigrationPreview.total_value":
		value := x.TotalValue
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MigrationPreview.principal_amount":
		value := x.PrincipalAmount
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MigrationPreview.accrued_rewards":
		value := x.AccruedRewards
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MigrationPreview.estimated_shares":
		value := x.EstimatedShares
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MigrationPreview.current_nav":
		value := x.CurrentNav
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MigrationPreview.position_count":
		value := x.PositionCount
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationPreview"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationPreview does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationPreview) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationPreview.total_value":
		x.TotalValue = value.Interface().(string)
	case "noble.dollar.vaults.v1.MigrationPreview.principal_amount":
		x.PrincipalAmount = value.Interface().(string)
	case "noble.dollar.vaults.v1.MigrationPreview.accrued_rewards":
		x.AccruedRewards = value.Interface().(string)
	case "noble.dollar.vaults.v1.MigrationPreview.estimated_shares":
		x.EstimatedShares = value.Interface().(string)
	case "noble.dollar.vaults.v1.MigrationPreview.current_nav":
		x.CurrentNav = value.Interface().(string)
	case "noble.dollar.vaults.v1.MigrationPreview.position_count":
		x.PositionCount = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationPreview"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationPreview does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationPreview) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationPreview.total_value":
		panic(fmt.Errorf("field total_value of message noble.dollar.vaults.v1.MigrationPreview is not mutable"))
	case "noble.dollar.vaults.v1.MigrationPreview.principal_amount":
		panic(fmt.Errorf("field principal_amount of message noble.dollar.vaults.v1.MigrationPreview is not mutable"))
	case "noble.dollar.vaults.v1.MigrationPreview.accrued_rewards":
		panic(fmt.Errorf("field accrued_rewards of message noble.dollar.vaults.v1.MigrationPreview is not mutable"))
	case "noble.dollar.vaults.v1.MigrationPreview.estimated_shares":
		panic(fmt.Errorf("field estimated_shares of message noble.dollar.vaults.v1.MigrationPreview is not mutable"))
	case "noble.dollar.vaults.v1.MigrationPreview.current_nav":
		panic(fmt.Errorf("field current_nav of message noble.dollar.vaults.v1.MigrationPreview is not mutable"))
	case "noble.dollar.vaults.v1.MigrationPreview.position_count":
		panic(fmt.Errorf("field position_count of message noble.dollar.vaults.v1.MigrationPreview is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationPreview"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationPreview does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MigrationPreview) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationPreview.total_value":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MigrationPreview.principal_amount":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MigrationPreview.accrued_rewards":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MigrationPreview.estimated_shares":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MigrationPreview.current_nav":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MigrationPreview.position_count":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationPreview"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationPreview does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MigrationPreview) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.MigrationPreview", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MigrationPreview) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationPreview) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MigrationPreview) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MigrationPreview) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MigrationPreview)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.TotalValue)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PrincipalAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AccruedRewards)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.EstimatedShares)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CurrentNav)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.PositionCount != 0 {
			n += 1 + runtime.Sov(uint64(x.PositionCount))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MigrationPreview)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.PositionCount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PositionCount))
			i--
			dAtA[i] = 0x30
		}
		if len(x.CurrentNav) > 0 {
			i -= len(x.CurrentNav)
			copy(dAtA[i:], x.CurrentNav)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CurrentNav)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.EstimatedShares) > 0 {
			i -= len(x.EstimatedShares)
			copy(dAtA[i:], x.EstimatedShares)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.EstimatedShares)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.AccruedRewards) > 0 {
			i -= len(x.AccruedRewards)
			copy(dAtA[i:], x.AccruedRewards)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AccruedRewards)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PrincipalAmount) > 0 {
			i -= len(x.PrincipalAmount)
			copy(dAtA[i:], x.PrincipalAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrincipalAmount)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.TotalValue) > 0 {
			i -= len(x.TotalValue)
			copy(dAtA[i:], x.TotalValue)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalValue)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MigrationPreview)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MigrationPreview: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MigrationPreview: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalValue = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrincipalAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrincipalAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AccruedRewards", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AccruedRewards = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EstimatedShares", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.EstimatedShares = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CurrentNav", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CurrentNav = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PositionCount", wireType)
				}
				x.PositionCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PositionCount |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MigrationBlockReason                protoreflect.MessageDescriptor
	fd_MigrationBlockReason_reason_code    protoreflect.FieldDescriptor
	fd_MigrationBlockReason_reason_message protoreflect.FieldDescriptor
	fd_MigrationBlockReason_temporary      protoreflect.FieldDescriptor
	fd_MigrationBlockReason_expires_at     protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_MigrationBlockReason = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("MigrationBlockReason")
	fd_MigrationBlockReason_reason_code = md_MigrationBlockReason.Fields().ByName("reason_code")
	fd_MigrationBlockReason_reason_message = md_MigrationBlockReason.Fields().ByName("reason_message")
	fd_MigrationBlockReason_temporary = md_MigrationBlockReason.Fields().ByName("temporary")
	fd_MigrationBlockReason_expires_at = md_MigrationBlockReason.Fields().ByName("expires_at")
}

var _ protoreflect.Message = (*fastReflection_MigrationBlockReason)(nil)

type fastReflection_MigrationBlockReason MigrationBlockReason

func (x *MigrationBlockReason) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MigrationBlockReason)(x)
}

func (x *MigrationBlockReason) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MigrationBlockReason_messageType fastReflection_MigrationBlockReason_messageType
var _ protoreflect.MessageType = fastReflection_MigrationBlockReason_messageType{}

type fastReflection_MigrationBlockReason_messageType struct{}

func (x fastReflection_MigrationBlockReason_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MigrationBlockReason)(nil)
}
func (x fastReflection_MigrationBlockReason_messageType) New() protoreflect.Message {
	return new(fastReflection_MigrationBlockReason)
}
func (x fastReflection_MigrationBlockReason_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MigrationBlockReason
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MigrationBlockReason) Descriptor() protoreflect.MessageDescriptor {
	return md_MigrationBlockReason
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MigrationBlockReason) Type() protoreflect.MessageType {
	return _fastReflection_MigrationBlockReason_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MigrationBlockReason) New() protoreflect.Message {
	return new(fastReflection_MigrationBlockReason)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MigrationBlockReason) Interface() protoreflect.ProtoMessage {
	return (*MigrationBlockReason)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MigrationBlockReason) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.ReasonCode != "" {
		value := protoreflect.ValueOfString(x.ReasonCode)
		if !f(fd_MigrationBlockReason_reason_code, value) {
			return
		}
	}
	if x.ReasonMessage != "" {
		value := protoreflect.ValueOfString(x.ReasonMessage)
		if !f(fd_MigrationBlockReason_reason_message, value) {
			return
		}
	}
	if x.Temporary != false {
		value := protoreflect.ValueOfBool(x.Temporary)
		if !f(fd_MigrationBlockReason_temporary, value) {
			return
		}
	}
	if x.ExpiresAt != nil {
		value := protoreflect.ValueOfMessage(x.ExpiresAt.ProtoReflect())
		if !f(fd_MigrationBlockReason_expires_at, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MigrationBlockReason) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationBlockReason.reason_code":
		return x.ReasonCode != ""
	case "noble.dollar.vaults.v1.MigrationBlockReason.reason_message":
		return x.ReasonMessage != ""
	case "noble.dollar.vaults.v1.MigrationBlockReason.temporary":
		return x.Temporary != false
	case "noble.dollar.vaults.v1.MigrationBlockReason.expires_at":
		return x.ExpiresAt != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationBlockReason"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationBlockReason does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationBlockReason) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationBlockReason.reason_code":
		x.ReasonCode = ""
	case "noble.dollar.vaults.v1.MigrationBlockReason.reason_message":
		x.ReasonMessage = ""
	case "noble.dollar.vaults.v1.MigrationBlockReason.temporary":
		x.Temporary = false
	case "noble.dollar.vaults.v1.MigrationBlockReason.expires_at":
		x.ExpiresAt = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationBlockReason"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationBlockReason does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MigrationBlockReason) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.MigrationBlockReason.reason_code":
		value := x.ReasonCode
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MigrationBlockReason.reason_message":
		value := x.ReasonMessage
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.MigrationBlockReason.temporary":
		value := x.Temporary
		return protoreflect.ValueOfBool(value)
	case "noble.dollar.vaults.v1.MigrationBlockReason.expires_at":
		value := x.ExpiresAt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationBlockReason"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationBlockReason does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationBlockReason) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationBlockReason.reason_code":
		x.ReasonCode = value.Interface().(string)
	case "noble.dollar.vaults.v1.MigrationBlockReason.reason_message":
		x.ReasonMessage = value.Interface().(string)
	case "noble.dollar.vaults.v1.MigrationBlockReason.temporary":
		x.Temporary = value.Bool()
	case "noble.dollar.vaults.v1.MigrationBlockReason.expires_at":
		x.ExpiresAt = value.Message().Interface().(*timestamppb.Timestamp)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationBlockReason"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationBlockReason does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationBlockReason) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationBlockReason.expires_at":
		if x.ExpiresAt == nil {
			x.ExpiresAt = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.ExpiresAt.ProtoReflect())
	case "noble.dollar.vaults.v1.MigrationBlockReason.reason_code":
		panic(fmt.Errorf("field reason_code of message noble.dollar.vaults.v1.MigrationBlockReason is not mutable"))
	case "noble.dollar.vaults.v1.MigrationBlockReason.reason_message":
		panic(fmt.Errorf("field reason_message of message noble.dollar.vaults.v1.MigrationBlockReason is not mutable"))
	case "noble.dollar.vaults.v1.MigrationBlockReason.temporary":
		panic(fmt.Errorf("field temporary of message noble.dollar.vaults.v1.MigrationBlockReason is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationBlockReason"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationBlockReason does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MigrationBlockReason) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.MigrationBlockReason.reason_code":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MigrationBlockReason.reason_message":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.MigrationBlockReason.temporary":
		return protoreflect.ValueOfBool(false)
	case "noble.dollar.vaults.v1.MigrationBlockReason.expires_at":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.MigrationBlockReason"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.MigrationBlockReason does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MigrationBlockReason) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.MigrationBlockReason", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MigrationBlockReason) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MigrationBlockReason) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MigrationBlockReason) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MigrationBlockReason) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MigrationBlockReason)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.ReasonCode)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReasonMessage)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Temporary {
			n += 2
		}
		if x.ExpiresAt != nil {
			l = options.Size(x.ExpiresAt)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MigrationBlockReason)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ExpiresAt != nil {
			encoded, err := options.Marshal(x.ExpiresAt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if x.Temporary {
			i--
			if x.Temporary {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x18
		}
		if len(x.ReasonMessage) > 0 {
			i -= len(x.ReasonMessage)
			copy(dAtA[i:], x.ReasonMessage)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReasonMessage)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.ReasonCode) > 0 {
			i -= len(x.ReasonCode)
			copy(dAtA[i:], x.ReasonCode)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReasonCode)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MigrationBlockReason)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MigrationBlockReason: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MigrationBlockReason: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReasonCode", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReasonCode = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReasonMessage", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReasonMessage = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Temporary", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Temporary = bool(v != 0)
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ExpiresAt == nil {
					x.ExpiresAt = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ExpiresAt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_QueryMigrationStatusRequest protoreflect.MessageDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_QueryMigrationStatusRequest = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("QueryMigrationStatusRequest")
}

var _ protoreflect.Message = (*fastReflection_QueryMigrationStatusRequest)(nil)

type fastReflection_QueryMigrationStatusRequest QueryMigrationStatusRequest

func (x *QueryMigrationStatusRequest) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QueryMigrationStatusRequest)(x)
}

func (x *QueryMigrationStatusRequest) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QueryMigrationStatusRequest_messageType fastReflection_QueryMigrationStatusRequest_messageType
var _ protoreflect.MessageType = fastReflection_QueryMigrationStatusRequest_messageType{}

type fastReflection_QueryMigrationStatusRequest_messageType struct{}

func (x fastReflection_QueryMigrationStatusRequest_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QueryMigrationStatusRequest)(nil)
}
func (x fastReflection_QueryMigrationStatusRequest_messageType) New() protoreflect.Message {
	return new(fastReflection_QueryMigrationStatusRequest)
}
func (x fastReflection_QueryMigrationStatusRequest_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryMigrationStatusRequest
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QueryMigrationStatusRequest) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryMigrationStatusRequest
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QueryMigrationStatusRequest) Type() protoreflect.MessageType {
	return _fastReflection_QueryMigrationStatusRequest_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QueryMigrationStatusRequest) New() protoreflect.Message {
	return new(fastReflection_QueryMigrationStatusRequest)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QueryMigrationStatusRequest) Interface() protoreflect.ProtoMessage {
	return (*QueryMigrationStatusRequest)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QueryMigrationStatusRequest) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QueryMigrationStatusRequest) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationStatusRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationStatusRequest does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationStatusRequest) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationStatusRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationStatusRequest does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QueryMigrationStatusRequest) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationStatusRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationStatusRequest does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationStatusRequest) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationStatusRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationStatusRequest does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationStatusRequest) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationStatusRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationStatusRequest does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QueryMigrationStatusRequest) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationStatusRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationStatusRequest does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QueryMigrationStatusRequest) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.QueryMigrationStatusRequest", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QueryMigrationStatusRequest) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationStatusRequest) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QueryMigrationStatusRequest) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QueryMigrationStatusRequest) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QueryMigrationStatusRequest)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QueryMigrationStatusRequest)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QueryMigrationStatusRequest)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryMigrationStatusRequest: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryMigrationStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_QueryMigrationStatusResponse                 protoreflect.MessageDescriptor
	fd_QueryMigrationStatusResponse_state           protoreflect.FieldDescriptor
	fd_QueryMigrationStatusResponse_total_migrated  protoreflect.FieldDescriptor
	fd_QueryMigrationStatusResponse_total_remaining protoreflect.FieldDescriptor
	fd_QueryMigrationStatusResponse_users_migrated  protoreflect.FieldDescriptor
	fd_QueryMigrationStatusResponse_users_remaining protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_QueryMigrationStatusResponse = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("QueryMigrationStatusResponse")
	fd_QueryMigrationStatusResponse_state = md_QueryMigrationStatusResponse.Fields().ByName("state")
	fd_QueryMigrationStatusResponse_total_migrated = md_QueryMigrationStatusResponse.Fields().ByName("total_migrated")
	fd_QueryMigrationStatusResponse_total_remaining = md_QueryMigrationStatusResponse.Fields().ByName("total_remaining")
	fd_QueryMigrationStatusResponse_users_migrated = md_QueryMigrationStatusResponse.Fields().ByName("users_migrated")
	fd_QueryMigrationStatusResponse_users_remaining = md_QueryMigrationStatusResponse.Fields().ByName("users_remaining")
}

var _ protoreflect.Message = (*fastReflection_QueryMigrationStatusResponse)(nil)

type fastReflection_QueryMigrationStatusResponse QueryMigrationStatusResponse

func (x *QueryMigrationStatusResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QueryMigrationStatusResponse)(x)
}

func (x *QueryMigrationStatusResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QueryMigrationStatusResponse_messageType fastReflection_QueryMigrationStatusResponse_messageType
var _ protoreflect.MessageType = fastReflection_QueryMigrationStatusResponse_messageType{}

type fastReflection_QueryMigrationStatusResponse_messageType struct{}

func (x fastReflection_QueryMigrationStatusResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QueryMigrationStatusResponse)(nil)
}
func (x fastReflection_QueryMigrationStatusResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_QueryMigrationStatusResponse)
}
func (x fastReflection_QueryMigrationStatusResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryMigrationStatusResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QueryMigrationStatusResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryMigrationStatusResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QueryMigrationStatusResponse) Type() protoreflect.MessageType {
	return _fastReflection_QueryMigrationStatusResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QueryMigrationStatusResponse) New() protoreflect.Message {
	return new(fastReflection_QueryMigrationStatusResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QueryMigrationStatusResponse) Interface() protoreflect.ProtoMessage {
	return (*QueryMigrationStatusResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QueryMigrationStatusResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.State != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.State))
		if !f(fd_QueryMigrationStatusResponse_state, value) {
			return
		}
	}
	if x.TotalMigrated != "" {
		value := protoreflect.ValueOfString(x.TotalMigrated)
		if !f(fd_QueryMigrationStatusResponse_total_migrated, value) {
			return
		}
	}
	if x.TotalRemaining != "" {
		value := protoreflect.ValueOfString(x.TotalRemaining)
		if !f(fd_QueryMigrationStatusResponse_total_remaining, value) {
			return
		}
	}
	if x.UsersMigrated != int64(0) {
		value := protoreflect.ValueOfInt64(x.UsersMigrated)
		if !f(fd_QueryMigrationStatusResponse_users_migrated, value) {
			return
		}
	}
	if x.UsersRemaining != int64(0) {
		value := protoreflect.ValueOfInt64(x.UsersRemaining)
		if !f(fd_QueryMigrationStatusResponse_users_remaining, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QueryMigrationStatusResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.state":
		return x.State != 0
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.total_migrated":
		return x.TotalMigrated != ""
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.total_remaining":
		return x.TotalRemaining != ""
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.users_migrated":
		return x.UsersMigrated != int64(0)
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.users_remaining":
		return x.UsersRemaining != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationStatusResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationStatusResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationStatusResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.state":
		x.State = 0
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.total_migrated":
		x.TotalMigrated = ""
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.total_remaining":
		x.TotalRemaining = ""
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.users_migrated":
		x.UsersMigrated = int64(0)
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.users_remaining":
		x.UsersRemaining = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationStatusResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationStatusResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QueryMigrationStatusResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.state":
		value := x.State
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.total_migrated":
		value := x.TotalMigrated
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.total_remaining":
		value := x.TotalRemaining
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.users_migrated":
		value := x.UsersMigrated
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.users_remaining":
		value := x.UsersRemaining
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationStatusResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationStatusResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationStatusResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.state":
		x.State = (MigrationState)(value.Enum())
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.total_migrated":
		x.TotalMigrated = value.Interface().(string)
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.total_remaining":
		x.TotalRemaining = value.Interface().(string)
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.users_migrated":
		x.UsersMigrated = value.Int()
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.users_remaining":
		x.UsersRemaining = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationStatusResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationStatusResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationStatusResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.state":
		panic(fmt.Errorf("field state of message noble.dollar.vaults.v1.QueryMigrationStatusResponse is not mutable"))
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.total_migrated":
		panic(fmt.Errorf("field total_migrated of message noble.dollar.vaults.v1.QueryMigrationStatusResponse is not mutable"))
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.total_remaining":
		panic(fmt.Errorf("field total_remaining of message noble.dollar.vaults.v1.QueryMigrationStatusResponse is not mutable"))
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.users_migrated":
		panic(fmt.Errorf("field users_migrated of message noble.dollar.vaults.v1.QueryMigrationStatusResponse is not mutable"))
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.users_remaining":
		panic(fmt.Errorf("field users_remaining of message noble.dollar.vaults.v1.QueryMigrationStatusResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationStatusResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationStatusResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QueryMigrationStatusResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.state":
		return protoreflect.ValueOfEnum(0)
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.total_migrated":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.total_remaining":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.users_migrated":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v1.QueryMigrationStatusResponse.users_remaining":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationStatusResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationStatusResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QueryMigrationStatusResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.QueryMigrationStatusResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QueryMigrationStatusResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationStatusResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QueryMigrationStatusResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QueryMigrationStatusResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QueryMigrationStatusResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.State != 0 {
			n += 1 + runtime.Sov(uint64(x.State))
		}
		l = len(x.TotalMigrated)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalRemaining)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.UsersMigrated != 0 {
			n += 1 + runtime.Sov(uint64(x.UsersMigrated))
		}
		if x.UsersRemaining != 0 {
			n += 1 + runtime.Sov(uint64(x.UsersRemaining))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QueryMigrationStatusResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.UsersRemaining != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.UsersRemaining))
			i--
			dAtA[i] = 0x28
		}
		if x.UsersMigrated != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.UsersMigrated))
			i--
			dAtA[i] = 0x20
		}
		if len(x.TotalRemaining) > 0 {
			i -= len(x.TotalRemaining)
			copy(dAtA[i:], x.TotalRemaining)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalRemaining)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.TotalMigrated) > 0 {
			i -= len(x.TotalMigrated)
			copy(dAtA[i:], x.TotalMigrated)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalMigrated)))
			i--
			dAtA[i] = 0x12
		}
		if x.State != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.State))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QueryMigrationStatusResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryMigrationStatusResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryMigrationStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
				}
				x.State = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.State |= MigrationState(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalMigrated", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalMigrated = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalRemaining", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalRemaining = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UsersMigrated", wireType)
				}
				x.UsersMigrated = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.UsersMigrated |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UsersRemaining", wireType)
				}
				x.UsersRemaining = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.UsersRemaining |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_QueryUserMigrationStatusRequest            protoreflect.MessageDescriptor
	fd_QueryUserMigrationStatusRequest_address    protoreflect.FieldDescriptor
	fd_QueryUserMigrationStatusRequest_vault_type protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_QueryUserMigrationStatusRequest = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("QueryUserMigrationStatusRequest")
	fd_QueryUserMigrationStatusRequest_address = md_QueryUserMigrationStatusRequest.Fields().ByName("address")
	fd_QueryUserMigrationStatusRequest_vault_type = md_QueryUserMigrationStatusRequest.Fields().ByName("vault_type")
}

var _ protoreflect.Message = (*fastReflection_QueryUserMigrationStatusRequest)(nil)

type fastReflection_QueryUserMigrationStatusRequest QueryUserMigrationStatusRequest

func (x *QueryUserMigrationStatusRequest) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QueryUserMigrationStatusRequest)(x)
}

func (x *QueryUserMigrationStatusRequest) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QueryUserMigrationStatusRequest_messageType fastReflection_QueryUserMigrationStatusRequest_messageType
var _ protoreflect.MessageType = fastReflection_QueryUserMigrationStatusRequest_messageType{}

type fastReflection_QueryUserMigrationStatusRequest_messageType struct{}

func (x fastReflection_QueryUserMigrationStatusRequest_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QueryUserMigrationStatusRequest)(nil)
}
func (x fastReflection_QueryUserMigrationStatusRequest_messageType) New() protoreflect.Message {
	return new(fastReflection_QueryUserMigrationStatusRequest)
}
func (x fastReflection_QueryUserMigrationStatusRequest_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryUserMigrationStatusRequest
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QueryUserMigrationStatusRequest) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryUserMigrationStatusRequest
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QueryUserMigrationStatusRequest) Type() protoreflect.MessageType {
	return _fastReflection_QueryUserMigrationStatusRequest_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QueryUserMigrationStatusRequest) New() protoreflect.Message {
	return new(fastReflection_QueryUserMigrationStatusRequest)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QueryUserMigrationStatusRequest) Interface() protoreflect.ProtoMessage {
	return (*QueryUserMigrationStatusRequest)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QueryUserMigrationStatusRequest) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Address != "" {
		value := protoreflect.ValueOfString(x.Address)
		if !f(fd_QueryUserMigrationStatusRequest_address, value) {
			return
		}
	}
	if x.VaultType != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.VaultType))
		if !f(fd_QueryUserMigrationStatusRequest_vault_type, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QueryUserMigrationStatusRequest) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.address":
		return x.Address != ""
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.vault_type":
		return x.VaultType != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryUserMigrationStatusRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryUserMigrationStatusRequest does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryUserMigrationStatusRequest) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.address":
		x.Address = ""
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.vault_type":
		x.VaultType = 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryUserMigrationStatusRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryUserMigrationStatusRequest does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QueryUserMigrationStatusRequest) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.address":
		value := x.Address
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.vault_type":
		value := x.VaultType
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryUserMigrationStatusRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryUserMigrationStatusRequest does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryUserMigrationStatusRequest) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.address":
		x.Address = value.Interface().(string)
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.vault_type":
		x.VaultType = (VaultType)(value.Enum())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryUserMigrationStatusRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryUserMigrationStatusRequest does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryUserMigrationStatusRequest) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.address":
		panic(fmt.Errorf("field address of message noble.dollar.vaults.v1.QueryUserMigrationStatusRequest is not mutable"))
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.vault_type":
		panic(fmt.Errorf("field vault_type of message noble.dollar.vaults.v1.QueryUserMigrationStatusRequest is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryUserMigrationStatusRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryUserMigrationStatusRequest does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QueryUserMigrationStatusRequest) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.address":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.vault_type":
		return protoreflect.ValueOfEnum(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryUserMigrationStatusRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryUserMigrationStatusRequest does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QueryUserMigrationStatusRequest) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.QueryUserMigrationStatusRequest", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QueryUserMigrationStatusRequest) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryUserMigrationStatusRequest) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QueryUserMigrationStatusRequest) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QueryUserMigrationStatusRequest) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QueryUserMigrationStatusRequest)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.VaultType != 0 {
			n += 1 + runtime.Sov(uint64(x.VaultType))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QueryUserMigrationStatusRequest)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.VaultType != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.VaultType))
			i--
			dAtA[i] = 0x10
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QueryUserMigrationStatusRequest)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryUserMigrationStatusRequest: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryUserMigrationStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
				}
				x.VaultType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.VaultType |= VaultType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_QueryUserMigrationStatusResponse_2_list)(nil)

type _QueryUserMigrationStatusResponse_2_list struct {
	list *[]*Position
}

func (x *_QueryUserMigrationStatusResponse_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_QueryUserMigrationStatusResponse_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_QueryUserMigrationStatusResponse_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Position)
	(*x.list)[i] = concreteValue
}

func (x *_QueryUserMigrationStatusResponse_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Position)
	*x.list = append(*x.list, concreteValue)
}

func (x *_QueryUserMigrationStatusResponse_2_list) AppendMutable() protoreflect.Value {
	v := new(Position)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_QueryUserMigrationStatusResponse_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_QueryUserMigrationStatusResponse_2_list) NewElement() protoreflect.Value {
	v := new(Position)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_QueryUserMigrationStatusResponse_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_QueryUserMigrationStatusResponse                  protoreflect.MessageDescriptor
	fd_QueryUserMigrationStatusResponse_has_migrated     protoreflect.FieldDescriptor
	fd_QueryUserMigrationStatusResponse_legacy_positions protoreflect.FieldDescriptor
	fd_QueryUserMigrationStatusResponse_migration_record protoreflect.FieldDescriptor
	fd_QueryUserMigrationStatusResponse_estimated_shares protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_QueryUserMigrationStatusResponse = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("QueryUserMigrationStatusResponse")
	fd_QueryUserMigrationStatusResponse_has_migrated = md_QueryUserMigrationStatusResponse.Fields().ByName("has_migrated")
	fd_QueryUserMigrationStatusResponse_legacy_positions = md_QueryUserMigrationStatusResponse.Fields().ByName("legacy_positions")
	fd_QueryUserMigrationStatusResponse_migration_record = md_QueryUserMigrationStatusResponse.Fields().ByName("migration_record")
	fd_QueryUserMigrationStatusResponse_estimated_shares = md_QueryUserMigrationStatusResponse.Fields().ByName("estimated_shares")
}

var _ protoreflect.Message = (*fastReflection_QueryUserMigrationStatusResponse)(nil)

type fastReflection_QueryUserMigrationStatusResponse QueryUserMigrationStatusResponse

func (x *QueryUserMigrationStatusResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QueryUserMigrationStatusResponse)(x)
}

func (x *QueryUserMigrationStatusResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QueryUserMigrationStatusResponse_messageType fastReflection_QueryUserMigrationStatusResponse_messageType
var _ protoreflect.MessageType = fastReflection_QueryUserMigrationStatusResponse_messageType{}

type fastReflection_QueryUserMigrationStatusResponse_messageType struct{}

func (x fastReflection_QueryUserMigrationStatusResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QueryUserMigrationStatusResponse)(nil)
}
func (x fastReflection_QueryUserMigrationStatusResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_QueryUserMigrationStatusResponse)
}
func (x fastReflection_QueryUserMigrationStatusResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryUserMigrationStatusResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QueryUserMigrationStatusResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryUserMigrationStatusResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QueryUserMigrationStatusResponse) Type() protoreflect.MessageType {
	return _fastReflection_QueryUserMigrationStatusResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QueryUserMigrationStatusResponse) New() protoreflect.Message {
	return new(fastReflection_QueryUserMigrationStatusResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QueryUserMigrationStatusResponse) Interface() protoreflect.ProtoMessage {
	return (*QueryUserMigrationStatusResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QueryUserMigrationStatusResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.HasMigrated != false {
		value := protoreflect.ValueOfBool(x.HasMigrated)
		if !f(fd_QueryUserMigrationStatusResponse_has_migrated, value) {
			return
		}
	}
	if len(x.LegacyPositions) != 0 {
		value := protoreflect.ValueOfList(&_QueryUserMigrationStatusResponse_2_list{list: &x.LegacyPositions})
		if !f(fd_QueryUserMigrationStatusResponse_legacy_positions, value) {
			return
		}
	}
	if x.MigrationRecord != nil {
		value := protoreflect.ValueOfMessage(x.MigrationRecord.ProtoReflect())
		if !f(fd_QueryUserMigrationStatusResponse_migration_record, value) {
			return
		}
	}
	if x.EstimatedShares != "" {
		value := protoreflect.ValueOfString(x.EstimatedShares)
		if !f(fd_QueryUserMigrationStatusResponse_estimated_shares, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QueryUserMigrationStatusResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.has_migrated":
		return x.HasMigrated != false
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.legacy_positions":
		return len(x.LegacyPositions) != 0
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.migration_record":
		return x.MigrationRecord != nil
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.estimated_shares":
		return x.EstimatedShares != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryUserMigrationStatusResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryUserMigrationStatusResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryUserMigrationStatusResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.has_migrated":
		x.HasMigrated = false
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.legacy_positions":
		x.LegacyPositions = nil
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.migration_record":
		x.MigrationRecord = nil
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.estimated_shares":
		x.EstimatedShares = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryUserMigrationStatusResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryUserMigrationStatusResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QueryUserMigrationStatusResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.has_migrated":
		value := x.HasMigrated
		return protoreflect.ValueOfBool(value)
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.legacy_positions":
		if len(x.LegacyPositions) == 0 {
			return protoreflect.ValueOfList(&_QueryUserMigrationStatusResponse_2_list{})
		}
		listValue := &_QueryUserMigrationStatusResponse_2_list{list: &x.LegacyPositions}
		return protoreflect.ValueOfList(listValue)
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.migration_record":
		value := x.MigrationRecord
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.estimated_shares":
		value := x.EstimatedShares
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryUserMigrationStatusResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryUserMigrationStatusResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryUserMigrationStatusResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.has_migrated":
		x.HasMigrated = value.Bool()
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.legacy_positions":
		lv := value.List()
		clv := lv.(*_QueryUserMigrationStatusResponse_2_list)
		x.LegacyPositions = *clv.list
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.migration_record":
		x.MigrationRecord = value.Message().Interface().(*UserMigrationRecord)
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.estimated_shares":
		x.EstimatedShares = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryUserMigrationStatusResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryUserMigrationStatusResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryUserMigrationStatusResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.legacy_positions":
		if x.LegacyPositions == nil {
			x.LegacyPositions = []*Position{}
		}
		value := &_QueryUserMigrationStatusResponse_2_list{list: &x.LegacyPositions}
		return protoreflect.ValueOfList(value)
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.migration_record":
		if x.MigrationRecord == nil {
			x.MigrationRecord = new(UserMigrationRecord)
		}
		return protoreflect.ValueOfMessage(x.MigrationRecord.ProtoReflect())
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.has_migrated":
		panic(fmt.Errorf("field has_migrated of message noble.dollar.vaults.v1.QueryUserMigrationStatusResponse is not mutable"))
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.estimated_shares":
		panic(fmt.Errorf("field estimated_shares of message noble.dollar.vaults.v1.QueryUserMigrationStatusResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryUserMigrationStatusResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryUserMigrationStatusResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QueryUserMigrationStatusResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.has_migrated":
		return protoreflect.ValueOfBool(false)
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.legacy_positions":
		list := []*Position{}
		return protoreflect.ValueOfList(&_QueryUserMigrationStatusResponse_2_list{list: &list})
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.migration_record":
		m := new(UserMigrationRecord)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.estimated_shares":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryUserMigrationStatusResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryUserMigrationStatusResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QueryUserMigrationStatusResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.QueryUserMigrationStatusResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QueryUserMigrationStatusResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryUserMigrationStatusResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QueryUserMigrationStatusResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QueryUserMigrationStatusResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QueryUserMigrationStatusResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.HasMigrated {
			n += 2
		}
		if len(x.LegacyPositions) > 0 {
			for _, e := range x.LegacyPositions {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.MigrationRecord != nil {
			l = options.Size(x.MigrationRecord)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.EstimatedShares)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QueryUserMigrationStatusResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.EstimatedShares) > 0 {
			i -= len(x.EstimatedShares)
			copy(dAtA[i:], x.EstimatedShares)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.EstimatedShares)))
			i--
			dAtA[i] = 0x22
		}
		if x.MigrationRecord != nil {
			encoded, err := options.Marshal(x.MigrationRecord)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.LegacyPositions) > 0 {
			for iNdEx := len(x.LegacyPositions) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.LegacyPositions[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if x.HasMigrated {
			i--
			if x.HasMigrated {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QueryUserMigrationStatusResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryUserMigrationStatusResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryUserMigrationStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field HasMigrated", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.HasMigrated = bool(v != 0)
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LegacyPositions", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LegacyPositions = append(x.LegacyPositions, &Position{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LegacyPositions[len(x.LegacyPositions)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MigrationRecord", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.MigrationRecord == nil {
					x.MigrationRecord = &UserMigrationRecord{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MigrationRecord); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EstimatedShares", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.EstimatedShares = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_QueryMigrationPreviewRequest            protoreflect.MessageDescriptor
	fd_QueryMigrationPreviewRequest_address    protoreflect.FieldDescriptor
	fd_QueryMigrationPreviewRequest_vault_type protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_QueryMigrationPreviewRequest = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("QueryMigrationPreviewRequest")
	fd_QueryMigrationPreviewRequest_address = md_QueryMigrationPreviewRequest.Fields().ByName("address")
	fd_QueryMigrationPreviewRequest_vault_type = md_QueryMigrationPreviewRequest.Fields().ByName("vault_type")
}

var _ protoreflect.Message = (*fastReflection_QueryMigrationPreviewRequest)(nil)

type fastReflection_QueryMigrationPreviewRequest QueryMigrationPreviewRequest

func (x *QueryMigrationPreviewRequest) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QueryMigrationPreviewRequest)(x)
}

func (x *QueryMigrationPreviewRequest) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QueryMigrationPreviewRequest_messageType fastReflection_QueryMigrationPreviewRequest_messageType
var _ protoreflect.MessageType = fastReflection_QueryMigrationPreviewRequest_messageType{}

type fastReflection_QueryMigrationPreviewRequest_messageType struct{}

func (x fastReflection_QueryMigrationPreviewRequest_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QueryMigrationPreviewRequest)(nil)
}
func (x fastReflection_QueryMigrationPreviewRequest_messageType) New() protoreflect.Message {
	return new(fastReflection_QueryMigrationPreviewRequest)
}
func (x fastReflection_QueryMigrationPreviewRequest_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryMigrationPreviewRequest
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QueryMigrationPreviewRequest) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryMigrationPreviewRequest
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QueryMigrationPreviewRequest) Type() protoreflect.MessageType {
	return _fastReflection_QueryMigrationPreviewRequest_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QueryMigrationPreviewRequest) New() protoreflect.Message {
	return new(fastReflection_QueryMigrationPreviewRequest)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QueryMigrationPreviewRequest) Interface() protoreflect.ProtoMessage {
	return (*QueryMigrationPreviewRequest)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QueryMigrationPreviewRequest) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Address != "" {
		value := protoreflect.ValueOfString(x.Address)
		if !f(fd_QueryMigrationPreviewRequest_address, value) {
			return
		}
	}
	if x.VaultType != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.VaultType))
		if !f(fd_QueryMigrationPreviewRequest_vault_type, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QueryMigrationPreviewRequest) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationPreviewRequest.address":
		return x.Address != ""
	case "noble.dollar.vaults.v1.QueryMigrationPreviewRequest.vault_type":
		return x.VaultType != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationPreviewRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationPreviewRequest does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationPreviewRequest) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationPreviewRequest.address":
		x.Address = ""
	case "noble.dollar.vaults.v1.QueryMigrationPreviewRequest.vault_type":
		x.VaultType = 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationPreviewRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationPreviewRequest does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QueryMigrationPreviewRequest) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationPreviewRequest.address":
		value := x.Address
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.QueryMigrationPreviewRequest.vault_type":
		value := x.VaultType
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationPreviewRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationPreviewRequest does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationPreviewRequest) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationPreviewRequest.address":
		x.Address = value.Interface().(string)
	case "noble.dollar.vaults.v1.QueryMigrationPreviewRequest.vault_type":
		x.VaultType = (VaultType)(value.Enum())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationPreviewRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationPreviewRequest does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationPreviewRequest) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationPreviewRequest.address":
		panic(fmt.Errorf("field address of message noble.dollar.vaults.v1.QueryMigrationPreviewRequest is not mutable"))
	case "noble.dollar.vaults.v1.QueryMigrationPreviewRequest.vault_type":
		panic(fmt.Errorf("field vault_type of message noble.dollar.vaults.v1.QueryMigrationPreviewRequest is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationPreviewRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationPreviewRequest does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QueryMigrationPreviewRequest) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationPreviewRequest.address":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.QueryMigrationPreviewRequest.vault_type":
		return protoreflect.ValueOfEnum(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationPreviewRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationPreviewRequest does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QueryMigrationPreviewRequest) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.QueryMigrationPreviewRequest", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QueryMigrationPreviewRequest) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationPreviewRequest) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QueryMigrationPreviewRequest) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QueryMigrationPreviewRequest) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QueryMigrationPreviewRequest)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.VaultType != 0 {
			n += 1 + runtime.Sov(uint64(x.VaultType))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QueryMigrationPreviewRequest)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.VaultType != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.VaultType))
			i--
			dAtA[i] = 0x10
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QueryMigrationPreviewRequest)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryMigrationPreviewRequest: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryMigrationPreviewRequest: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VaultType", wireType)
				}
				x.VaultType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.VaultType |= VaultType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_QueryMigrationPreviewResponse                  protoreflect.MessageDescriptor
	fd_QueryMigrationPreviewResponse_total_value      protoreflect.FieldDescriptor
	fd_QueryMigrationPreviewResponse_principal_amount protoreflect.FieldDescriptor
	fd_QueryMigrationPreviewResponse_accrued_rewards  protoreflect.FieldDescriptor
	fd_QueryMigrationPreviewResponse_estimated_shares protoreflect.FieldDescriptor
	fd_QueryMigrationPreviewResponse_current_nav      protoreflect.FieldDescriptor
	fd_QueryMigrationPreviewResponse_position_count   protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v1_migration_proto_init()
	md_QueryMigrationPreviewResponse = File_noble_dollar_vaults_v1_migration_proto.Messages().ByName("QueryMigrationPreviewResponse")
	fd_QueryMigrationPreviewResponse_total_value = md_QueryMigrationPreviewResponse.Fields().ByName("total_value")
	fd_QueryMigrationPreviewResponse_principal_amount = md_QueryMigrationPreviewResponse.Fields().ByName("principal_amount")
	fd_QueryMigrationPreviewResponse_accrued_rewards = md_QueryMigrationPreviewResponse.Fields().ByName("accrued_rewards")
	fd_QueryMigrationPreviewResponse_estimated_shares = md_QueryMigrationPreviewResponse.Fields().ByName("estimated_shares")
	fd_QueryMigrationPreviewResponse_current_nav = md_QueryMigrationPreviewResponse.Fields().ByName("current_nav")
	fd_QueryMigrationPreviewResponse_position_count = md_QueryMigrationPreviewResponse.Fields().ByName("position_count")
}

var _ protoreflect.Message = (*fastReflection_QueryMigrationPreviewResponse)(nil)

type fastReflection_QueryMigrationPreviewResponse QueryMigrationPreviewResponse

func (x *QueryMigrationPreviewResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_QueryMigrationPreviewResponse)(x)
}

func (x *QueryMigrationPreviewResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_QueryMigrationPreviewResponse_messageType fastReflection_QueryMigrationPreviewResponse_messageType
var _ protoreflect.MessageType = fastReflection_QueryMigrationPreviewResponse_messageType{}

type fastReflection_QueryMigrationPreviewResponse_messageType struct{}

func (x fastReflection_QueryMigrationPreviewResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_QueryMigrationPreviewResponse)(nil)
}
func (x fastReflection_QueryMigrationPreviewResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_QueryMigrationPreviewResponse)
}
func (x fastReflection_QueryMigrationPreviewResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryMigrationPreviewResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_QueryMigrationPreviewResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_QueryMigrationPreviewResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_QueryMigrationPreviewResponse) Type() protoreflect.MessageType {
	return _fastReflection_QueryMigrationPreviewResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_QueryMigrationPreviewResponse) New() protoreflect.Message {
	return new(fastReflection_QueryMigrationPreviewResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_QueryMigrationPreviewResponse) Interface() protoreflect.ProtoMessage {
	return (*QueryMigrationPreviewResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_QueryMigrationPreviewResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TotalValue != "" {
		value := protoreflect.ValueOfString(x.TotalValue)
		if !f(fd_QueryMigrationPreviewResponse_total_value, value) {
			return
		}
	}
	if x.PrincipalAmount != "" {
		value := protoreflect.ValueOfString(x.PrincipalAmount)
		if !f(fd_QueryMigrationPreviewResponse_principal_amount, value) {
			return
		}
	}
	if x.AccruedRewards != "" {
		value := protoreflect.ValueOfString(x.AccruedRewards)
		if !f(fd_QueryMigrationPreviewResponse_accrued_rewards, value) {
			return
		}
	}
	if x.EstimatedShares != "" {
		value := protoreflect.ValueOfString(x.EstimatedShares)
		if !f(fd_QueryMigrationPreviewResponse_estimated_shares, value) {
			return
		}
	}
	if x.CurrentNav != "" {
		value := protoreflect.ValueOfString(x.CurrentNav)
		if !f(fd_QueryMigrationPreviewResponse_current_nav, value) {
			return
		}
	}
	if x.PositionCount != int64(0) {
		value := protoreflect.ValueOfInt64(x.PositionCount)
		if !f(fd_QueryMigrationPreviewResponse_position_count, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_QueryMigrationPreviewResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.total_value":
		return x.TotalValue != ""
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.principal_amount":
		return x.PrincipalAmount != ""
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.accrued_rewards":
		return x.AccruedRewards != ""
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.estimated_shares":
		return x.EstimatedShares != ""
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.current_nav":
		return x.CurrentNav != ""
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.position_count":
		return x.PositionCount != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationPreviewResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationPreviewResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationPreviewResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.total_value":
		x.TotalValue = ""
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.principal_amount":
		x.PrincipalAmount = ""
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.accrued_rewards":
		x.AccruedRewards = ""
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.estimated_shares":
		x.EstimatedShares = ""
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.current_nav":
		x.CurrentNav = ""
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.position_count":
		x.PositionCount = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationPreviewResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationPreviewResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_QueryMigrationPreviewResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.total_value":
		value := x.TotalValue
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.principal_amount":
		value := x.PrincipalAmount
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.accrued_rewards":
		value := x.AccruedRewards
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.estimated_shares":
		value := x.EstimatedShares
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.current_nav":
		value := x.CurrentNav
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.position_count":
		value := x.PositionCount
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationPreviewResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationPreviewResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationPreviewResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.total_value":
		x.TotalValue = value.Interface().(string)
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.principal_amount":
		x.PrincipalAmount = value.Interface().(string)
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.accrued_rewards":
		x.AccruedRewards = value.Interface().(string)
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.estimated_shares":
		x.EstimatedShares = value.Interface().(string)
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.current_nav":
		x.CurrentNav = value.Interface().(string)
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.position_count":
		x.PositionCount = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationPreviewResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationPreviewResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationPreviewResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.total_value":
		panic(fmt.Errorf("field total_value of message noble.dollar.vaults.v1.QueryMigrationPreviewResponse is not mutable"))
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.principal_amount":
		panic(fmt.Errorf("field principal_amount of message noble.dollar.vaults.v1.QueryMigrationPreviewResponse is not mutable"))
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.accrued_rewards":
		panic(fmt.Errorf("field accrued_rewards of message noble.dollar.vaults.v1.QueryMigrationPreviewResponse is not mutable"))
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.estimated_shares":
		panic(fmt.Errorf("field estimated_shares of message noble.dollar.vaults.v1.QueryMigrationPreviewResponse is not mutable"))
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.current_nav":
		panic(fmt.Errorf("field current_nav of message noble.dollar.vaults.v1.QueryMigrationPreviewResponse is not mutable"))
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.position_count":
		panic(fmt.Errorf("field position_count of message noble.dollar.vaults.v1.QueryMigrationPreviewResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationPreviewResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationPreviewResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_QueryMigrationPreviewResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.total_value":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.principal_amount":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.accrued_rewards":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.estimated_shares":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.current_nav":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v1.QueryMigrationPreviewResponse.position_count":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v1.QueryMigrationPreviewResponse"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v1.QueryMigrationPreviewResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_QueryMigrationPreviewResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v1.QueryMigrationPreviewResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_QueryMigrationPreviewResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_QueryMigrationPreviewResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_QueryMigrationPreviewResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_QueryMigrationPreviewResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*QueryMigrationPreviewResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.TotalValue)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PrincipalAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AccruedRewards)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.EstimatedShares)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CurrentNav)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.PositionCount != 0 {
			n += 1 + runtime.Sov(uint64(x.PositionCount))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*QueryMigrationPreviewResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.PositionCount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PositionCount))
			i--
			dAtA[i] = 0x30
		}
		if len(x.CurrentNav) > 0 {
			i -= len(x.CurrentNav)
			copy(dAtA[i:], x.CurrentNav)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CurrentNav)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.EstimatedShares) > 0 {
			i -= len(x.EstimatedShares)
			copy(dAtA[i:], x.EstimatedShares)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.EstimatedShares)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.AccruedRewards) > 0 {
			i -= len(x.AccruedRewards)
			copy(dAtA[i:], x.AccruedRewards)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AccruedRewards)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PrincipalAmount) > 0 {
			i -= len(x.PrincipalAmount)
			copy(dAtA[i:], x.PrincipalAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrincipalAmount)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.TotalValue) > 0 {
			i -= len(x.TotalValue)
			copy(dAtA[i:], x.TotalValue)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalValue)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*QueryMigrationPreviewResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryMigrationPreviewResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: QueryMigrationPreviewResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalValue = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrincipalAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrincipalAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AccruedRewards", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AccruedRewards = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EstimatedShares", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.EstimatedShares = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CurrentNav", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CurrentNav = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PositionCount", wireType)
				}
				x.PositionCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PositionCount |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: noble/dollar/vaults/v1/migration.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// MigrationState represents the current state of the migration process
type MigrationState int32

const (
	// Migration has not started yet
	MigrationState_MIGRATION_STATE_NOT_STARTED MigrationState = 0
	// Migration is active, users can migrate
	MigrationState_MIGRATION_STATE_ACTIVE MigrationState = 1
	// Migration is in closing period (grace period warning)
	MigrationState_MIGRATION_STATE_CLOSING MigrationState = 2
	// Migration is locked, no new migrations allowed
	MigrationState_MIGRATION_STATE_LOCKED MigrationState = 3
	// Legacy vault is deprecated
	MigrationState_MIGRATION_STATE_DEPRECATED MigrationState = 4
	// Migration has been cancelled
	MigrationState_MIGRATION_STATE_CANCELLED MigrationState = 5
)

// Enum value maps for MigrationState.
var (
	MigrationState_name = map[int32]string{
		0: "MIGRATION_STATE_NOT_STARTED",
		1: "MIGRATION_STATE_ACTIVE",
		2: "MIGRATION_STATE_CLOSING",
		3: "MIGRATION_STATE_LOCKED",
		4: "MIGRATION_STATE_DEPRECATED",
		5: "MIGRATION_STATE_CANCELLED",
	}
	MigrationState_value = map[string]int32{
		"MIGRATION_STATE_NOT_STARTED": 0,
		"MIGRATION_STATE_ACTIVE":      1,
		"MIGRATION_STATE_CLOSING":     2,
		"MIGRATION_STATE_LOCKED":      3,
		"MIGRATION_STATE_DEPRECATED":  4,
		"MIGRATION_STATE_CANCELLED":   5,
	}
)

func (x MigrationState) Enum() *MigrationState {
	p := new(MigrationState)
	*p = x
	return p
}

func (x MigrationState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MigrationState) Descriptor() protoreflect.EnumDescriptor {
	return file_noble_dollar_vaults_v1_migration_proto_enumTypes[0].Descriptor()
}

func (MigrationState) Type() protoreflect.EnumType {
	return &file_noble_dollar_vaults_v1_migration_proto_enumTypes[0]
}

func (x MigrationState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MigrationState.Descriptor instead.
func (MigrationState) EnumDescriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{0}
}

// MsgMigratePosition allows users to migrate their legacy positions to the new vault system
type MsgMigratePosition struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// User initiating the migration
	Signer string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	// Vault type to migrate from
	VaultType VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// Amount to migrate (0 = migrate all positions)
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// Whether user wants to forgo yield (for yield redistribution)
	ForgoYield bool `protobuf:"varint,4,opt,name=forgo_yield,json=forgoYield,proto3" json:"forgo_yield,omitempty"`
}

func (x *MsgMigratePosition) Reset() {
	*x = MsgMigratePosition{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgMigratePosition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgMigratePosition) ProtoMessage() {}

// Deprecated: Use MsgMigratePosition.ProtoReflect.Descriptor instead.
func (*MsgMigratePosition) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{0}
}

func (x *MsgMigratePosition) GetSigner() string {
	if x != nil {
		return x.Signer
	}
	return ""
}

func (x *MsgMigratePosition) GetVaultType() VaultType {
	if x != nil {
		return x.VaultType
	}
	return VaultType_UNSPECIFIED
}

func (x *MsgMigratePosition) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *MsgMigratePosition) GetForgoYield() bool {
	if x != nil {
		return x.ForgoYield
	}
	return false
}

// MsgMigratePositionResponse returns the results of a position migration
type MsgMigratePositionResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Shares received in the new vault system
	SharesReceived string `protobuf:"bytes,1,opt,name=shares_received,json=sharesReceived,proto3" json:"shares_received,omitempty"`
	// Principal amount migrated
	PrincipalMigrated string `protobuf:"bytes,2,opt,name=principal_migrated,json=principalMigrated,proto3" json:"principal_migrated,omitempty"`
	// Rewards included in migration
	RewardsMigrated string `protobuf:"bytes,3,opt,name=rewards_migrated,json=rewardsMigrated,proto3" json:"rewards_migrated,omitempty"`
	// Transaction hash for reference
	MigrationTxHash string `protobuf:"bytes,4,opt,name=migration_tx_hash,json=migrationTxHash,proto3" json:"migration_tx_hash,omitempty"`
	// Gas used for the migration
	GasUsed uint64 `protobuf:"varint,5,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
}

func (x *MsgMigratePositionResponse) Reset() {
	*x = MsgMigratePositionResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgMigratePositionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgMigratePositionResponse) ProtoMessage() {}

// Deprecated: Use MsgMigratePositionResponse.ProtoReflect.Descriptor instead.
func (*MsgMigratePositionResponse) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{1}
}

func (x *MsgMigratePositionResponse) GetSharesReceived() string {
	if x != nil {
		return x.SharesReceived
	}
	return ""
}

func (x *MsgMigratePositionResponse) GetPrincipalMigrated() string {
	if x != nil {
		return x.PrincipalMigrated
	}
	return ""
}

func (x *MsgMigratePositionResponse) GetRewardsMigrated() string {
	if x != nil {
		return x.RewardsMigrated
	}
	return ""
}

func (x *MsgMigratePositionResponse) GetMigrationTxHash() string {
	if x != nil {
		return x.MigrationTxHash
	}
	return ""
}

func (x *MsgMigratePositionResponse) GetGasUsed() uint64 {
	if x != nil {
		return x.GasUsed
	}
	return 0
}

// MsgEmergencyWithdrawLegacy allows users to withdraw from legacy positions in emergency scenarios
type MsgEmergencyWithdrawLegacy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// User requesting emergency withdrawal
	Signer string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	// Vault type to withdraw from
	VaultType VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
	// Specific position indices to withdraw (empty = all positions)
	PositionIndices []int64 `protobuf:"varint,3,rep,packed,name=position_indices,json=positionIndices,proto3" json:"position_indices,omitempty"`
}

func (x *MsgEmergencyWithdrawLegacy) Reset() {
	*x = MsgEmergencyWithdrawLegacy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgEmergencyWithdrawLegacy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgEmergencyWithdrawLegacy) ProtoMessage() {}

// Deprecated: Use MsgEmergencyWithdrawLegacy.ProtoReflect.Descriptor instead.
func (*MsgEmergencyWithdrawLegacy) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{2}
}

func (x *MsgEmergencyWithdrawLegacy) GetSigner() string {
	if x != nil {
		return x.Signer
	}
	return ""
}

func (x *MsgEmergencyWithdrawLegacy) GetVaultType() VaultType {
	if x != nil {
		return x.VaultType
	}
	return VaultType_UNSPECIFIED
}

func (x *MsgEmergencyWithdrawLegacy) GetPositionIndices() []int64 {
	if x != nil {
		return x.PositionIndices
	}
	return nil
}

// MsgEmergencyWithdrawLegacyResponse returns the results of emergency withdrawal
type MsgEmergencyWithdrawLegacyResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Amount withdrawn
	AmountWithdrawn string `protobuf:"bytes,1,opt,name=amount_withdrawn,json=amountWithdrawn,proto3" json:"amount_withdrawn,omitempty"`
	// Number of positions withdrawn
	PositionsWithdrawn int64 `protobuf:"varint,2,opt,name=positions_withdrawn,json=positionsWithdrawn,proto3" json:"positions_withdrawn,omitempty"`
}

func (x *MsgEmergencyWithdrawLegacyResponse) Reset() {
	*x = MsgEmergencyWithdrawLegacyResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgEmergencyWithdrawLegacyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgEmergencyWithdrawLegacyResponse) ProtoMessage() {}

// Deprecated: Use MsgEmergencyWithdrawLegacyResponse.ProtoReflect.Descriptor instead.
func (*MsgEmergencyWithdrawLegacyResponse) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{3}
}

func (x *MsgEmergencyWithdrawLegacyResponse) GetAmountWithdrawn() string {
	if x != nil {
		return x.AmountWithdrawn
	}
	return ""
}

func (x *MsgEmergencyWithdrawLegacyResponse) GetPositionsWithdrawn() int64 {
	if x != nil {
		return x.PositionsWithdrawn
	}
	return 0
}

// MsgUpdateMigrationState allows authority to update migration state
type MsgUpdateMigrationState struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Authority address
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// New migration state
	NewState MigrationState `protobuf:"varint,2,opt,name=new_state,json=newState,proto3,enum=noble.dollar.vaults.v1.MigrationState" json:"new_state,omitempty"`
	// Reason for state change
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (x *MsgUpdateMigrationState) Reset() {
	*x = MsgUpdateMigrationState{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateMigrationState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateMigrationState) ProtoMessage() {}

// Deprecated: Use MsgUpdateMigrationState.ProtoReflect.Descriptor instead.
func (*MsgUpdateMigrationState) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{4}
}

func (x *MsgUpdateMigrationState) GetAuthority() string {
	if x != nil {
		return x.Authority
	}
	return ""
}

func (x *MsgUpdateMigrationState) GetNewState() MigrationState {
	if x != nil {
		return x.NewState
	}
	return MigrationState_MIGRATION_STATE_NOT_STARTED
}

func (x *MsgUpdateMigrationState) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// MsgUpdateMigrationStateResponse confirms migration state update
type MsgUpdateMigrationStateResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Previous state
	PreviousState MigrationState `protobuf:"varint,1,opt,name=previous_state,json=previousState,proto3,enum=noble.dollar.vaults.v1.MigrationState" json:"previous_state,omitempty"`
	// New state
	NewState MigrationState `protobuf:"varint,2,opt,name=new_state,json=newState,proto3,enum=noble.dollar.vaults.v1.MigrationState" json:"new_state,omitempty"`
	// Update timestamp
	UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (x *MsgUpdateMigrationStateResponse) Reset() {
	*x = MsgUpdateMigrationStateResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateMigrationStateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateMigrationStateResponse) ProtoMessage() {}

// Deprecated: Use MsgUpdateMigrationStateResponse.ProtoReflect.Descriptor instead.
func (*MsgUpdateMigrationStateResponse) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{5}
}

func (x *MsgUpdateMigrationStateResponse) GetPreviousState() MigrationState {
	if x != nil {
		return x.PreviousState
	}
	return MigrationState_MIGRATION_STATE_NOT_STARTED
}

func (x *MsgUpdateMigrationStateResponse) GetNewState() MigrationState {
	if x != nil {
		return x.NewState
	}
	return MigrationState_MIGRATION_STATE_NOT_STARTED
}

func (x *MsgUpdateMigrationStateResponse) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

// MigrationConfig defines configuration parameters for the migration process
type MigrationConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Migration start time
	StartTime *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Time when migration enters closing period
	ClosingTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=closing_time,json=closingTime,proto3" json:"closing_time,omitempty"`
	// Final deadline for migrations
	FinalDeadline *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=final_deadline,json=finalDeadline,proto3" json:"final_deadline,omitempty"`
	// Maximum number of migrations allowed per block
	MaxMigrationPerBlock int64 `protobuf:"varint,4,opt,name=max_migration_per_block,json=maxMigrationPerBlock,proto3" json:"max_migration_per_block,omitempty"`
	// Minimum amount required for migration
	MinMigrationAmount string `protobuf:"bytes,5,opt,name=min_migration_amount,json=minMigrationAmount,proto3" json:"min_migration_amount,omitempty"`
	// Whether full migration is required (cannot partial migrate)
	RequireFullMigration bool `protobuf:"varint,6,opt,name=require_full_migration,json=requireFullMigration,proto3" json:"require_full_migration,omitempty"`
	// Whether migration is enabled
	MigrationEnabled bool `protobuf:"varint,7,opt,name=migration_enabled,json=migrationEnabled,proto3" json:"migration_enabled,omitempty"`
}

func (x *MigrationConfig) Reset() {
	*x = MigrationConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MigrationConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MigrationConfig) ProtoMessage() {}

// Deprecated: Use MigrationConfig.ProtoReflect.Descriptor instead.
func (*MigrationConfig) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{6}
}

func (x *MigrationConfig) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *MigrationConfig) GetClosingTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ClosingTime
	}
	return nil
}

func (x *MigrationConfig) GetFinalDeadline() *timestamppb.Timestamp {
	if x != nil {
		return x.FinalDeadline
	}
	return nil
}

func (x *MigrationConfig) GetMaxMigrationPerBlock() int64 {
	if x != nil {
		return x.MaxMigrationPerBlock
	}
	return 0
}

func (x *MigrationConfig) GetMinMigrationAmount() string {
	if x != nil {
		return x.MinMigrationAmount
	}
	return ""
}

func (x *MigrationConfig) GetRequireFullMigration() bool {
	if x != nil {
		return x.RequireFullMigration
	}
	return false
}

func (x *MigrationConfig) GetMigrationEnabled() bool {
	if x != nil {
		return x.MigrationEnabled
	}
	return false
}

// UserMigrationRecord tracks migration details for a specific user
type UserMigrationRecord struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// When the user migrated
	MigratedAt *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=migrated_at,json=migratedAt,proto3" json:"migrated_at,omitempty"`
	// Vault type migrated from
	FromVaultType VaultType `protobuf:"varint,2,opt,name=from_vault_type,json=fromVaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"from_vault_type,omitempty"`
	// Number of legacy positions migrated
	LegacyPositionCount int64 `protobuf:"varint,3,opt,name=legacy_position_count,json=legacyPositionCount,proto3" json:"legacy_position_count,omitempty"`
	// Principal amount migrated
	PrincipalMigrated string `protobuf:"bytes,4,opt,name=principal_migrated,json=principalMigrated,proto3" json:"principal_migrated,omitempty"`
	// Rewards amount migrated
	RewardsMigrated string `protobuf:"bytes,5,opt,name=rewards_migrated,json=rewardsMigrated,proto3" json:"rewards_migrated,omitempty"`
	// Shares received in new system
	SharesReceived string `protobuf:"bytes,6,opt,name=shares_received,json=sharesReceived,proto3" json:"shares_received,omitempty"`
	// Migration transaction hash
	MigrationTxHash string `protobuf:"bytes,7,opt,name=migration_tx_hash,json=migrationTxHash,proto3" json:"migration_tx_hash,omitempty"`
	// Gas used for migration
	GasUsed uint64 `protobuf:"varint,8,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	// Whether user chose to forgo yield
	YieldForgone bool `protobuf:"varint,9,opt,name=yield_forgone,json=yieldForgone,proto3" json:"yield_forgone,omitempty"`
}

func (x *UserMigrationRecord) Reset() {
	*x = UserMigrationRecord{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UserMigrationRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserMigrationRecord) ProtoMessage() {}

// Deprecated: Use UserMigrationRecord.ProtoReflect.Descriptor instead.
func (*UserMigrationRecord) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{7}
}

func (x *UserMigrationRecord) GetMigratedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.MigratedAt
	}
	return nil
}

func (x *UserMigrationRecord) GetFromVaultType() VaultType {
	if x != nil {
		return x.FromVaultType
	}
	return VaultType_UNSPECIFIED
}

func (x *UserMigrationRecord) GetLegacyPositionCount() int64 {
	if x != nil {
		return x.LegacyPositionCount
	}
	return 0
}

func (x *UserMigrationRecord) GetPrincipalMigrated() string {
	if x != nil {
		return x.PrincipalMigrated
	}
	return ""
}

func (x *UserMigrationRecord) GetRewardsMigrated() string {
	if x != nil {
		return x.RewardsMigrated
	}
	return ""
}

func (x *UserMigrationRecord) GetSharesReceived() string {
	if x != nil {
		return x.SharesReceived
	}
	return ""
}

func (x *UserMigrationRecord) GetMigrationTxHash() string {
	if x != nil {
		return x.MigrationTxHash
	}
	return ""
}

func (x *UserMigrationRecord) GetGasUsed() uint64 {
	if x != nil {
		return x.GasUsed
	}
	return 0
}

func (x *UserMigrationRecord) GetYieldForgone() bool {
	if x != nil {
		return x.YieldForgone
	}
	return false
}

// MigrationStats tracks overall migration progress and statistics
type MigrationStats struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Total number of users in legacy system
	TotalUsers uint64 `protobuf:"varint,1,opt,name=total_users,json=totalUsers,proto3" json:"total_users,omitempty"`
	// Number of users who have migrated
	UsersMigrated uint64 `protobuf:"varint,2,opt,name=users_migrated,json=usersMigrated,proto3" json:"users_migrated,omitempty"`
	// Total value locked in legacy system
	TotalValueLocked string `protobuf:"bytes,3,opt,name=total_value_locked,json=totalValueLocked,proto3" json:"total_value_locked,omitempty"`
	// Total value migrated to new system
	ValueMigrated string `protobuf:"bytes,4,opt,name=value_migrated,json=valueMigrated,proto3" json:"value_migrated,omitempty"`
	// Total shares issued through migration
	TotalSharesIssued string `protobuf:"bytes,5,opt,name=total_shares_issued,json=totalSharesIssued,proto3" json:"total_shares_issued,omitempty"`
	// Last migration timestamp
	LastMigrationTime *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=last_migration_time,json=lastMigrationTime,proto3" json:"last_migration_time,omitempty"`
	// Average gas used per migration
	AverageGasPerMigration uint64 `protobuf:"varint,7,opt,name=average_gas_per_migration,json=averageGasPerMigration,proto3" json:"average_gas_per_migration,omitempty"`
	// Migration completion percentage (basis points)
	CompletionPercentage int32 `protobuf:"varint,8,opt,name=completion_percentage,json=completionPercentage,proto3" json:"completion_percentage,omitempty"`
}

func (x *MigrationStats) Reset() {
	*x = MigrationStats{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MigrationStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MigrationStats) ProtoMessage() {}

// Deprecated: Use MigrationStats.ProtoReflect.Descriptor instead.
func (*MigrationStats) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{8}
}

func (x *MigrationStats) GetTotalUsers() uint64 {
	if x != nil {
		return x.TotalUsers
	}
	return 0
}

func (x *MigrationStats) GetUsersMigrated() uint64 {
	if x != nil {
		return x.UsersMigrated
	}
	return 0
}

func (x *MigrationStats) GetTotalValueLocked() string {
	if x != nil {
		return x.TotalValueLocked
	}
	return ""
}

func (x *MigrationStats) GetValueMigrated() string {
	if x != nil {
		return x.ValueMigrated
	}
	return ""
}

func (x *MigrationStats) GetTotalSharesIssued() string {
	if x != nil {
		return x.TotalSharesIssued
	}
	return ""
}

func (x *MigrationStats) GetLastMigrationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastMigrationTime
	}
	return nil
}

func (x *MigrationStats) GetAverageGasPerMigration() uint64 {
	if x != nil {
		return x.AverageGasPerMigration
	}
	return 0
}

func (x *MigrationStats) GetCompletionPercentage() int32 {
	if x != nil {
		return x.CompletionPercentage
	}
	return 0
}

// LockedLegacyPosition represents a legacy position that has been locked during migration
type LockedLegacyPosition struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Original position details
	Position *Position `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
	// When the position was locked
	LockedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=locked_at,json=lockedAt,proto3" json:"locked_at,omitempty"`
	// Address it was migrated to (in new system)
	MigratedTo []byte `protobuf:"bytes,3,opt,name=migrated_to,json=migratedTo,proto3" json:"migrated_to,omitempty"`
	// Unique migration ID
	MigrationId string `protobuf:"bytes,4,opt,name=migration_id,json=migrationId,proto3" json:"migration_id,omitempty"`
	// Whether unlock is enabled (for emergency scenarios)
	UnlockEnabled bool `protobuf:"varint,5,opt,name=unlock_enabled,json=unlockEnabled,proto3" json:"unlock_enabled,omitempty"`
	// Lock reason
	LockReason string `protobuf:"bytes,6,opt,name=lock_reason,json=lockReason,proto3" json:"lock_reason,omitempty"`
}

func (x *LockedLegacyPosition) Reset() {
	*x = LockedLegacyPosition{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LockedLegacyPosition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LockedLegacyPosition) ProtoMessage() {}

// Deprecated: Use LockedLegacyPosition.ProtoReflect.Descriptor instead.
func (*LockedLegacyPosition) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{9}
}

func (x *LockedLegacyPosition) GetPosition() *Position {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *LockedLegacyPosition) GetLockedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.LockedAt
	}
	return nil
}

func (x *LockedLegacyPosition) GetMigratedTo() []byte {
	if x != nil {
		return x.MigratedTo
	}
	return nil
}

func (x *LockedLegacyPosition) GetMigrationId() string {
	if x != nil {
		return x.MigrationId
	}
	return ""
}

func (x *LockedLegacyPosition) GetUnlockEnabled() bool {
	if x != nil {
		return x.UnlockEnabled
	}
	return false
}

func (x *LockedLegacyPosition) GetLockReason() string {
	if x != nil {
		return x.LockReason
	}
	return ""
}

// MigrationPreview provides a preview of what a user would receive from migration
type MigrationPreview struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Total value to be migrated
	TotalValue string `protobuf:"bytes,1,opt,name=total_value,json=totalValue,proto3" json:"total_value,omitempty"`
	// Principal component
	PrincipalAmount string `protobuf:"bytes,2,opt,name=principal_amount,json=principalAmount,proto3" json:"principal_amount,omitempty"`
	// Accrued rewards component
	AccruedRewards string `protobuf:"bytes,3,opt,name=accrued_rewards,json=accruedRewards,proto3" json:"accrued_rewards,omitempty"`
	// Estimated shares to receive
	EstimatedShares string `protobuf:"bytes,4,opt,name=estimated_shares,json=estimatedShares,proto3" json:"estimated_shares,omitempty"`
	// Current NAV used for calculation
	CurrentNav string `protobuf:"bytes,5,opt,name=current_nav,json=currentNav,proto3" json:"current_nav,omitempty"`
	// Number of positions to be migrated
	PositionCount int64 `protobuf:"varint,6,opt,name=position_count,json=positionCount,proto3" json:"position_count,omitempty"`
}

func (x *MigrationPreview) Reset() {
	*x = MigrationPreview{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MigrationPreview) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MigrationPreview) ProtoMessage() {}

// Deprecated: Use MigrationPreview.ProtoReflect.Descriptor instead.
func (*MigrationPreview) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{10}
}

func (x *MigrationPreview) GetTotalValue() string {
	if x != nil {
		return x.TotalValue
	}
	return ""
}

func (x *MigrationPreview) GetPrincipalAmount() string {
	if x != nil {
		return x.PrincipalAmount
	}
	return ""
}

func (x *MigrationPreview) GetAccruedRewards() string {
	if x != nil {
		return x.AccruedRewards
	}
	return ""
}

func (x *MigrationPreview) GetEstimatedShares() string {
	if x != nil {
		return x.EstimatedShares
	}
	return ""
}

func (x *MigrationPreview) GetCurrentNav() string {
	if x != nil {
		return x.CurrentNav
	}
	return ""
}

func (x *MigrationPreview) GetPositionCount() int64 {
	if x != nil {
		return x.PositionCount
	}
	return 0
}

// MigrationBlockReason represents reasons why a user cannot migrate
type MigrationBlockReason struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Block reason code
	ReasonCode string `protobuf:"bytes,1,opt,name=reason_code,json=reasonCode,proto3" json:"reason_code,omitempty"`
	// Human readable reason
	ReasonMessage string `protobuf:"bytes,2,opt,name=reason_message,json=reasonMessage,proto3" json:"reason_message,omitempty"`
	// Whether this is a temporary block
	Temporary bool `protobuf:"varint,3,opt,name=temporary,proto3" json:"temporary,omitempty"`
	// When the block expires (if temporary)
	ExpiresAt *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
}

func (x *MigrationBlockReason) Reset() {
	*x = MigrationBlockReason{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MigrationBlockReason) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MigrationBlockReason) ProtoMessage() {}

// Deprecated: Use MigrationBlockReason.ProtoReflect.Descriptor instead.
func (*MigrationBlockReason) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{11}
}

func (x *MigrationBlockReason) GetReasonCode() string {
	if x != nil {
		return x.ReasonCode
	}
	return ""
}

func (x *MigrationBlockReason) GetReasonMessage() string {
	if x != nil {
		return x.ReasonMessage
	}
	return ""
}

func (x *MigrationBlockReason) GetTemporary() bool {
	if x != nil {
		return x.Temporary
	}
	return false
}

func (x *MigrationBlockReason) GetExpiresAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiresAt
	}
	return nil
}

type QueryMigrationStatusRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *QueryMigrationStatusRequest) Reset() {
	*x = QueryMigrationStatusRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QueryMigrationStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryMigrationStatusRequest) ProtoMessage() {}

// Deprecated: Use QueryMigrationStatusRequest.ProtoReflect.Descriptor instead.
func (*QueryMigrationStatusRequest) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{12}
}

type QueryMigrationStatusResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Current migration state
	State MigrationState `protobuf:"varint,1,opt,name=state,proto3,enum=noble.dollar.vaults.v1.MigrationState" json:"state,omitempty"`
	// Total value migrated
	TotalMigrated string `protobuf:"bytes,2,opt,name=total_migrated,json=totalMigrated,proto3" json:"total_migrated,omitempty"`
	// Total value remaining to migrate
	TotalRemaining string `protobuf:"bytes,3,opt,name=total_remaining,json=totalRemaining,proto3" json:"total_remaining,omitempty"`
	// Number of users migrated
	UsersMigrated int64 `protobuf:"varint,4,opt,name=users_migrated,json=usersMigrated,proto3" json:"users_migrated,omitempty"`
	// Number of users remaining
	UsersRemaining int64 `protobuf:"varint,5,opt,name=users_remaining,json=usersRemaining,proto3" json:"users_remaining,omitempty"`
}

func (x *QueryMigrationStatusResponse) Reset() {
	*x = QueryMigrationStatusResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QueryMigrationStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryMigrationStatusResponse) ProtoMessage() {}

// Deprecated: Use QueryMigrationStatusResponse.ProtoReflect.Descriptor instead.
func (*QueryMigrationStatusResponse) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{13}
}

func (x *QueryMigrationStatusResponse) GetState() MigrationState {
	if x != nil {
		return x.State
	}
	return MigrationState_MIGRATION_STATE_NOT_STARTED
}

func (x *QueryMigrationStatusResponse) GetTotalMigrated() string {
	if x != nil {
		return x.TotalMigrated
	}
	return ""
}

func (x *QueryMigrationStatusResponse) GetTotalRemaining() string {
	if x != nil {
		return x.TotalRemaining
	}
	return ""
}

func (x *QueryMigrationStatusResponse) GetUsersMigrated() int64 {
	if x != nil {
		return x.UsersMigrated
	}
	return 0
}

func (x *QueryMigrationStatusResponse) GetUsersRemaining() int64 {
	if x != nil {
		return x.UsersRemaining
	}
	return 0
}

type QueryUserMigrationStatusRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// User address to check
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Vault type (optional, defaults to all)
	VaultType VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
}

func (x *QueryUserMigrationStatusRequest) Reset() {
	*x = QueryUserMigrationStatusRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QueryUserMigrationStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryUserMigrationStatusRequest) ProtoMessage() {}

// Deprecated: Use QueryUserMigrationStatusRequest.ProtoReflect.Descriptor instead.
func (*QueryUserMigrationStatusRequest) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{14}
}

func (x *QueryUserMigrationStatusRequest) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *QueryUserMigrationStatusRequest) GetVaultType() VaultType {
	if x != nil {
		return x.VaultType
	}
	return VaultType_UNSPECIFIED
}

type QueryUserMigrationStatusResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Whether user has migrated
	HasMigrated bool `protobuf:"varint,1,opt,name=has_migrated,json=hasMigrated,proto3" json:"has_migrated,omitempty"`
	// Legacy positions (if not migrated)
	LegacyPositions []*Position `protobuf:"bytes,2,rep,name=legacy_positions,json=legacyPositions,proto3" json:"legacy_positions,omitempty"`
	// Migration record (if migrated)
	MigrationRecord *UserMigrationRecord `protobuf:"bytes,3,opt,name=migration_record,json=migrationRecord,proto3" json:"migration_record,omitempty"`
	// Estimated shares if they migrate now
	EstimatedShares string `protobuf:"bytes,4,opt,name=estimated_shares,json=estimatedShares,proto3" json:"estimated_shares,omitempty"`
}

func (x *QueryUserMigrationStatusResponse) Reset() {
	*x = QueryUserMigrationStatusResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QueryUserMigrationStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryUserMigrationStatusResponse) ProtoMessage() {}

// Deprecated: Use QueryUserMigrationStatusResponse.ProtoReflect.Descriptor instead.
func (*QueryUserMigrationStatusResponse) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{15}
}

func (x *QueryUserMigrationStatusResponse) GetHasMigrated() bool {
	if x != nil {
		return x.HasMigrated
	}
	return false
}

func (x *QueryUserMigrationStatusResponse) GetLegacyPositions() []*Position {
	if x != nil {
		return x.LegacyPositions
	}
	return nil
}

func (x *QueryUserMigrationStatusResponse) GetMigrationRecord() *UserMigrationRecord {
	if x != nil {
		return x.MigrationRecord
	}
	return nil
}

func (x *QueryUserMigrationStatusResponse) GetEstimatedShares() string {
	if x != nil {
		return x.EstimatedShares
	}
	return ""
}

type QueryMigrationPreviewRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// User address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Vault type
	VaultType VaultType `protobuf:"varint,2,opt,name=vault_type,json=vaultType,proto3,enum=noble.dollar.vaults.v1.VaultType" json:"vault_type,omitempty"`
}

func (x *QueryMigrationPreviewRequest) Reset() {
	*x = QueryMigrationPreviewRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QueryMigrationPreviewRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryMigrationPreviewRequest) ProtoMessage() {}

// Deprecated: Use QueryMigrationPreviewRequest.ProtoReflect.Descriptor instead.
func (*QueryMigrationPreviewRequest) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{16}
}

func (x *QueryMigrationPreviewRequest) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *QueryMigrationPreviewRequest) GetVaultType() VaultType {
	if x != nil {
		return x.VaultType
	}
	return VaultType_UNSPECIFIED
}

type QueryMigrationPreviewResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Total value to be migrated
	TotalValue string `protobuf:"bytes,1,opt,name=total_value,json=totalValue,proto3" json:"total_value,omitempty"`
	// Principal component
	PrincipalAmount string `protobuf:"bytes,2,opt,name=principal_amount,json=principalAmount,proto3" json:"principal_amount,omitempty"`
	// Accrued rewards component
	AccruedRewards string `protobuf:"bytes,3,opt,name=accrued_rewards,json=accruedRewards,proto3" json:"accrued_rewards,omitempty"`
	// Estimated shares to receive
	EstimatedShares string `protobuf:"bytes,4,opt,name=estimated_shares,json=estimatedShares,proto3" json:"estimated_shares,omitempty"`
	// Current NAV used for calculation
	CurrentNav string `protobuf:"bytes,5,opt,name=current_nav,json=currentNav,proto3" json:"current_nav,omitempty"`
	// Number of positions to be migrated
	PositionCount int64 `protobuf:"varint,6,opt,name=position_count,json=positionCount,proto3" json:"position_count,omitempty"`
}

func (x *QueryMigrationPreviewResponse) Reset() {
	*x = QueryMigrationPreviewResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v1_migration_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QueryMigrationPreviewResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryMigrationPreviewResponse) ProtoMessage() {}

// Deprecated: Use QueryMigrationPreviewResponse.ProtoReflect.Descriptor instead.
func (*QueryMigrationPreviewResponse) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP(), []int{17}
}

func (x *QueryMigrationPreviewResponse) GetTotalValue() string {
	if x != nil {
		return x.TotalValue
	}
	return ""
}

func (x *QueryMigrationPreviewResponse) GetPrincipalAmount() string {
	if x != nil {
		return x.PrincipalAmount
	}
	return ""
}

func (x *QueryMigrationPreviewResponse) GetAccruedRewards() string {
	if x != nil {
		return x.AccruedRewards
	}
	return ""
}

func (x *QueryMigrationPreviewResponse) GetEstimatedShares() string {
	if x != nil {
		return x.EstimatedShares
	}
	return ""
}

func (x *QueryMigrationPreviewResponse) GetCurrentNav() string {
	if x != nil {
		return x.CurrentNav
	}
	return ""
}

func (x *QueryMigrationPreviewResponse) GetPositionCount() int64 {
	if x != nil {
		return x.PositionCount
	}
	return 0
}

var File_noble_dollar_vaults_v1_migration_proto protoreflect.FileDescriptor

var file_noble_dollar_vaults_v1_migration_proto_rawDesc = []byte{
	0x0a, 0x26, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2f, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2f, 0x76,
	0x61, 0x75, 0x6c, 0x74, 0x73, 0x2f, 0x76, 0x31, 0x2f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x16, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e,
	0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31,
	0x1a, 0x11, 0x61, 0x6d, 0x69, 0x6e, 0x6f, 0x2f, 0x61, 0x6d, 0x69, 0x6e, 0x6f, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x6d, 0x73, 0x67, 0x2f,
	0x76, 0x31, 0x2f, 0x6d, 0x73, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x14, 0x67, 0x6f, 0x67, 0x6f, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67,
	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74,
	0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x23,
	0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2f, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2f, 0x76, 0x61, 0x75,
	0x6c, 0x74, 0x73, 0x2f, 0x76, 0x31, 0x2f, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x22, 0xaa, 0x02, 0x0a, 0x12, 0x4d, 0x73, 0x67, 0x4d, 0x69, 0x67, 0x72, 0x61,
	0x74, 0x65, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x30, 0x0a, 0x06, 0x73, 0x69,
	0x67, 0x6e, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74,
	0x72, 0x69, 0x6e, 0x67, 0x52, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x72, 0x12, 0x40, 0x0a, 0x0a,
	0x76, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x21, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e,
	0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x75, 0x6c, 0x74, 0x54,
	0x79, 0x70, 0x65, 0x52, 0x09, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x48,
	0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d,
	0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01,
	0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x66, 0x6f, 0x72, 0x67,
	0x6f, 0x5f, 0x79, 0x69, 0x65, 0x6c, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x66,
	0x6f, 0x72, 0x67, 0x6f, 0x59, 0x69, 0x65, 0x6c, 0x64, 0x3a, 0x35, 0x88, 0xa0, 0x1f, 0x00, 0xe8,
	0xa0, 0x1f, 0x00, 0x82, 0xe7, 0xb0, 0x2a, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x72, 0x8a, 0xe7,
	0xb0, 0x2a, 0x1d, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2f, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73,
	0x2f, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e,
	0x22, 0xfc, 0x02, 0x0a, 0x1a, 0x4d, 0x73, 0x67, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x50,
	0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x59, 0x0a, 0x0f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x73, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76,
	0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde,
	0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d,
	0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0e, 0x73, 0x68, 0x61, 0x72,
	0x65, 0x73, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x12, 0x5f, 0x0a, 0x12, 0x70, 0x72,
	0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x5f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74,
	0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e,
	0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x11, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69,
	0x70, 0x61, 0x6c, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x12, 0x5b, 0x0a, 0x10, 0x72,
	0x65, 0x77, 0x61, 0x72, 0x64, 0x73, 0x5f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49,
	0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0f, 0x72, 0x65, 0x77, 0x61, 0x72, 0x64, 0x73,
	0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x12, 0x2a, 0x0a, 0x11, 0x6d, 0x69, 0x67, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x78, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x78,
	0x48, 0x61, 0x73, 0x68, 0x12, 0x19, 0x0a, 0x08, 0x67, 0x61, 0x73, 0x5f, 0x75, 0x73, 0x65, 0x64,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x67, 0x61, 0x73, 0x55, 0x73, 0x65, 0x64, 0x22,
	0xfa, 0x01, 0x0a, 0x1a, 0x4d, 0x73, 0x67, 0x45, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x6e, 0x63, 0x79,
	0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x12, 0x30,
	0x0a, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18,
	0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x72,
	0x12, 0x40, 0x0a, 0x0a, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c,
	0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61,
	0x75, 0x6c, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x09, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x29, 0x0a, 0x10, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69,
	0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x03, 0x52, 0x0f, 0x70, 0x6f,
	0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x3a, 0x3d, 0x88,
	0xa0, 0x1f, 0x00, 0xe8, 0xa0, 0x1f, 0x00, 0x82, 0xe7, 0xb0, 0x2a, 0x06, 0x73, 0x69, 0x67, 0x6e,
	0x65, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x25, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2f, 0x76, 0x61,
	0x75, 0x6c, 0x74, 0x73, 0x2f, 0x45, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x6e, 0x63, 0x79, 0x57, 0x69,
	0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x22, 0xb2, 0x01, 0x0a,
	0x22, 0x4d, 0x73, 0x67, 0x45, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x6e, 0x63, 0x79, 0x57, 0x69, 0x74,
	0x68, 0x64, 0x72, 0x61, 0x77, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0x5b, 0x0a, 0x10, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x77, 0x69,
	0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b,
	0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52,
	0x0f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x6e,
	0x12, 0x2f, 0x0a, 0x13, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x77, 0x69,
	0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x12, 0x70,
	0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77,
	0x6e, 0x22, 0xed, 0x01, 0x0a, 0x17, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d,
	0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x36, 0x0a,
	0x09, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x09, 0x61, 0x75, 0x74, 0x68,
	0x6f, 0x72, 0x69, 0x74, 0x79, 0x12, 0x43, 0x0a, 0x09, 0x6e, 0x65, 0x77, 0x5f, 0x73, 0x74, 0x61,
	0x74, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x26, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65,
	0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76,
	0x31, 0x2e, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65,
	0x52, 0x08, 0x6e, 0x65, 0x77, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x65,
	0x61, 0x73, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x65, 0x61, 0x73,
	0x6f, 0x6e, 0x3a, 0x3d, 0x88, 0xa0, 0x1f, 0x00, 0xe8, 0xa0, 0x1f, 0x00, 0x82, 0xe7, 0xb0, 0x2a,
	0x09, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x8a, 0xe7, 0xb0, 0x2a, 0x22, 0x64,
	0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2f, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2f, 0x55, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74,
	0x65, 0x22, 0xfa, 0x01, 0x0a, 0x1f, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d,
	0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4d, 0x0a, 0x0e, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75,
	0x73, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x26, 0x2e,
	0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75,
	0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x0d, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x53,
	0x74, 0x61, 0x74, 0x65, 0x12, 0x43, 0x0a, 0x09, 0x6e, 0x65, 0x77, 0x5f, 0x73, 0x74, 0x61, 0x74,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x26, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e,
	0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31,
	0x2e, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52,
	0x08, 0x6e, 0x65, 0x77, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x43, 0x0a, 0x0a, 0x75, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90,
	0xdf, 0x1f, 0x01, 0x52, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x22, 0xea,
	0x03, 0x0a, 0x0f, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x12, 0x43, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
	0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x09, 0x73, 0x74,
	0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x47, 0x0a, 0x0c, 0x63, 0x6c, 0x6f, 0x73, 0x69,
	0x6e, 0x67, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90,
	0xdf, 0x1f, 0x01, 0x52, 0x0b, 0x63, 0x6c, 0x6f, 0x73, 0x69, 0x6e, 0x67, 0x54, 0x69, 0x6d, 0x65,
	0x12, 0x4b, 0x0a, 0x0e, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x65, 0x61, 0x64, 0x6c, 0x69,
	0x6e, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x0d,
	0x66, 0x69, 0x6e, 0x61, 0x6c, 0x44, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x35, 0x0a,
	0x17, 0x6d, 0x61, 0x78, 0x5f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70,
	0x65, 0x72, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x14,
	0x6d, 0x61, 0x78, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x65, 0x72, 0x42,
	0x6c, 0x6f, 0x63, 0x6b, 0x12, 0x62, 0x0a, 0x14, 0x6d, 0x69, 0x6e, 0x5f, 0x6d, 0x69, 0x67, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e,
	0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8,
	0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x12, 0x6d, 0x69, 0x6e, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x34, 0x0a, 0x16, 0x72, 0x65, 0x71, 0x75,
	0x69, 0x72, 0x65, 0x5f, 0x66, 0x75, 0x6c, 0x6c, 0x5f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x14, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72,
	0x65, 0x46, 0x75, 0x6c, 0x6c, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2b,
	0x0a, 0x11, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x65, 0x6e, 0x61, 0x62,
	0x6c, 0x65, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10, 0x6d, 0x69, 0x67, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x22, 0xe0, 0x04, 0x0a, 0x13,
	0x55, 0x73, 0x65, 0x72, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x63,
	0x6f, 0x72, 0x64, 0x12, 0x45, 0x0a, 0x0b, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x5f,
	0x61, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x0a,
	0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x49, 0x0a, 0x0f, 0x66, 0x72,
	0x6f, 0x6d, 0x5f, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c,
	0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x75,
	0x6c, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0d, 0x66, 0x72, 0x6f, 0x6d, 0x56, 0x61, 0x75, 0x6c,
	0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x32, 0x0a, 0x15, 0x6c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x5f,
	0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x13, 0x6c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x50, 0x6f, 0x73, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x5f, 0x0a, 0x12, 0x70, 0x72, 0x69,
	0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x5f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49,
	0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x11, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70,
	0x61, 0x6c, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x12, 0x5b, 0x0a, 0x10, 0x72, 0x65,
	0x77, 0x61, 0x72, 0x64, 0x73, 0x5f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e,
	0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e,
	0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0f, 0x72, 0x65, 0x77, 0x61, 0x72, 0x64, 0x73, 0x4d,
	0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x12, 0x59, 0x0a, 0x0f, 0x73, 0x68, 0x61, 0x72, 0x65,
	0x73, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2,
	0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0,
	0x2a, 0x01, 0x52, 0x0e, 0x73, 0x68, 0x61, 0x72, 0x65, 0x73, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76,
	0x65, 0x64, 0x12, 0x2a, 0x0a, 0x11, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x74, 0x78, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x6d,
	0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x78, 0x48, 0x61, 0x73, 0x68, 0x12, 0x19,
	0x0a, 0x08, 0x67, 0x61, 0x73, 0x5f, 0x75, 0x73, 0x65, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x07, 0x67, 0x61, 0x73, 0x55, 0x73, 0x65, 0x64, 0x12, 0x23, 0x0a, 0x0d, 0x79, 0x69, 0x65,
	0x6c, 0x64, 0x5f, 0x66, 0x6f, 0x72, 0x67, 0x6f, 0x6e, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x0c, 0x79, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x6f, 0x72, 0x67, 0x6f, 0x6e, 0x65, 0x22, 0xb9,
	0x04, 0x0a, 0x0e, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74,
	0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x73,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x55, 0x73, 0x65,
	0x72, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x75, 0x73, 0x65, 0x72, 0x73, 0x5f, 0x6d, 0x69, 0x67, 0x72,
	0x61, 0x74, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x75, 0x73, 0x65, 0x72,
	0x73, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x12, 0x5e, 0x0a, 0x12, 0x74, 0x6f, 0x74,
	0x61, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49,
	0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x10, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x56, 0x61,
	0x6c, 0x75, 0x65, 0x4c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x12, 0x57, 0x0a, 0x0e, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x5f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74,
	0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7,
	0xb0, 0x2a, 0x01, 0x52, 0x0d, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74,
	0x65, 0x64, 0x12, 0x60, 0x0a, 0x13, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x68, 0x61, 0x72,
	0x65, 0x73, 0x5f, 0x69, 0x73, 0x73, 0x75, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4,
	0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a,
	0x01, 0x52, 0x11, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x68, 0x61, 0x72, 0x65, 0x73, 0x49, 0x73,
	0x73, 0x75, 0x65, 0x64, 0x12, 0x54, 0x0a, 0x13, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x67,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8,
	0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x11, 0x6c, 0x61, 0x73, 0x74, 0x4d, 0x69, 0x67,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x39, 0x0a, 0x19, 0x61, 0x76,
	0x65, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x67, 0x61, 0x73, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x6d, 0x69,
	0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x16, 0x61,
	0x76, 0x65, 0x72, 0x61, 0x67, 0x65, 0x47, 0x61, 0x73, 0x50, 0x65, 0x72, 0x4d, 0x69, 0x67, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x33, 0x0a, 0x15, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74,
	0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x14, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x69, 0x6f, 0x6e,
	0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x22, 0xa3, 0x02, 0x0a, 0x14, 0x4c,
	0x6f, 0x63, 0x6b, 0x65, 0x64, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x50, 0x6f, 0x73, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x12, 0x3c, 0x0a, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f,
	0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x50,
	0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x41, 0x0a, 0x09, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x08, 0x6c, 0x6f, 0x63, 0x6b,
	0x65, 0x64, 0x41, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64,
	0x5f, 0x74, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0a, 0x6d, 0x69, 0x67, 0x72, 0x61,
	0x74, 0x65, 0x64, 0x54, 0x6f, 0x12, 0x21, 0x0a, 0x0c, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6d, 0x69, 0x67,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x25, 0x0a, 0x0e, 0x75, 0x6e, 0x6c, 0x6f,
	0x63, 0x6b, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x0d, 0x75, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12,
	0x1f, 0x0a, 0x0b, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x6c, 0x6f, 0x63, 0x6b, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e,
	0x22, 0xfa, 0x03, 0x0a, 0x10, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72,
	0x65, 0x76, 0x69, 0x65, 0x77, 0x12, 0x51, 0x0a, 0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00,
	0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f,
	0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0a, 0x74, 0x6f,
	0x74, 0x61, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x5b, 0x0a, 0x10, 0x70, 0x72, 0x69, 0x6e,
	0x63, 0x69, 0x70, 0x61, 0x6c, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e,
	0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8,
	0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0f, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x41,
	0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x59, 0x0a, 0x0f, 0x61, 0x63, 0x63, 0x72, 0x75, 0x65, 0x64,
	0x5f, 0x72, 0x65, 0x77, 0x61, 0x72, 0x64, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d,
	0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01,
	0x52, 0x0e, 0x61, 0x63, 0x63, 0x72, 0x75, 0x65, 0x64, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x73,
	0x12, 0x5b, 0x0a, 0x10, 0x65, 0x73, 0x74, 0x69, 0x6d, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x68,
	0x61, 0x72, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00,
	0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f,
	0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0f, 0x65, 0x73,
	0x74, 0x69, 0x6d, 0x61, 0x74, 0x65, 0x64, 0x53, 0x68, 0x61, 0x72, 0x65, 0x73, 0x12, 0x57, 0x0a,
	0x0b, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x6e, 0x61, 0x76, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x36, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65,
	0x67, 0x61, 0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x44, 0x65, 0x63, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0a, 0x63, 0x75, 0x72, 0x72,
	0x65, 0x6e, 0x74, 0x4e, 0x61, 0x76, 0x12, 0x25, 0x0a, 0x0e, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d,
	0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0xc1, 0x01,
	0x0a, 0x14, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x6c, 0x6f, 0x63, 0x6b,
	0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x12, 0x1f, 0x0a, 0x0b, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e,
	0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x72, 0x65, 0x61,
	0x73, 0x6f, 0x6e, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x72, 0x65, 0x61, 0x73, 0x6f,
	0x6e, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0d, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x1c,
	0x0a, 0x09, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x72, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x09, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x72, 0x79, 0x12, 0x43, 0x0a, 0x0a,
	0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x5f, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde,
	0x1f, 0x01, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41,
	0x74, 0x22, 0x1d, 0x0a, 0x1b, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x22, 0xe0, 0x02, 0x0a, 0x1c, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x3c, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x26, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e,
	0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x12,
	0x57, 0x0a, 0x0e, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f,
	0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61,
	0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c,
	0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x12, 0x59, 0x0a, 0x0f, 0x74, 0x6f, 0x74, 0x61,
	0x6c, 0x5f, 0x72, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74,
	0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7,
	0xb0, 0x2a, 0x01, 0x52, 0x0e, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x52, 0x65, 0x6d, 0x61, 0x69, 0x6e,
	0x69, 0x6e, 0x67, 0x12, 0x25, 0x0a, 0x0e, 0x75, 0x73, 0x65, 0x72, 0x73, 0x5f, 0x6d, 0x69, 0x67,
	0x72, 0x61, 0x74, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x75, 0x73, 0x65,
	0x72, 0x73, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x64, 0x12, 0x27, 0x0a, 0x0f, 0x75, 0x73,
	0x65, 0x72, 0x73, 0x5f, 0x72, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x03, 0x52, 0x0e, 0x75, 0x73, 0x65, 0x72, 0x73, 0x52, 0x65, 0x6d, 0x61, 0x69, 0x6e,
	0x69, 0x6e, 0x67, 0x22, 0x97, 0x01, 0x0a, 0x1f, 0x51, 0x75, 0x65, 0x72, 0x79, 0x55, 0x73, 0x65,
	0x72, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x32, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69,
	0x6e, 0x67, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x40, 0x0a, 0x0a, 0x76,
	0x61, 0x75, 0x6c, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x21, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76,
	0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x75, 0x6c, 0x74, 0x54, 0x79,
	0x70, 0x65, 0x52, 0x09, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x54, 0x79, 0x70, 0x65, 0x22, 0xc7, 0x02,
	0x0a, 0x20, 0x51, 0x75, 0x65, 0x72, 0x79, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x69, 0x67, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x68, 0x61, 0x73, 0x5f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74,
	0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x68, 0x61, 0x73, 0x4d, 0x69, 0x67,
	0x72, 0x61, 0x74, 0x65, 0x64, 0x12, 0x4b, 0x0a, 0x10, 0x6c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x5f,
	0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x20, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76,
	0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x52, 0x0f, 0x6c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x12, 0x56, 0x0a, 0x10, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x6e,
	0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c,
	0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x0f, 0x6d, 0x69, 0x67, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x5b, 0x0a, 0x10, 0x65, 0x73,
	0x74, 0x69, 0x6d, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x73, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e,
	0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e,
	0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0f, 0x65, 0x73, 0x74, 0x69, 0x6d, 0x61, 0x74, 0x65,
	0x64, 0x53, 0x68, 0x61, 0x72, 0x65, 0x73, 0x22, 0x94, 0x01, 0x0a, 0x1c, 0x51, 0x75, 0x65, 0x72,
	0x79, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x65, 0x76, 0x69, 0x65,
	0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x32, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x40, 0x0a, 0x0a,
	0x76, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x21, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e,
	0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x75, 0x6c, 0x74, 0x54,
	0x79, 0x70, 0x65, 0x52, 0x09, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x54, 0x79, 0x70, 0x65, 0x22, 0x87,
	0x04, 0x0a, 0x1d, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x50, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x12, 0x51, 0x0a, 0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49,
	0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x56, 0x61,
	0x6c, 0x75, 0x65, 0x12, 0x5b, 0x0a, 0x10, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c,
	0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b,
	0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52,
	0x0f, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
	0x12, 0x59, 0x0a, 0x0f, 0x61, 0x63, 0x63, 0x72, 0x75, 0x65, 0x64, 0x5f, 0x72, 0x65, 0x77, 0x61,
	0x72, 0x64, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda,
	0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f,
	0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0e, 0x61, 0x63, 0x63,
	0x72, 0x75, 0x65, 0x64, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x73, 0x12, 0x5b, 0x0a, 0x10, 0x65,
	0x73, 0x74, 0x69, 0x6d, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x73, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49,
	0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0f, 0x65, 0x73, 0x74, 0x69, 0x6d, 0x61, 0x74,
	0x65, 0x64, 0x53, 0x68, 0x61, 0x72, 0x65, 0x73, 0x12, 0x57, 0x0a, 0x0b, 0x63, 0x75, 0x72, 0x72,
	0x65, 0x6e, 0x74, 0x5f, 0x6e, 0x61, 0x76, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x36, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b,
	0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44,
	0x65, 0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63,
	0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0a, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x4e, 0x61,
	0x76, 0x12, 0x25, 0x0a, 0x0e, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x6f,
	0x75, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x70, 0x6f, 0x73, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x2a, 0xcb, 0x01, 0x0a, 0x0e, 0x4d, 0x69, 0x67,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x1f, 0x0a, 0x1b, 0x4d,
	0x49, 0x47, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x4e,
	0x4f, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x52, 0x54, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16,
	0x4d, 0x49, 0x47, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f,
	0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x10, 0x01, 0x12, 0x1b, 0x0a, 0x17, 0x4d, 0x49, 0x47, 0x52,
	0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x43, 0x4c, 0x4f, 0x53,
	0x49, 0x4e, 0x47, 0x10, 0x02, 0x12, 0x1a, 0x0a, 0x16, 0x4d, 0x49, 0x47, 0x52, 0x41, 0x54, 0x49,
	0x4f, 0x4e, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x4c, 0x4f, 0x43, 0x4b, 0x45, 0x44, 0x10,
	0x03, 0x12, 0x1e, 0x0a, 0x1a, 0x4d, 0x49, 0x47, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x53,
	0x54, 0x41, 0x54, 0x45, 0x5f, 0x44, 0x45, 0x50, 0x52, 0x45, 0x43, 0x41, 0x54, 0x45, 0x44, 0x10,
	0x04, 0x12, 0x1d, 0x0a, 0x19, 0x4d, 0x49, 0x47, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x53,
	0x54, 0x41, 0x54, 0x45, 0x5f, 0x43, 0x41, 0x4e, 0x43, 0x45, 0x4c, 0x4c, 0x45, 0x44, 0x10, 0x05,
	0x1a, 0x04, 0x88, 0xa3, 0x1e, 0x00, 0x32, 0x97, 0x03, 0x0a, 0x0c, 0x4d, 0x69, 0x67, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x73, 0x67, 0x12, 0x71, 0x0a, 0x0f, 0x4d, 0x69, 0x67, 0x72, 0x61,
	0x74, 0x65, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2a, 0x2e, 0x6e, 0x6f, 0x62,
	0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73,
	0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x50, 0x6f,
	0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x32, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64,
	0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e,
	0x4d, 0x73, 0x67, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x89, 0x01, 0x0a, 0x17, 0x45,
	0x6d, 0x65, 0x72, 0x67, 0x65, 0x6e, 0x63, 0x79, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77,
	0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x12, 0x32, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64,
	0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e,
	0x4d, 0x73, 0x67, 0x45, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x6e, 0x63, 0x79, 0x57, 0x69, 0x74, 0x68,
	0x64, 0x72, 0x61, 0x77, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x1a, 0x3a, 0x2e, 0x6e, 0x6f, 0x62,
	0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73,
	0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x45, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x6e, 0x63, 0x79,
	0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x80, 0x01, 0x0a, 0x14, 0x55, 0x70, 0x64, 0x61, 0x74,
	0x65, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12,
	0x2f, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76,
	0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65,
	0x1a, 0x37, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e,
	0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74,
	0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x1a, 0x05, 0x80, 0xe7, 0xb0, 0x2a, 0x01,
	0x32, 0x9a, 0x03, 0x0a, 0x0e, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x51, 0x75,
	0x65, 0x72, 0x79, 0x12, 0x7c, 0x0a, 0x0f, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x33, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64,
	0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e,
	0x51, 0x75, 0x65, 0x72, 0x79, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x34, 0x2e, 0x6e, 0x6f,
	0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74,
	0x73, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x88, 0x01, 0x0a, 0x13, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x37, 0x2e, 0x6e, 0x6f, 0x62, 0x6c,
	0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e,
	0x76, 0x31, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x69, 0x67, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x38, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61,
	0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75, 0x65, 0x72,
	0x79, 0x55, 0x73, 0x65, 0x72, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x7f, 0x0a, 0x10,
	0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77,
	0x12, 0x34, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e,
	0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4d,
	0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x35, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64,
	0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x2e,
	0x51, 0x75, 0x65, 0x72, 0x79, 0x4d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72,
	0x65, 0x76, 0x69, 0x65, 0x77, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0xe0, 0x01,
	0x0a, 0x1a, 0x63, 0x6f, 0x6d, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c,
	0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x31, 0x42, 0x0e, 0x4d, 0x69,
	0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x37,
	0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x78, 0x79, 0x7a,
	0x2f, 0x76, 0x32, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2f, 0x64, 0x6f,
	0x6c, 0x6c, 0x61, 0x72, 0x2f, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2f, 0x76, 0x31, 0x3b, 0x76,
	0x61, 0x75, 0x6c, 0x74, 0x73, 0x76, 0x31, 0xa2, 0x02, 0x03, 0x4e, 0x44, 0x56, 0xaa, 0x02, 0x16,
	0x4e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x44, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x56, 0x61, 0x75,
	0x6c, 0x74, 0x73, 0x2e, 0x56, 0x31, 0xca, 0x02, 0x16, 0x4e, 0x6f, 0x62, 0x6c, 0x65, 0x5c, 0x44,
	0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x5c, 0x56, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x5c, 0x56, 0x31, 0xe2,
	0x02, 0x22, 0x4e, 0x6f, 0x62, 0x6c, 0x65, 0x5c, 0x44, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x5c, 0x56,
	0x61, 0x75, 0x6c, 0x74, 0x73, 0x5c, 0x56, 0x31, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x19, 0x4e, 0x6f, 0x62, 0x6c, 0x65, 0x3a, 0x3a, 0x44, 0x6f,
	0x6c, 0x6c, 0x61, 0x72, 0x3a, 0x3a, 0x56, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x3a, 0x3a, 0x56, 0x31,
	0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_noble_dollar_vaults_v1_migration_proto_rawDescOnce sync.Once
	file_noble_dollar_vaults_v1_migration_proto_rawDescData = file_noble_dollar_vaults_v1_migration_proto_rawDesc
)

func file_noble_dollar_vaults_v1_migration_proto_rawDescGZIP() []byte {
	file_noble_dollar_vaults_v1_migration_proto_rawDescOnce.Do(func() {
		file_noble_dollar_vaults_v1_migration_proto_rawDescData = protoimpl.X.CompressGZIP(file_noble_dollar_vaults_v1_migration_proto_rawDescData)
	})
	return file_noble_dollar_vaults_v1_migration_proto_rawDescData
}

var file_noble_dollar_vaults_v1_migration_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_noble_dollar_vaults_v1_migration_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_noble_dollar_vaults_v1_migration_proto_goTypes = []interface{}{
	(MigrationState)(0),                        // 0: noble.dollar.vaults.v1.MigrationState
	(*MsgMigratePosition)(nil),                 // 1: noble.dollar.vaults.v1.MsgMigratePosition
	(*MsgMigratePositionResponse)(nil),         // 2: noble.dollar.vaults.v1.MsgMigratePositionResponse
	(*MsgEmergencyWithdrawLegacy)(nil),         // 3: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy
	(*MsgEmergencyWithdrawLegacyResponse)(nil), // 4: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse
	(*MsgUpdateMigrationState)(nil),            // 5: noble.dollar.vaults.v1.MsgUpdateMigrationState
	(*MsgUpdateMigrationStateResponse)(nil),    // 6: noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse
	(*MigrationConfig)(nil),                    // 7: noble.dollar.vaults.v1.MigrationConfig
	(*UserMigrationRecord)(nil),                // 8: noble.dollar.vaults.v1.UserMigrationRecord
	(*MigrationStats)(nil),                     // 9: noble.dollar.vaults.v1.MigrationStats
	(*LockedLegacyPosition)(nil),               // 10: noble.dollar.vaults.v1.LockedLegacyPosition
	(*MigrationPreview)(nil),                   // 11: noble.dollar.vaults.v1.MigrationPreview
	(*MigrationBlockReason)(nil),               // 12: noble.dollar.vaults.v1.MigrationBlockReason
	(*QueryMigrationStatusRequest)(nil),        // 13: noble.dollar.vaults.v1.QueryMigrationStatusRequest
	(*QueryMigrationStatusResponse)(nil),       // 14: noble.dollar.vaults.v1.QueryMigrationStatusResponse
	(*QueryUserMigrationStatusRequest)(nil),    // 15: noble.dollar.vaults.v1.QueryUserMigrationStatusRequest
	(*QueryUserMigrationStatusResponse)(nil),   // 16: noble.dollar.vaults.v1.QueryUserMigrationStatusResponse
	(*QueryMigrationPreviewRequest)(nil),       // 17: noble.dollar.vaults.v1.QueryMigrationPreviewRequest
	(*QueryMigrationPreviewResponse)(nil),      // 18: noble.dollar.vaults.v1.QueryMigrationPreviewResponse
	(VaultType)(0),                             // 19: noble.dollar.vaults.v1.VaultType
	(*timestamppb.Timestamp)(nil),              // 20: google.protobuf.Timestamp
	(*Position)(nil),                           // 21: noble.dollar.vaults.v1.Position
}
var file_noble_dollar_vaults_v1_migration_proto_depIdxs = []int32{
	19, // 0: noble.dollar.vaults.v1.MsgMigratePosition.vault_type:type_name -> noble.dollar.vaults.v1.VaultType
	19, // 1: noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy.vault_type:type_name -> noble.dollar.vaults.v1.VaultType
	0,  // 2: noble.dollar.vaults.v1.MsgUpdateMigrationState.new_state:type_name -> noble.dollar.vaults.v1.MigrationState
	0,  // 3: noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.previous_state:type_name -> noble.dollar.vaults.v1.MigrationState
	0,  // 4: noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.new_state:type_name -> noble.dollar.vaults.v1.MigrationState
	20, // 5: noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse.updated_at:type_name -> google.protobuf.Timestamp
	20, // 6: noble.dollar.vaults.v1.MigrationConfig.start_time:type_name -> google.protobuf.Timestamp
	20, // 7: noble.dollar.vaults.v1.MigrationConfig.closing_time:type_name -> google.protobuf.Timestamp
	20, // 8: noble.dollar.vaults.v1.MigrationConfig.final_deadline:type_name -> google.protobuf.Timestamp
	20, // 9: noble.dollar.vaults.v1.UserMigrationRecord.migrated_at:type_name -> google.protobuf.Timestamp
	19, // 10: noble.dollar.vaults.v1.UserMigrationRecord.from_vault_type:type_name -> noble.dollar.vaults.v1.VaultType
	20, // 11: noble.dollar.vaults.v1.MigrationStats.last_migration_time:type_name -> google.protobuf.Timestamp
	21, // 12: noble.dollar.vaults.v1.LockedLegacyPosition.position:type_name -> noble.dollar.vaults.v1.Position
	20, // 13: noble.dollar.vaults.v1.LockedLegacyPosition.locked_at:type_name -> google.protobuf.Timestamp
	20, // 14: noble.dollar.vaults.v1.MigrationBlockReason.expires_at:type_name -> google.protobuf.Timestamp
	0,  // 15: noble.dollar.vaults.v1.QueryMigrationStatusResponse.state:type_name -> noble.dollar.vaults.v1.MigrationState
	19, // 16: noble.dollar.vaults.v1.QueryUserMigrationStatusRequest.vault_type:type_name -> noble.dollar.vaults.v1.VaultType
	21, // 17: noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.legacy_positions:type_name -> noble.dollar.vaults.v1.Position
	8,  // 18: noble.dollar.vaults.v1.QueryUserMigrationStatusResponse.migration_record:type_name -> noble.dollar.vaults.v1.UserMigrationRecord
	19, // 19: noble.dollar.vaults.v1.QueryMigrationPreviewRequest.vault_type:type_name -> noble.dollar.vaults.v1.VaultType
	1,  // 20: noble.dollar.vaults.v1.MigrationMsg.MigratePosition:input_type -> noble.dollar.vaults.v1.MsgMigratePosition
	3,  // 21: noble.dollar.vaults.v1.MigrationMsg.EmergencyWithdrawLegacy:input_type -> noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacy
	5,  // 22: noble.dollar.vaults.v1.MigrationMsg.UpdateMigrationState:input_type -> noble.dollar.vaults.v1.MsgUpdateMigrationState
	13, // 23: noble.dollar.vaults.v1.MigrationQuery.MigrationStatus:input_type -> noble.dollar.vaults.v1.QueryMigrationStatusRequest
	15, // 24: noble.dollar.vaults.v1.MigrationQuery.UserMigrationStatus:input_type -> noble.dollar.vaults.v1.QueryUserMigrationStatusRequest
	17, // 25: noble.dollar.vaults.v1.MigrationQuery.MigrationPreview:input_type -> noble.dollar.vaults.v1.QueryMigrationPreviewRequest
	2,  // 26: noble.dollar.vaults.v1.MigrationMsg.MigratePosition:output_type -> noble.dollar.vaults.v1.MsgMigratePositionResponse
	4,  // 27: noble.dollar.vaults.v1.MigrationMsg.EmergencyWithdrawLegacy:output_type -> noble.dollar.vaults.v1.MsgEmergencyWithdrawLegacyResponse
	6,  // 28: noble.dollar.vaults.v1.MigrationMsg.UpdateMigrationState:output_type -> noble.dollar.vaults.v1.MsgUpdateMigrationStateResponse
	14, // 29: noble.dollar.vaults.v1.MigrationQuery.MigrationStatus:output_type -> noble.dollar.vaults.v1.QueryMigrationStatusResponse
	16, // 30: noble.dollar.vaults.v1.MigrationQuery.UserMigrationStatus:output_type -> noble.dollar.vaults.v1.QueryUserMigrationStatusResponse
	18, // 31: noble.dollar.vaults.v1.MigrationQuery.MigrationPreview:output_type -> noble.dollar.vaults.v1.QueryMigrationPreviewResponse
	26, // [26:32] is the sub-list for method output_type
	20, // [20:26] is the sub-list for method input_type
	20, // [20:20] is the sub-list for extension type_name
	20, // [20:20] is the sub-list for extension extendee
	0,  // [0:20] is the sub-list for field type_name
}

func init() { file_noble_dollar_vaults_v1_migration_proto_init() }
func file_noble_dollar_vaults_v1_migration_proto_init() {
	if File_noble_dollar_vaults_v1_migration_proto != nil {
		return
	}
	file_noble_dollar_vaults_v1_vaults_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgMigratePosition); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgMigratePositionResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgEmergencyWithdrawLegacy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgEmergencyWithdrawLegacyResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateMigrationState); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateMigrationStateResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MigrationConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UserMigrationRecord); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MigrationStats); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LockedLegacyPosition); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MigrationPreview); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MigrationBlockReason); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QueryMigrationStatusRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QueryMigrationStatusResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QueryUserMigrationStatusRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QueryUserMigrationStatusResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QueryMigrationPreviewRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v1_migration_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QueryMigrationPreviewResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_noble_dollar_vaults_v1_migration_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   18,
			NumExtensions: 0,
			NumServices:   2,
		},
		GoTypes:           file_noble_dollar_vaults_v1_migration_proto_goTypes,
		DependencyIndexes: file_noble_dollar_vaults_v1_migration_proto_depIdxs,
		EnumInfos:         file_noble_dollar_vaults_v1_migration_proto_enumTypes,
		MessageInfos:      file_noble_dollar_vaults_v1_migration_proto_msgTypes,
	}.Build()
	File_noble_dollar_vaults_v1_migration_proto = out.File
	file_noble_dollar_vaults_v1_migration_proto_rawDesc = nil
	file_noble_dollar_vaults_v1_migration_proto_goTypes = nil
	file_noble_dollar_vaults_v1_migration_proto_depIdxs = nil
}
